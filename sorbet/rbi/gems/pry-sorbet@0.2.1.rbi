# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pry-sorbet` gem.
# Please instead update this file by running `bin/tapioca gem pry-sorbet`.

class Pry
  extend ::Forwardable
  extend ::Pry::Forwardable

  def initialize(options = T.unsafe(nil)); end

  def add_sticky_local(name, &block); end
  def backtrace; end
  def backtrace=(_arg0); end
  def binding_stack; end
  def binding_stack=(_arg0); end
  def color(*args, **_arg1, &block); end
  def color=(*args, **_arg1, &block); end
  def commands(*args, **_arg1, &block); end
  def commands=(*args, **_arg1, &block); end
  def complete(str); end
  def config; end
  def current_binding; end
  def current_context; end
  def custom_completions; end
  def custom_completions=(_arg0); end
  def editor(*args, **_arg1, &block); end
  def editor=(*args, **_arg1, &block); end
  def eval(line, options = T.unsafe(nil)); end
  def eval_string; end
  def eval_string=(_arg0); end
  def evaluate_ruby(code); end
  def exception_handler(*args, **_arg1, &block); end
  def exception_handler=(*args, **_arg1, &block); end
  def exec_hook(name, *args, &block); end
  def exit_value; end
  def extra_sticky_locals(*args, **_arg1, &block); end
  def extra_sticky_locals=(*args, **_arg1, &block); end
  def hooks(*args, **_arg1, &block); end
  def hooks=(*args, **_arg1, &block); end
  def inject_local(name, value, binding); end
  def inject_sticky_locals!; end
  def input(*args, **_arg1, &block); end
  def input=(*args, **_arg1, &block); end
  def input_ring; end
  def last_dir; end
  def last_dir=(_arg0); end
  def last_exception; end
  def last_exception=(exception); end
  def last_file; end
  def last_file=(_arg0); end
  def last_result; end
  def last_result=(_arg0); end
  def last_result_is_exception?; end
  def memory_size; end
  def memory_size=(size); end
  def output; end
  def output=(*args, **_arg1, &block); end
  def output_ring; end
  def pager; end
  def pager=(*args, **_arg1, &block); end
  def pop_prompt; end
  def print(*args, **_arg1, &block); end
  def print=(*args, **_arg1, &block); end
  def process_command(val); end
  def process_command_safely(val); end
  def prompt; end
  def prompt=(new_prompt); end
  def push_binding(object); end
  def push_initial_binding(target = T.unsafe(nil)); end
  def push_prompt(new_prompt); end
  def quiet?; end
  def raise_up(*args); end
  def raise_up!(*args); end
  def raise_up_common(force, *args); end
  def repl(target = T.unsafe(nil)); end
  def reset_eval_string; end
  def run_command(val); end
  def select_prompt; end
  def set_last_result(result, code = T.unsafe(nil)); end
  def should_print?; end
  def show_result(result); end
  def sticky_locals; end
  def suppress_output; end
  def suppress_output=(_arg0); end
  def update_input_history(code); end

  private

  def ensure_correct_encoding!(val); end
  def generate_prompt(prompt_proc, conf); end
  def handle_line(line, options); end
  def prompt_stack; end

  class << self
    def Code(obj); end
    def Method(obj); end
    def WrappedModule(obj); end
    def auto_resize!; end
    def binding_for(target); end
    def cli; end
    def cli=(_arg0); end
    def color(*args, **_arg1, &block); end
    def color=(*args, **_arg1, &block); end
    def commands(*args, **_arg1, &block); end
    def commands=(*args, **_arg1, &block); end
    def config; end
    def config=(_arg0); end
    def configure; end
    def critical_section; end
    def current; end
    def current_line; end
    def current_line=(_arg0); end
    def custom_completions; end
    def custom_completions=(_arg0); end
    def editor(*args, **_arg1, &block); end
    def editor=(*args, **_arg1, &block); end
    def enable_rescuing!(block = T.unsafe(nil)); end
    def eval_path; end
    def eval_path=(_arg0); end
    def exception_handler(*args, **_arg1, &block); end
    def exception_handler=(*args, **_arg1, &block); end
    def extra_sticky_locals(*args, **_arg1, &block); end
    def extra_sticky_locals=(*args, **_arg1, &block); end
    def final_session_setup; end
    def history(*args, **_arg1, &block); end
    def history=(*args, **_arg1, &block); end
    def hooks(*args, **_arg1, &block); end
    def hooks=(*args, **_arg1, &block); end
    def in_critical_section?; end
    def init; end
    def initial_session?; end
    def initial_session_setup; end
    def input(*args, **_arg1, &block); end
    def input=(*args, **_arg1, &block); end
    def last_internal_error; end
    def last_internal_error=(_arg0); end
    def line_buffer; end
    def line_buffer=(_arg0); end
    def load_file_at_toplevel(file); end
    def load_file_through_repl(file_name); end
    def load_history; end
    def load_rc_files; end
    def load_requires; end
    def load_traps; end
    def load_win32console; end
    def main; end
    def memory_size(*args, **_arg1, &block); end
    def memory_size=(*args, **_arg1, &block); end
    def output(*args, **_arg1, &block); end
    def output=(*args, **_arg1, &block); end
    def pager(*args, **_arg1, &block); end
    def pager=(*args, **_arg1, &block); end
    def print(*args, **_arg1, &block); end
    def print=(*args, **_arg1, &block); end
    def prompt(*args, **_arg1, &block); end
    def prompt=(*args, **_arg1, &block); end
    def quiet; end
    def quiet=(_arg0); end
    def rc_files_to_load; end
    def real_path_to(file); end
    def rescue(&block); end
    def rescued(e = T.unsafe(nil)); end
    def reset_defaults; end
    def run_command(command_string, options = T.unsafe(nil)); end
    def start(target = T.unsafe(nil), options = T.unsafe(nil)); end
    def toplevel_binding; end
    def toplevel_binding=(_arg0); end
    def view_clip(obj, options = T.unsafe(nil)); end

    private

    def with_rescuing(&block); end
  end
end

Pry::BINDING_METHOD_IMPL = T.let(T.unsafe(nil), Array)

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::Text
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers

  def initialize(context = T.unsafe(nil)); end

  def _pry_; end
  def _pry_=(_arg0); end
  def arg_string; end
  def arg_string=(_arg0); end
  def block; end
  def captures; end
  def captures=(_arg0); end
  def check_for_command_collision(command_match, arg_string); end
  def command_block; end
  def command_block=(_arg0); end
  def command_name; end
  def command_options; end
  def command_set; end
  def command_set=(_arg0); end
  def commands; end
  def complete(_search); end
  def context; end
  def context=(_arg0); end
  def description; end
  def eval_string; end
  def eval_string=(_arg0); end
  def hooks; end
  def hooks=(_arg0); end
  def interpolate_string(str); end
  def match; end
  def name; end
  def output; end
  def output=(_arg0); end
  def process_line(line); end
  def pry_instance; end
  def pry_instance=(_arg0); end
  def run(command_string, *args); end
  def source; end
  def state; end
  def target; end
  def target=(_arg0); end
  def target_self; end
  def tokenize(val); end
  def void; end

  private

  def after_hooks; end
  def before_hooks; end
  def call_safely(*args); end
  def call_with_hooks(*args); end
  def find_hooks(event); end
  def normalize_method_args(method, args); end
  def pass_block(arg_string); end
  def use_unpatched_symbol; end

  class << self
    def banner(arg = T.unsafe(nil)); end
    def block; end
    def block=(_arg0); end
    def command_name; end
    def command_options(arg = T.unsafe(nil)); end
    def command_options=(_arg0); end
    def command_regex; end
    def convert_to_regex(obj); end
    def default_options(match); end
    def description(arg = T.unsafe(nil)); end
    def description=(_arg0); end
    def doc; end
    def file; end
    def group(name = T.unsafe(nil)); end
    def inspect; end
    def line; end
    def match(arg = T.unsafe(nil)); end
    def match=(_arg0); end
    def match_score(val); end
    def matches?(val); end
    def name; end
    def options(arg = T.unsafe(nil)); end
    def options=(_arg0); end
    def source; end
    def source_file; end
    def source_line; end
    def state; end
    def subclass(match, description, options, helpers, &block); end
  end
end

class Pry::Command::ShowInfo < ::Pry::ClassCommand
  extend ::Pry::Helpers::BaseHelpers

  def initialize(*_arg0); end

  def code_object_header(code_object, line_num); end
  def code_object_with_accessible_source(code_object); end
  def complete(input); end
  def content_and_header_for_code_object(code_object); end
  def content_and_headers_for_all_module_candidates(mod); end
  def file_and_line_for(code_object); end
  def header(code_object); end
  def header_options; end
  def method_header(code_object, line_num); end
  def method_sections(code_object); end
  def module_header(code_object, line_num); end
  def no_definition_message; end
  def obj_name; end
  def options(opt); end
  def process; end
  def show_all_modules?(code_object); end
  def start_line_for(code_object); end
  def use_line_numbers?; end
  def valid_superclass?(code_object); end

  private

  def build_signature_string(signature); end
end

Pry::Command::VOID_VALUE = T.let(T.unsafe(nil), Object)
Pry::Commands = T.let(T.unsafe(nil), Pry::CommandSet)
Pry::EMPTY_COMPLETIONS = T.let(T.unsafe(nil), Array)
Pry::LOCAL_RC_FILE = T.let(T.unsafe(nil), String)

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  extend ::Pry::Helpers::BaseHelpers
  extend ::Forwardable
  extend ::Pry::Forwardable

  def initialize(method, known_info = T.unsafe(nil)); end

  def ==(other); end
  def alias?; end
  def aliases; end
  def bound_method?; end
  def comment; end
  def doc; end
  def dynamically_defined?; end
  def is_a?(klass); end
  def kind_of?(klass); end
  def method_missing(method_name, *args, &block); end
  def name; end
  def name_with_owner; end
  def original_name; end
  def owner(*args, **_arg1, &block); end
  def parameters(*args, **_arg1, &block); end
  def pry_method?; end
  def receiver(*args, **_arg1, &block); end
  def redefine(source); end
  def respond_to?(method_name, include_all = T.unsafe(nil)); end
  def signature; end
  def singleton_method?; end
  def source; end
  def source?; end
  def source_file; end
  def source_line; end
  def source_location; end
  def source_range; end
  def source_type; end
  def super(times = T.unsafe(nil)); end
  def unbound_method?; end
  def undefined?; end
  def visibility; end
  def wrapped; end
  def wrapped_owner; end

  private

  def c_source; end
  def method_name_from_first_line(first_ln); end
  def pry_doc_info; end
  def respond_to_missing?(method_name, include_private = T.unsafe(nil)); end
  def ruby_source; end
  def super_using_ancestors(ancestors, times = T.unsafe(nil)); end

  class << self
    def all_from_class(klass, include_super = T.unsafe(nil)); end
    def all_from_obj(obj, include_super = T.unsafe(nil)); end
    def from_binding(binding); end
    def from_class(klass, name, target = T.unsafe(nil)); end
    def from_module(klass, name, target = T.unsafe(nil)); end
    def from_obj(obj, name, target = T.unsafe(nil)); end
    def from_str(name, target = T.unsafe(nil), options = T.unsafe(nil)); end
    def instance_method_definition?(name, definition_line); end
    def instance_resolution_order(klass); end
    def lookup_method_via_binding(obj, method_name, method_type, target = T.unsafe(nil)); end
    def method_definition?(name, definition_line); end
    def resolution_order(obj); end
    def singleton_class_of(obj); end
    def singleton_class_resolution_order(klass); end
    def singleton_method_definition?(name, definition_line); end
  end
end

Pry::VERSION = T.let(T.unsafe(nil), String)
module PrySorbet; end

class PrySorbet::UnwrapCommand < ::Pry::ClassCommand
  def process; end
end

PrySorbet::VERSION = T.let(T.unsafe(nil), String)
