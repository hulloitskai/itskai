# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `liquid` gem.
# Please instead update this file by running `bin/tapioca gem liquid`.

class Array
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

Array::NOT_SET = T.let(T.unsafe(nil), Object)

class Date
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations

  def to_liquid; end
end

Date::DATE_FORMATS = T.let(T.unsafe(nil), Hash)
Date::NOT_SET = T.let(T.unsafe(nil), Object)
Date::VERSION = T.let(T.unsafe(nil), String)

class DateTime < ::Date
  include ::DateAndTime::Compatibility

  def to_liquid; end
end

DateTime::NOT_SET = T.let(T.unsafe(nil), Object)

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

class Hash
  include ::Enumerable
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

module Liquid
  class << self
    def cache_classes; end
    def cache_classes=(_arg0); end
  end
end

Liquid::AnyStartingTag = T.let(T.unsafe(nil), Regexp)
class Liquid::ArgumentError < ::Liquid::Error; end
Liquid::ArgumentSeparator = T.let(T.unsafe(nil), String)

class Liquid::Assign < ::Liquid::Tag
  # @return [Assign] a new instance of Assign
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  def blank?; end

  # Returns the value of attribute from.
  def from; end

  def render_to_output_buffer(context, output); end

  # Returns the value of attribute to.
  def to; end

  private

  def assign_score_of(val); end

  class << self
    # @api private
    # @raise [Liquid::SyntaxError]
    def raise_syntax_error(parse_context); end
  end
end

class Liquid::Assign::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::Assign::Syntax = T.let(T.unsafe(nil), Regexp)

# A Liquid file system is a way to let your templates retrieve other templates for use with the include tag.
#
# You can implement subclasses that retrieve templates from the database, from the file system using a different
# path structure, you can provide them as hard-coded inline strings, or any manner that you see fit.
#
# You can add additional instance variables, arguments, or methods as needed.
#
# Example:
#
#   Liquid::Template.file_system = Liquid::LocalFileSystem.new(template_path)
#   liquid = Liquid::Template.parse(template)
#
# This will parse the template with a LocalFileSystem implementation rooted at 'template_path'.
class Liquid::BlankFileSystem
  # Called by Liquid to retrieve a template file
  #
  # @raise [FileSystemError]
  def read_template_file(_template_path); end
end

class Liquid::Block < ::Liquid::Tag
  # @return [Block] a new instance of Block
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  def blank?; end

  def block_delimiter; end
  def block_name; end
  def nodelist; end
  def parse(tokens); end

  # @raise [SyntaxError]
  def raise_tag_never_closed(block_name); end

  # For backwards compatibility
  def render(context); end

  def unknown_tag(tag_name, _markup, _tokenizer); end

  private

  # @api public
  def new_body; end

  # @api public
  def parse_body(body, tokens); end

  class << self
    # @api private
    def raise_unknown_tag(tag, block_name, block_delimiter, parse_context); end
  end
end

Liquid::Block::MAX_DEPTH = T.let(T.unsafe(nil), Integer)

class Liquid::BlockBody
  # @return [BlockBody] a new instance of BlockBody
  def initialize; end

  # @return [Boolean]
  def blank?; end

  def freeze; end

  # Returns the value of attribute nodelist.
  def nodelist; end

  # @raise [FrozenError]
  def parse(tokenizer, parse_context, &block); end

  # Remove blank strings in the block body for a control flow tag (e.g. `if`, `for`, `case`, `unless`)
  # with a blank body.
  #
  # For example, in a conditional assignment like the following
  #
  # ```
  # {% if size > max_size %}
  #   {% assign size = max_size %}
  # {% endif %}
  # ```
  #
  # we assume the intention wasn't to output the blank spaces in the `if` tag's block body, so this method
  # will remove them to reduce the render output size.
  #
  # Note that it is now preferred to use the `liquid` tag for this use case.
  def remove_blank_strings; end

  def render(context); end
  def render_to_output_buffer(context, output); end
  def whitespace_handler(token, parse_context); end

  private

  def create_variable(token, parse_context); end

  # @yield [nil, nil]
  def parse_for_document(tokenizer, parse_context); end

  # @yield [nil, nil]
  def parse_for_liquid_tag(tokenizer, parse_context); end

  def parse_liquid_tag(markup, parse_context); end

  # @deprecated Use {.raise_missing_tag_terminator} instead
  def raise_missing_tag_terminator(token, parse_context); end

  # @deprecated Use {.raise_missing_variable_terminator} instead
  def raise_missing_variable_terminator(token, parse_context); end

  def registered_tags; end
  def render_node(context, output, node); end

  class << self
    # @api private
    # @raise [SyntaxError]
    def raise_missing_tag_terminator(token, parse_context); end

    # @api private
    # @raise [SyntaxError]
    def raise_missing_variable_terminator(token, parse_context); end

    # @api private
    def render_node(context, output, node); end

    # @api private
    def rescue_render_node(context, output, line_number, exc, blank_tag); end

    # @api private
    def unknown_tag_in_liquid_tag(tag, parse_context); end
  end
end

Liquid::BlockBody::ContentOfVariable = T.let(T.unsafe(nil), Regexp)
Liquid::BlockBody::FullToken = T.let(T.unsafe(nil), Regexp)
Liquid::BlockBody::LiquidTagToken = T.let(T.unsafe(nil), Regexp)
Liquid::BlockBody::TAGSTART = T.let(T.unsafe(nil), String)
Liquid::BlockBody::VARSTART = T.let(T.unsafe(nil), String)
Liquid::BlockBody::WhitespaceOrNothing = T.let(T.unsafe(nil), Regexp)

# Break tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% break %}
#      {% endif %}
#    {% endfor %}
class Liquid::Break < ::Liquid::Tag
  def render_to_output_buffer(context, output); end
end

Liquid::Break::INTERRUPT = T.let(T.unsafe(nil), Liquid::BreakInterrupt)

# Interrupt that is thrown whenever a {% break %} is called.
class Liquid::BreakInterrupt < ::Liquid::Interrupt; end

class Liquid::Capture < ::Liquid::Block
  # @return [Capture] a new instance of Capture
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  def blank?; end

  def render_to_output_buffer(context, output); end
end

Liquid::Capture::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Case < ::Liquid::Block
  # @return [Case] a new instance of Case
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  def blocks; end

  # Returns the value of attribute left.
  def left; end

  def nodelist; end
  def parse(tokens); end
  def render_to_output_buffer(context, output); end
  def unknown_tag(tag, markup, tokens); end

  private

  def record_else_condition(markup); end
  def record_when_condition(markup); end
end

class Liquid::Case::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::Case::Syntax = T.let(T.unsafe(nil), Regexp)
Liquid::Case::WhenSyntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Comment < ::Liquid::Block
  # @return [Boolean]
  def blank?; end

  def render_to_output_buffer(_context, output); end
  def unknown_tag(_tag, _markup, _tokens); end
end

# Container for liquid nodes which conveniently wraps decision making logic
#
# Example:
#
#   c = Condition.new(1, '==', 1)
#   c.evaluate #=> true
class Liquid::Condition
  # @return [Condition] a new instance of Condition
  def initialize(left = T.unsafe(nil), operator = T.unsafe(nil), right = T.unsafe(nil)); end

  def and(condition); end
  def attach(attachment); end

  # Returns the value of attribute attachment.
  def attachment; end

  # Returns the value of attribute child_condition.
  def child_condition; end

  # @return [Boolean]
  def else?; end

  def evaluate(context = T.unsafe(nil)); end
  def inspect; end

  # Returns the value of attribute left.
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  def left=(_arg0); end

  # Returns the value of attribute operator.
  def operator; end

  # Sets the attribute operator
  #
  # @param value the value to set the attribute operator to.
  def operator=(_arg0); end

  def or(condition); end

  # Returns the value of attribute right.
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  def right=(_arg0); end

  protected

  # Returns the value of attribute child_relation.
  def child_relation; end

  private

  def deprecated_default_context; end
  def equal_variables(left, right); end
  def interpret_condition(left, right, op, context); end

  class << self
    def operators; end
    def parse_expression(parse_context, markup); end
  end
end

class Liquid::Condition::MethodLiteral
  # @return [MethodLiteral] a new instance of MethodLiteral
  def initialize(method_name, to_s); end

  # Returns the value of attribute method_name.
  def method_name; end

  # Returns the value of attribute to_s.
  def to_s; end
end

class Liquid::Condition::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

# Context keeps the variable stack and resolves variables, as well as keywords
#
#   context['variable'] = 'testing'
#   context['variable'] #=> 'testing'
#   context['true']     #=> true
#   context['10.2232']  #=> 10.2232
#
#   context.stack do
#      context['bob'] = 'bobsen'
#   end
#
#   context['bob']  #=> nil  class Context
class Liquid::Context
  # @return [Context] a new instance of Context
  # @yield [_self]
  # @yieldparam _self [Liquid::Context] the object that the method was called on
  def initialize(environments = T.unsafe(nil), outer_scope = T.unsafe(nil), registers = T.unsafe(nil), rethrow_errors = T.unsafe(nil), resource_limits = T.unsafe(nil), static_environments = T.unsafe(nil)); end

  # Look up variable, either resolve directly after considering the name. We can directly handle
  # Strings, digits, floats and booleans (true,false).
  # If no match is made we lookup the variable in the current scope and
  # later move up to the parent blocks to see if we can resolve the variable somewhere up the tree.
  # Some special keywords return symbols. Those symbols are to be called on the rhs object in expressions
  #
  # Example:
  #   products == empty #=> products.empty?
  def [](expression); end

  # Only allow String, Numeric, Hash, Array, Proc, Boolean or <tt>Liquid::Drop</tt>
  def []=(key, value); end

  # Adds filters to this context.
  #
  # Note that this does not register the filters with the main Template object. see <tt>Template.register_filter</tt>
  # for that
  def add_filters(filters); end

  def apply_global_filter(obj); end
  def clear_instance_assigns; end

  # Returns the value of attribute environments.
  def environments; end

  # Returns the value of attribute errors.
  def errors; end

  def evaluate(object); end

  # Returns the value of attribute exception_renderer.
  def exception_renderer; end

  # Sets the attribute exception_renderer
  #
  # @param value the value to set the attribute exception_renderer to.
  def exception_renderer=(_arg0); end

  # Fetches an object starting at the local scope and then moving up the hierachy
  def find_variable(key, raise_on_not_found: T.unsafe(nil)); end

  # Returns the value of attribute global_filter.
  def global_filter; end

  # Sets the attribute global_filter
  #
  # @param value the value to set the attribute global_filter to.
  def global_filter=(_arg0); end

  def handle_error(e, line_number = T.unsafe(nil)); end

  # are there any not handled interrupts?
  #
  # @return [Boolean]
  def interrupt?; end

  def invoke(method, *args); end

  # @return [Boolean]
  def key?(key); end

  def lookup_and_evaluate(obj, key, raise_on_not_found: T.unsafe(nil)); end

  # Merge a hash of variables in the current local scope
  def merge(new_scopes); end

  # Creates a new context inheriting resource limits, filters, environment etc.,
  # but with an isolated scope.
  def new_isolated_subcontext; end

  # Returns the value of attribute partial.
  def partial; end

  # Sets the attribute partial
  #
  # @param value the value to set the attribute partial to.
  def partial=(_arg0); end

  # Pop from the stack. use <tt>Context#stack</tt> instead
  #
  # @raise [ContextError]
  def pop; end

  # pop an interrupt from the stack
  def pop_interrupt; end

  # Push new local scope on the stack. use <tt>Context#stack</tt> instead
  def push(new_scope = T.unsafe(nil)); end

  # push an interrupt to the stack. this interrupt is considered not handled.
  def push_interrupt(e); end

  # Returns the value of attribute registers.
  def registers; end

  # Returns the value of attribute resource_limits.
  def resource_limits; end

  # Returns the value of attribute scopes.
  def scopes; end

  # Pushes a new local scope on the stack, pops it at the end of the block
  #
  # Example:
  #   context.stack do
  #      context['var'] = 'hi'
  #   end
  #
  #   context['var']  #=> nil
  def stack(new_scope = T.unsafe(nil)); end

  # Returns the value of attribute static_environments.
  def static_environments; end

  # Returns the value of attribute static_registers.
  def static_registers; end

  def strainer; end

  # Returns the value of attribute strict_filters.
  def strict_filters; end

  # Sets the attribute strict_filters
  #
  # @param value the value to set the attribute strict_filters to.
  def strict_filters=(_arg0); end

  # Returns the value of attribute strict_variables.
  def strict_variables; end

  # Sets the attribute strict_variables
  #
  # @param value the value to set the attribute strict_variables to.
  def strict_variables=(_arg0); end

  # @return [Boolean]
  def tag_disabled?(tag_name); end

  # Returns the value of attribute template_name.
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  def template_name=(_arg0); end

  def warnings; end
  def with_disabled_tags(tag_names); end

  protected

  # Sets the attribute base_scope_depth
  #
  # @param value the value to set the attribute base_scope_depth to.
  def base_scope_depth=(_arg0); end

  # Sets the attribute disabled_tags
  #
  # @param value the value to set the attribute disabled_tags to.
  def disabled_tags=(_arg0); end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  def errors=(_arg0); end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  def filters=(_arg0); end

  # Sets the attribute strainer
  #
  # @param value the value to set the attribute strainer to.
  def strainer=(_arg0); end

  # Sets the attribute warnings
  #
  # @param value the value to set the attribute warnings to.
  def warnings=(_arg0); end

  private

  # Returns the value of attribute base_scope_depth.
  def base_scope_depth; end

  # @raise [StackLevelError]
  def check_overflow; end

  def internal_error; end

  # @return [Boolean]
  def overflow?; end

  def squash_instance_assigns_with_environments; end
  def try_variable_find_in_environments(key, raise_on_not_found:); end

  class << self
    def build(environments: T.unsafe(nil), outer_scope: T.unsafe(nil), registers: T.unsafe(nil), rethrow_errors: T.unsafe(nil), resource_limits: T.unsafe(nil), static_environments: T.unsafe(nil), &block); end
  end
end

class Liquid::ContextError < ::Liquid::Error; end

class Liquid::Continue < ::Liquid::Tag
  def render_to_output_buffer(context, output); end
end

Liquid::Continue::INTERRUPT = T.let(T.unsafe(nil), Liquid::ContinueInterrupt)

# Interrupt that is thrown whenever a {% continue %} is called.
class Liquid::ContinueInterrupt < ::Liquid::Interrupt; end

class Liquid::Cycle < ::Liquid::Tag
  # @return [Cycle] a new instance of Cycle
  def initialize(tag_name, markup, options); end

  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variables.
  def variables; end

  private

  def variables_from_string(markup); end
end

Liquid::Cycle::NamedSyntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Cycle::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::Cycle::SimpleSyntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Decrement < ::Liquid::Tag
  # @return [Decrement] a new instance of Decrement
  def initialize(tag_name, markup, options); end

  def render_to_output_buffer(context, output); end
end

class Liquid::DisabledError < ::Liquid::Error; end

class Liquid::Document
  # @return [Document] a new instance of Document
  def initialize(parse_context); end

  # Returns the value of attribute body.
  def body; end

  def nodelist; end
  def parse(tokenizer, parse_context); end

  # Returns the value of attribute parse_context.
  def parse_context; end

  def render(context); end
  def render_to_output_buffer(context, output); end
  def unknown_tag(tag, _markup, _tokenizer); end

  private

  def new_body; end
  def parse_body(tokenizer); end

  class << self
    def parse(tokens, parse_context); end
  end
end

# A drop in liquid is a class which allows you to export DOM like things to liquid.
# Methods of drops are callable.
# The main use for liquid drops is to implement lazy loaded objects.
# If you would like to make data available to the web designers which you don't want loaded unless needed then
# a drop is a great way to do that.
#
# Example:
#
#   class ProductDrop < Liquid::Drop
#     def top_sales
#       Shop.current.products.find(:all, :order => 'sales', :limit => 10 )
#     end
#   end
#
#   tmpl = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {%endfor%} '  )
#   tmpl.render('product' => ProductDrop.new ) # will invoke top_sales query.
#
# Your drop can either implement the methods sans any parameters
# or implement the liquid_method_missing(name) method which is a catch all.
class Liquid::Drop
  # called by liquid to invoke a drop
  def [](method_or_key); end

  # Sets the attribute context
  #
  # @param value the value to set the attribute context to.
  def context=(_arg0); end

  def inspect; end

  # called by liquid to invoke a drop
  def invoke_drop(method_or_key); end

  # @return [Boolean]
  def key?(_name); end

  # Catch all for the method
  #
  # @raise [Liquid::UndefinedDropMethod]
  def liquid_method_missing(method); end

  def to_liquid; end
  def to_s; end

  class << self
    # Check for method existence without invoking respond_to?, which creates symbols
    #
    # @return [Boolean]
    def invokable?(method_name); end

    def invokable_methods; end
  end
end

class Liquid::Echo < ::Liquid::Tag
  # @return [Echo] a new instance of Echo
  def initialize(tag_name, markup, parse_context); end

  def render(context); end

  # Returns the value of attribute variable.
  def variable; end
end

class Liquid::Echo::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

class Liquid::ElseCondition < ::Liquid::Condition
  # @return [Boolean]
  def else?; end

  def evaluate(_context); end
end

class Liquid::Error < ::StandardError
  # Returns the value of attribute line_number.
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  def line_number=(_arg0); end

  # Returns the value of attribute markup_context.
  def markup_context; end

  # Sets the attribute markup_context
  #
  # @param value the value to set the attribute markup_context to.
  def markup_context=(_arg0); end

  # Returns the value of attribute template_name.
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  def template_name=(_arg0); end

  def to_s(with_prefix = T.unsafe(nil)); end

  private

  def message_prefix; end
end

class Liquid::Expression
  class << self
    def parse(markup); end
  end
end

Liquid::Expression::FLOATS_REGEX = T.let(T.unsafe(nil), Regexp)
Liquid::Expression::INTEGERS_REGEX = T.let(T.unsafe(nil), Regexp)
Liquid::Expression::LITERALS = T.let(T.unsafe(nil), Hash)

# Use an atomic group (?>...) to avoid pathological backtracing from
# malicious input as described in https://github.com/Shopify/liquid/issues/1357
Liquid::Expression::RANGES_REGEX = T.let(T.unsafe(nil), Regexp)

class Liquid::FileSystemError < ::Liquid::Error; end
Liquid::FilterArgumentSeparator = T.let(T.unsafe(nil), String)
Liquid::FilterSeparator = T.let(T.unsafe(nil), Regexp)
class Liquid::FloatDomainError < ::Liquid::Error; end

class Liquid::For < ::Liquid::Block
  # @return [For] a new instance of For
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute collection_name.
  def collection_name; end

  # Returns the value of attribute from.
  def from; end

  # Returns the value of attribute limit.
  def limit; end

  def nodelist; end
  def parse(tokens); end
  def render_to_output_buffer(context, output); end
  def unknown_tag(tag, markup, tokens); end

  # Returns the value of attribute variable_name.
  def variable_name; end

  protected

  def lax_parse(markup); end

  # @raise [SyntaxError]
  def strict_parse(markup); end

  private

  def collection_segment(context); end
  def render_else(context, output); end
  def render_segment(context, output, segment); end
  def set_attribute(key, expr); end
end

class Liquid::For::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::For::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::ForloopDrop < ::Liquid::Drop
  # @return [ForloopDrop] a new instance of ForloopDrop
  def initialize(name, length, parentloop); end

  def first; end
  def index; end
  def index0; end
  def last; end

  # Returns the value of attribute length.
  def length; end

  def name; end

  # Returns the value of attribute parentloop.
  def parentloop; end

  def rindex; end
  def rindex0; end

  protected

  def increment!; end
end

class Liquid::I18n
  # @return [I18n] a new instance of I18n
  def initialize(path = T.unsafe(nil)); end

  def locale; end

  # Returns the value of attribute path.
  def path; end

  def t(name, vars = T.unsafe(nil)); end
  def translate(name, vars = T.unsafe(nil)); end

  private

  def deep_fetch_translation(name); end
  def interpolate(name, vars); end
end

Liquid::I18n::DEFAULT_LOCALE = T.let(T.unsafe(nil), String)
class Liquid::I18n::TranslationError < ::StandardError; end

class Liquid::If < ::Liquid::Block
  # @return [If] a new instance of If
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  def blocks; end

  def nodelist; end
  def parse(tokens); end
  def render_to_output_buffer(context, output); end
  def unknown_tag(tag, markup, tokens); end

  private

  # @raise [SyntaxError]
  def lax_parse(markup); end

  def parse_binary_comparisons(p); end
  def parse_comparison(p); end
  def parse_expression(markup); end
  def push_block(tag, markup); end
  def strict_parse(markup); end
end

Liquid::If::BOOLEAN_OPERATORS = T.let(T.unsafe(nil), Array)
Liquid::If::ELSE_TAG_NAMES = T.let(T.unsafe(nil), Array)
Liquid::If::ExpressionsAndOperators = T.let(T.unsafe(nil), Regexp)

class Liquid::If::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::If::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Ifchanged < ::Liquid::Block
  def render_to_output_buffer(context, output); end
end

class Liquid::Include < ::Liquid::Tag
  include ::Liquid::Tag::Disableable

  # @return [Include] a new instance of Include
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  def attributes; end

  def parse(_tokens); end

  # @raise [ArgumentError]
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  def variable_name_expr; end

  private

  def parse_context; end
end

class Liquid::Include::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::Include::SYNTAX = T.let(T.unsafe(nil), Regexp)
Liquid::Include::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Increment < ::Liquid::Tag
  # @return [Increment] a new instance of Increment
  def initialize(tag_name, markup, options); end

  def render_to_output_buffer(context, output); end
end

class Liquid::InlineComment < ::Liquid::Tag
  # @return [InlineComment] a new instance of InlineComment
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  def blank?; end

  def render_to_output_buffer(_context, output); end
end

class Liquid::InternalError < ::Liquid::Error; end

# An interrupt is any command that breaks processing of a block (ex: a for loop).
class Liquid::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  def initialize(message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  def message; end
end

class Liquid::Lexer
  # @return [Lexer] a new instance of Lexer
  def initialize(input); end

  def tokenize; end
end

Liquid::Lexer::COMPARISON_OPERATOR = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::DOTDOT = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::DOUBLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::IDENTIFIER = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::NUMBER_LITERAL = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::SINGLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)
Liquid::Lexer::SPECIALS = T.let(T.unsafe(nil), Hash)
Liquid::Lexer::WHITESPACE_OR_NOTHING = T.let(T.unsafe(nil), Regexp)

# This implements an abstract file system which retrieves template files named in a manner similar to Rails partials,
# ie. with the template name prefixed with an underscore. The extension ".liquid" is also added.
#
# For security reasons, template paths are only allowed to contain letters, numbers, and underscore.
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path")
#
#   file_system.full_path("mypartial")       # => "/some/path/_mypartial.liquid"
#   file_system.full_path("dir/mypartial")   # => "/some/path/dir/_mypartial.liquid"
#
# Optionally in the second argument you can specify a custom pattern for template filenames.
# The Kernel::sprintf format specification is used.
# Default pattern is "_%s.liquid".
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path", "%s.html")
#
#   file_system.full_path("index") # => "/some/path/index.html"
class Liquid::LocalFileSystem
  # @return [LocalFileSystem] a new instance of LocalFileSystem
  def initialize(root, pattern = T.unsafe(nil)); end

  # @raise [FileSystemError]
  def full_path(template_path); end

  # @raise [FileSystemError]
  def read_template_file(template_path); end

  # Returns the value of attribute root.
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  def root=(_arg0); end
end

class Liquid::MemoryError < ::Liquid::Error; end
class Liquid::MethodOverrideError < ::Liquid::Error; end

class Liquid::ParseContext
  # @return [ParseContext] a new instance of ParseContext
  def initialize(options = T.unsafe(nil)); end

  def [](option_key); end

  # Returns the value of attribute depth.
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  def depth=(_arg0); end

  # Returns the value of attribute error_mode.
  def error_mode; end

  # Returns the value of attribute line_number.
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  def line_number=(_arg0); end

  # Returns the value of attribute locale.
  def locale; end

  # Sets the attribute locale
  #
  # @param value the value to set the attribute locale to.
  def locale=(_arg0); end

  def new_block_body; end
  def new_tokenizer(markup, start_line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end
  def parse_expression(markup); end

  # Returns the value of attribute partial.
  def partial; end

  def partial=(value); end
  def partial_options; end

  # Returns the value of attribute trim_whitespace.
  def trim_whitespace; end

  # Sets the attribute trim_whitespace
  #
  # @param value the value to set the attribute trim_whitespace to.
  def trim_whitespace=(_arg0); end

  # Returns the value of attribute warnings.
  def warnings; end
end

class Liquid::ParseTreeVisitor
  # @return [ParseTreeVisitor] a new instance of ParseTreeVisitor
  def initialize(node, callbacks); end

  def add_callback_for(*classes, &block); end
  def visit(context = T.unsafe(nil)); end

  protected

  def children; end

  class << self
    def for(node, callbacks = T.unsafe(nil)); end
  end
end

class Liquid::Parser
  # @return [Parser] a new instance of Parser
  def initialize(input); end

  def argument; end
  def consume(type = T.unsafe(nil)); end

  # Only consumes the token if it matches the type
  # Returns the token's contents if it was consumed
  # or false otherwise.
  #
  # @return [Boolean]
  def consume?(type); end

  def expression; end

  # Like consume? Except for an :id token of a certain name
  #
  # @return [Boolean]
  def id?(str); end

  def jump(point); end
  def look(type, ahead = T.unsafe(nil)); end
  def variable_lookups; end
end

module Liquid::ParserSwitching
  def parse_with_selected_parser(markup); end
  def strict_parse_with_error_mode_fallback(markup); end

  private

  def markup_context(markup); end
  def strict_parse_with_error_context(markup); end
end

class Liquid::PartialCache
  class << self
    def load(template_name, context:, parse_context:); end
  end
end

Liquid::PartialTemplateParser = T.let(T.unsafe(nil), Regexp)
Liquid::QuotedFragment = T.let(T.unsafe(nil), Regexp)
Liquid::QuotedString = T.let(T.unsafe(nil), Regexp)
Liquid::RAISE_EXCEPTION_LAMBDA = T.let(T.unsafe(nil), Proc)

class Liquid::RangeLookup
  # @return [RangeLookup] a new instance of RangeLookup
  def initialize(start_obj, end_obj); end

  # Returns the value of attribute end_obj.
  def end_obj; end

  def evaluate(context); end

  # Returns the value of attribute start_obj.
  def start_obj; end

  private

  def to_integer(input); end

  class << self
    def parse(start_markup, end_markup); end
  end
end

class Liquid::RangeLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

class Liquid::Raw < ::Liquid::Block
  # @return [Raw] a new instance of Raw
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  def blank?; end

  def nodelist; end
  def parse(tokens); end
  def render_to_output_buffer(_context, output); end

  protected

  def ensure_valid_markup(tag_name, markup, parse_context); end
end

Liquid::Raw::FullTokenPossiblyInvalid = T.let(T.unsafe(nil), Regexp)
Liquid::Raw::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::Registers
  # @return [Registers] a new instance of Registers
  def initialize(registers = T.unsafe(nil)); end

  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def fetch(key, default = T.unsafe(nil), &block); end

  # @return [Boolean]
  def key?(key); end

  # Returns the value of attribute static.
  def static; end
end

Liquid::Registers::UNDEFINED = T.let(T.unsafe(nil), Object)

class Liquid::Render < ::Liquid::Tag
  include ::Liquid::Tag::Disabler
  extend ::Liquid::Tag::Disabler::ClassMethods

  # @raise [SyntaxError]
  # @return [Render] a new instance of Render
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  def attributes; end

  # @raise [::ArgumentError]
  def render_tag(context, output); end

  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  def variable_name_expr; end
end

Liquid::Render::FOR = T.let(T.unsafe(nil), String)

class Liquid::Render::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::Render::SYNTAX = T.let(T.unsafe(nil), Regexp)

class Liquid::ResourceLimits
  # @return [ResourceLimits] a new instance of ResourceLimits
  def initialize(limits); end

  # Returns the value of attribute assign_score.
  def assign_score; end

  # Returns the value of attribute assign_score_limit.
  def assign_score_limit; end

  # Sets the attribute assign_score_limit
  #
  # @param value the value to set the attribute assign_score_limit to.
  def assign_score_limit=(_arg0); end

  def increment_assign_score(amount); end
  def increment_render_score(amount); end

  # update either render_length or assign_score based on whether or not the writes are captured
  def increment_write_score(output); end

  # @raise [MemoryError]
  def raise_limits_reached; end

  # @return [Boolean]
  def reached?; end

  # Returns the value of attribute render_length_limit.
  def render_length_limit; end

  # Sets the attribute render_length_limit
  #
  # @param value the value to set the attribute render_length_limit to.
  def render_length_limit=(_arg0); end

  # Returns the value of attribute render_score.
  def render_score; end

  # Returns the value of attribute render_score_limit.
  def render_score_limit; end

  # Sets the attribute render_score_limit
  #
  # @param value the value to set the attribute render_score_limit to.
  def render_score_limit=(_arg0); end

  def reset; end
  def with_capture; end
end

class Liquid::StackLevelError < ::Liquid::Error; end
class Liquid::StandardError < ::Liquid::Error; end

module Liquid::StandardFilters
  def abs(input); end
  def append(input, string); end
  def at_least(input, n); end
  def at_most(input, n); end
  def base64_decode(input); end
  def base64_encode(input); end
  def base64_url_safe_decode(input); end
  def base64_url_safe_encode(input); end
  def capitalize(input); end
  def ceil(input); end
  def compact(input, property = T.unsafe(nil)); end
  def concat(input, array); end

  # Reformat a date using Ruby's core Time#strftime( string ) -> string
  #
  #   %a - The abbreviated weekday name (``Sun'')
  #   %A - The  full  weekday  name (``Sunday'')
  #   %b - The abbreviated month name (``Jan'')
  #   %B - The  full  month  name (``January'')
  #   %c - The preferred local date and time representation
  #   %d - Day of the month (01..31)
  #   %H - Hour of the day, 24-hour clock (00..23)
  #   %I - Hour of the day, 12-hour clock (01..12)
  #   %j - Day of the year (001..366)
  #   %m - Month of the year (01..12)
  #   %M - Minute of the hour (00..59)
  #   %p - Meridian indicator (``AM''  or  ``PM'')
  #   %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #   %S - Second of the minute (00..60)
  #   %U - Week  number  of the current year,
  #           starting with the first Sunday as the first
  #           day of the first week (00..53)
  #   %W - Week  number  of the current year,
  #           starting with the first Monday as the first
  #           day of the first week (00..53)
  #   %w - Day of the week (Sunday is 0, 0..6)
  #   %x - Preferred representation for the date alone, no time
  #   %X - Preferred representation for the time alone, no date
  #   %y - Year without a century (00..99)
  #   %Y - Year with century
  #   %Z - Time zone name
  #   %% - Literal ``%'' character
  #
  #   See also: http://www.ruby-doc.org/core/Time.html#method-i-strftime
  def date(input, format); end

  def default(input, default_value = T.unsafe(nil), options = T.unsafe(nil)); end
  def divided_by(input, operand); end
  def downcase(input); end
  def escape(input); end
  def escape_once(input); end
  def first(array); end
  def floor(input); end
  def h(input); end
  def join(input, glue = T.unsafe(nil)); end
  def last(array); end
  def lstrip(input); end
  def map(input, property); end
  def minus(input, operand); end
  def modulo(input, operand); end
  def newline_to_br(input); end
  def plus(input, operand); end
  def prepend(input, string); end
  def remove(input, string); end
  def remove_first(input, string); end
  def remove_last(input, string); end
  def replace(input, string, replacement = T.unsafe(nil)); end
  def replace_first(input, string, replacement = T.unsafe(nil)); end
  def replace_last(input, string, replacement); end
  def reverse(input); end
  def round(input, n = T.unsafe(nil)); end
  def rstrip(input); end
  def size(input); end
  def slice(input, offset, length = T.unsafe(nil)); end
  def sort(input, property = T.unsafe(nil)); end
  def sort_natural(input, property = T.unsafe(nil)); end
  def split(input, pattern); end
  def strip(input); end
  def strip_html(input); end
  def strip_newlines(input); end
  def times(input, operand); end
  def truncate(input, length = T.unsafe(nil), truncate_string = T.unsafe(nil)); end
  def truncatewords(input, words = T.unsafe(nil), truncate_string = T.unsafe(nil)); end
  def uniq(input, property = T.unsafe(nil)); end
  def upcase(input); end

  # @raise [Liquid::ArgumentError]
  def url_decode(input); end

  def url_encode(input); end
  def where(input, property, target_value = T.unsafe(nil)); end

  private

  def apply_operation(input, operand, operation); end

  # Returns the value of attribute context.
  def context; end

  def nil_safe_casecmp(a, b); end
  def nil_safe_compare(a, b); end

  # @raise [Liquid::ArgumentError]
  def raise_property_error(property); end
end

Liquid::StandardFilters::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)
Liquid::StandardFilters::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)

class Liquid::StandardFilters::InputIterator
  include ::Enumerable

  # @return [InputIterator] a new instance of InputIterator
  def initialize(input, context); end

  def compact; end
  def concat(args); end
  def each; end

  # @return [Boolean]
  def empty?; end

  def join(glue); end
  def reverse; end
  def uniq(&block); end
end

Liquid::StandardFilters::MAX_INT = T.let(T.unsafe(nil), Integer)
Liquid::StandardFilters::STRIP_HTML_BLOCKS = T.let(T.unsafe(nil), Regexp)
Liquid::StandardFilters::STRIP_HTML_TAGS = T.let(T.unsafe(nil), Regexp)

# Alias for backwards compatibility
Liquid::StaticRegisters = Liquid::Registers

# StrainerFactory is the factory for the filters system.
module Liquid::StrainerFactory
  extend ::Liquid::StrainerFactory

  def add_global_filter(filter); end
  def create(context, filters = T.unsafe(nil)); end
  def global_filter_names; end

  private

  def strainer_class_cache; end
  def strainer_from_cache(filters); end
end

class Liquid::StrainerFactory::GlobalCache < ::Liquid::StrainerTemplate
  include ::Liquid::StandardFilters
end

# StrainerTemplate is the computed class for the filters system.
# New filters are mixed into the strainer class which is then instantiated for each liquid template render run.
#
# The Strainer only allows method calls defined in filters given to it via StrainerFactory.add_global_filter,
# Context#add_filters or Template.register_filter
class Liquid::StrainerTemplate
  # @return [StrainerTemplate] a new instance of StrainerTemplate
  def initialize(context); end

  def invoke(method, *args); end

  class << self
    def add_filter(filter); end
    def filter_method_names; end

    # @private
    def inherited(subclass); end

    # @return [Boolean]
    def invokable?(method); end

    private

    def filter_methods; end
  end
end

class Liquid::SyntaxError < ::Liquid::Error; end

class Liquid::TableRow < ::Liquid::Block
  # @return [TableRow] a new instance of TableRow
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  def attributes; end

  # Returns the value of attribute collection_name.
  def collection_name; end

  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variable_name.
  def variable_name; end
end

class Liquid::TableRow::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::TableRow::Syntax = T.let(T.unsafe(nil), Regexp)

class Liquid::TablerowloopDrop < ::Liquid::Drop
  # @return [TablerowloopDrop] a new instance of TablerowloopDrop
  def initialize(length, cols); end

  # Returns the value of attribute col.
  def col; end

  def col0; end
  def col_first; end
  def col_last; end
  def first; end
  def index; end
  def index0; end
  def last; end

  # Returns the value of attribute length.
  def length; end

  def rindex; end
  def rindex0; end

  # Returns the value of attribute row.
  def row; end

  protected

  def increment!; end
end

class Liquid::Tag
  include ::Liquid::ParserSwitching

  # @return [Tag] a new instance of Tag
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  def blank?; end

  # Returns the value of attribute line_number.
  def line_number; end

  def name; end

  # Returns the value of attribute nodelist.
  def nodelist; end

  # Returns the value of attribute parse_context.
  def options; end

  def parse(_tokens); end

  # Returns the value of attribute parse_context.
  def parse_context; end

  def raw; end
  def render(_context); end

  # For backwards compatibility with custom tags. In a future release, the semantics
  # of the `render_to_output_buffer` method will become the default and the `render`
  # method will be removed.
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute tag_name.
  def tag_name; end

  private

  def parse_expression(markup); end

  class << self
    def disable_tags(*tag_names); end
    def parse(tag_name, markup, tokenizer, parse_context); end
  end
end

module Liquid::Tag::Disableable
  def disabled_error(context); end
  def render_to_output_buffer(context, output); end
end

module Liquid::Tag::Disabler
  def render_to_output_buffer(context, output); end

  class << self
    def prepended(base); end
  end
end

module Liquid::Tag::Disabler::ClassMethods
  # Returns the value of attribute disabled_tags.
  def disabled_tags; end
end

Liquid::TagAttributes = T.let(T.unsafe(nil), Regexp)
Liquid::TagEnd = T.let(T.unsafe(nil), Regexp)
Liquid::TagName = T.let(T.unsafe(nil), Regexp)
Liquid::TagStart = T.let(T.unsafe(nil), Regexp)

# Templates are central to liquid.
# Interpretating templates is a two step process. First you compile the
# source code you got. During compile time some extensive error checking is performed.
# your code should expect to get some SyntaxErrors.
#
# After you have a compiled template you can then <tt>render</tt> it.
# You can use a compiled template over and over again and keep it cached.
#
# Example:
#
#   template = Liquid::Template.parse(source)
#   template.render('user_name' => 'bob')
class Liquid::Template
  # @return [Template] a new instance of Template
  def initialize; end

  def assigns; end
  def errors; end
  def instance_assigns; end

  # Parse source code.
  # Returns self for easy chaining
  def parse(source, options = T.unsafe(nil)); end

  # Returns the value of attribute profiler.
  def profiler; end

  def registers; end

  # Render takes a hash with local variables.
  #
  # if you use the same filters over and over again consider registering them globally
  # with <tt>Template.register_filter</tt>
  #
  # if profiling was enabled in <tt>Template#parse</tt> then the resulting profiling information
  # will be available via <tt>Template#profiler</tt>
  #
  # Following options can be passed:
  #
  #  * <tt>filters</tt> : array with local filters
  #  * <tt>registers</tt> : hash with register variables. Those can be accessed from
  #    filters and tags and might be useful to integrate liquid more with its host application
  def render(*args); end

  def render!(*args); end
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute resource_limits.
  def resource_limits; end

  # Returns the value of attribute root.
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  def root=(_arg0); end

  # Returns the value of attribute warnings.
  def warnings; end

  private

  def apply_options_to_context(context, options); end
  def configure_options(options); end

  class << self
    # Returns the value of attribute default_exception_renderer.
    def default_exception_renderer; end

    # Sets the attribute default_exception_renderer
    #
    # @param value the value to set the attribute default_exception_renderer to.
    def default_exception_renderer=(_arg0); end

    # Returns the value of attribute default_resource_limits.
    def default_resource_limits; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    def error_mode; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    def error_mode=(_arg0); end

    # Returns the value of attribute file_system.
    def file_system; end

    # Sets the attribute file_system
    #
    # @param value the value to set the attribute file_system to.
    def file_system=(_arg0); end

    # creates a new <tt>Template</tt> object from liquid source code
    # To enable profiling, pass in <tt>profile: true</tt> as an option.
    # See Liquid::Profiler for more information
    def parse(source, options = T.unsafe(nil)); end

    # Pass a module with filter methods which should be available
    # to all liquid views. Good for registering the standard library
    def register_filter(mod); end

    def register_tag(name, klass); end

    # Returns the value of attribute tags.
    def tags; end

    private

    # Sets the attribute default_resource_limits
    #
    # @param value the value to set the attribute default_resource_limits to.
    def default_resource_limits=(_arg0); end

    # Sets the attribute tags
    #
    # @param value the value to set the attribute tags to.
    def tags=(_arg0); end
  end
end

class Liquid::Template::TagRegistry
  include ::Enumerable

  # @return [TagRegistry] a new instance of TagRegistry
  def initialize; end

  def [](tag_name); end
  def []=(tag_name, klass); end
  def delete(tag_name); end
  def each(&block); end

  private

  def lookup_class(name); end
end

class Liquid::TemplateFactory
  def for(_template_name); end
end

Liquid::TemplateParser = T.let(T.unsafe(nil), Regexp)

class Liquid::Tokenizer
  # @return [Tokenizer] a new instance of Tokenizer
  def initialize(source, line_numbers = T.unsafe(nil), line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  # Returns the value of attribute for_liquid_tag.
  def for_liquid_tag; end

  # Returns the value of attribute line_number.
  def line_number; end

  def shift; end

  private

  def tokenize; end
end

class Liquid::UndefinedDropMethod < ::Liquid::Error; end
class Liquid::UndefinedFilter < ::Liquid::Error; end
class Liquid::UndefinedVariable < ::Liquid::Error; end

class Liquid::Unless < ::Liquid::If
  def render_to_output_buffer(context, output); end
end

module Liquid::Usage
  class << self
    def increment(name); end
  end
end

module Liquid::Utils
  class << self
    def slice_collection(collection, from, to); end
    def slice_collection_using_each(collection, from, to); end
    def to_date(obj); end
    def to_integer(num); end
    def to_liquid_value(obj); end
    def to_number(obj); end
  end
end

Liquid::VERSION = T.let(T.unsafe(nil), String)

# Holds variables. Variables are only loaded "just in time"
# and are not evaluated as part of the render stage
#
#   {{ monkey }}
#   {{ user.name }}
#
# Variables can be combined with filters:
#
#   {{ user | link }}
class Liquid::Variable
  include ::Liquid::ParserSwitching

  # @return [Variable] a new instance of Variable
  def initialize(markup, parse_context); end

  # @return [Boolean]
  def disabled?(_context); end

  def disabled_tags; end

  # Returns the value of attribute filters.
  def filters; end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  def filters=(_arg0); end

  def lax_parse(markup); end

  # Returns the value of attribute line_number.
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  def line_number=(_arg0); end

  def markup_context(markup); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Returns the value of attribute parse_context.
  def options; end

  # Returns the value of attribute parse_context.
  def parse_context; end

  def parse_filterargs(p); end
  def raw; end
  def render(context); end
  def render_to_output_buffer(context, output); end
  def strict_parse(markup); end

  private

  def evaluate_filter_expressions(context, filter_args, filter_kwargs); end
  def parse_filter_expressions(filter_name, unparsed_args); end
end

Liquid::Variable::FilterArgsRegex = T.let(T.unsafe(nil), Regexp)
Liquid::Variable::FilterMarkupRegex = T.let(T.unsafe(nil), Regexp)
Liquid::Variable::FilterParser = T.let(T.unsafe(nil), Regexp)
Liquid::Variable::JustTagAttributes = T.let(T.unsafe(nil), Regexp)
Liquid::Variable::MarkupWithQuotedFragment = T.let(T.unsafe(nil), Regexp)

class Liquid::Variable::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::VariableAttributeSeparator = T.let(T.unsafe(nil), String)
Liquid::VariableEnd = T.let(T.unsafe(nil), Regexp)
Liquid::VariableIncompleteEnd = T.let(T.unsafe(nil), Regexp)

class Liquid::VariableLookup
  # @return [VariableLookup] a new instance of VariableLookup
  def initialize(markup); end

  def ==(other); end
  def evaluate(context); end

  # @return [Boolean]
  def lookup_command?(lookup_index); end

  # Returns the value of attribute lookups.
  def lookups; end

  # Returns the value of attribute name.
  def name; end

  protected

  def state; end

  class << self
    def parse(markup); end
  end
end

Liquid::VariableLookup::COMMAND_METHODS = T.let(T.unsafe(nil), Array)

class Liquid::VariableLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  def children; end
end

Liquid::VariableParser = T.let(T.unsafe(nil), Regexp)
Liquid::VariableSegment = T.let(T.unsafe(nil), Regexp)
Liquid::VariableSignature = T.let(T.unsafe(nil), Regexp)
Liquid::VariableStart = T.let(T.unsafe(nil), Regexp)
Liquid::WhitespaceControl = T.let(T.unsafe(nil), String)
class Liquid::ZeroDivisionError < ::Liquid::Error; end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

class Numeric
  include ::Comparable
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

Numeric::EXABYTE = T.let(T.unsafe(nil), Integer)
Numeric::GIGABYTE = T.let(T.unsafe(nil), Integer)
Numeric::KILOBYTE = T.let(T.unsafe(nil), Integer)
Numeric::MEGABYTE = T.let(T.unsafe(nil), Integer)
Numeric::PETABYTE = T.let(T.unsafe(nil), Integer)
Numeric::TERABYTE = T.let(T.unsafe(nil), Integer)

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::DeprecatedRangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::EachTimeWithZone
  include ::Enumerable

  def to_liquid; end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::MessagePack::CoreExt
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  def to_liquid; end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)

class Symbol
  include ::Comparable
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end

class Time
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations
  include ::DateAndTime::Compatibility

  def to_liquid; end
end

Time::COMMON_YEAR_DAYS_IN_MONTH = T.let(T.unsafe(nil), Array)
Time::DATE_FORMATS = T.let(T.unsafe(nil), Hash)
Time::NOT_SET = T.let(T.unsafe(nil), Object)

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::MessagePack::CoreExt
  include ::FriendlyId::UnfriendlyUtils

  def to_liquid; end
end
