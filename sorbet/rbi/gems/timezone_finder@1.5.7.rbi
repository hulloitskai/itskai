# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `timezone_finder` gem.
# Please instead update this file by running `bin/tapioca gem timezone_finder`.

# source://timezone_finder//lib/timezone_finder/helpers.rb#3
module TimezoneFinder
  class << self
    # source://timezone_finder//lib/timezone_finder.rb#5
    def create; end
  end
end

# https://github.com/MrMinimal64/timezonefinder
#
# source://timezone_finder//lib/timezone_finder/gem_version.rb#4
TimezoneFinder::BASED_SHA1_OF_PYTHON = T.let(T.unsafe(nil), String)

# source://timezone_finder//lib/timezone_finder/helpers.rb#4
class TimezoneFinder::Helpers
  class << self
    # source://timezone_finder//lib/timezone_finder/helpers.rb#167
    def all_the_same(pointer, length, id_list); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#194
    def cartesian2coords(x, y, z); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#182
    def cartesian2rad(x, y, z); end

    # :param lng_rad: lng of px in radians
    # :param lat_rad: lat of px in radians
    # :param p0_lng: lng of p0 in radians
    # :param p0_lat: lat of p0 in radians
    # :param pm1_lng: lng of pm1 in radians
    # :param pm1_lat: lat of pm1 in radians
    # :param p1_lng: lng of p1 in radians
    # :param p1_lat: lat of p1 in radians
    # :return: shortest distance between pX and the polygon section (pm1---p0---p1) in radians
    #
    # source://timezone_finder//lib/timezone_finder/helpers.rb#249
    def compute_min_distance(lng_rad, lat_rad, p0_lng, p0_lat, pm1_lng, pm1_lat, p1_lng, p1_lat); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#293
    def coord2int(double); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#214
    def coords2cartesian(lng_rad, lat_rad); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#190
    def degrees(x); end

    # uses the simplified haversine formula for this special case (lat_p1 = 0)
    # :param lng_rad: the longitude of the point in radians
    # :param lat_rad: the latitude of the point
    # :param lng_rad_p1: the latitude of the point1 on the equator (lat=0)
    # :return: distance between the point and p1 (lng_rad_p1,0) in km
    # this is only an approximation since the earth is not a real sphere
    #
    # source://timezone_finder//lib/timezone_finder/helpers.rb#224
    def distance_to_point_on_equator(lng_rad, lat_rad, lng_rad_p1); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#332
    def distance_to_polygon(lng_rad, lat_rad, nr_points, points); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#297
    def distance_to_polygon_exact(lng_rad, lat_rad, nr_points, points, trans_points); end

    # Ruby original
    # like numpy.fromfile
    #
    # source://timezone_finder//lib/timezone_finder/helpers.rb#345
    def fromfile(file, unsigned, byte_width, count); end

    # :param lng_p1: the longitude of point 1 in radians
    # :param lat_p1: the latitude of point 1 in radians
    # :param lng_p2: the longitude of point 1 in radians
    # :param lat_p2: the latitude of point 1 in radians
    # :return: distance between p1 and p2 in km
    # this is only an approximation since the earth is not a real sphere
    #
    # source://timezone_finder//lib/timezone_finder/helpers.rb#235
    def haversine(lng_p1, lat_p1, lng_p2, lat_p2); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#109
    def inside_polygon(x, y, coords); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#289
    def int2coord(int32); end

    # tests if a point pX(x,y) is Left|On|Right of an infinite line from p1 to p2
    #     Return: -1 for pX left of the line from! p1 to! p2
    #             0 for pX on the line [is not needed]
    #             1 for pX  right of the line
    #             this approach is only valid because we already know that y lies within ]y1;y2]
    #
    # source://timezone_finder//lib/timezone_finder/helpers.rb#10
    def position_to_line(x, y, x1, x2, y1, y2); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#186
    def radians(x); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#198
    def x_rotate(rad, point); end

    # source://timezone_finder//lib/timezone_finder/helpers.rb#206
    def y_rotate(rad, point); end
  end
end

# source://timezone_finder//lib/timezone_finder/timezone_names.rb#2
TimezoneFinder::TIMEZONE_NAMES = T.let(T.unsafe(nil), Array)

# This class lets you quickly find the timezone of a point on earth.
# It keeps the binary file with the timezonefinder open in reading mode to enable fast consequent access.
# In the file currently used there are two shortcuts stored per degree of latitude and one per degree of longitude
# (tests evaluated this to be the fastest setup when being used with numba)
#
# source://timezone_finder//lib/timezone_finder/timezone_finder.rb#13
class TimezoneFinder::TimezoneFinder
  # @return [TimezoneFinder] a new instance of TimezoneFinder
  #
  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#14
  def initialize; end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#137
  def _holes_of_line(line = T.unsafe(nil)); end

  # this function looks up in which polygon the point certainly is included
  # this is much slower than 'timezone_at'!
  # :param lng: longitude of the point in degree
  # :param lat: latitude in degree
  # :return: the timezone name of the polygon the point is included in or None
  #
  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#452
  def certain_timezone_at(lng: T.unsafe(nil), lat: T.unsafe(nil)); end

  # This function searches for the closest polygon in the surrounding shortcuts.
  # Make sure that the point does not lie within a polygon (for that case the algorithm is simply wrong!)
  # Note that the algorithm won't find the closest polygon when it's on the 'other end of earth'
  # (it can't search beyond the 180 deg lng border yet)
  # this checks all the polygons within [delta_degree] degree lng and lat
  # Keep in mind that x degrees lat are not the same distance apart than x degree lng!
  # This is also the reason why there could still be a closer polygon even though you got a result already.
  # order to make sure to get the closest polygon, you should increase the search radius
  # until you get a result and then increase it once more (and take that result).
  # This should only make a difference in really rare cases however.
  # :param lng: longitude of the point in degree
  # :param lat: latitude in degree
  # :param delta_degree: the 'search radius' in degree
  # :param exact_computation: when enabled the distance to every polygon edge is computed (way more complicated),
  # instead of only evaluating the distances to all the vertices (=default).
  # This only makes a real difference when polygons are very close.
  # :param return_distances: when enabled the output looks like this:
  # ( 'tz_name_of_the_closest_polygon',[ distances to all polygons in km], [tz_names of all polygons])
  # :param force_evaluation:
  # :return: the timezone name of the closest found polygon, the list of distances or None
  #
  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#266
  def closest_timezone_at(lng: T.unsafe(nil), lat: T.unsafe(nil), delta_degree: T.unsafe(nil), exact_computation: T.unsafe(nil), return_distances: T.unsafe(nil), force_evaluation: T.unsafe(nil)); end

  # sorts the polygons_id list from least to most occurrences of the zone ids (->speed up)
  # approx. 0.24% of all realistic points benefit from sorting (0.4% for random points)
  # = percentage of sorting usage for 100k points
  # in most of those cases there are only two types of zones (= entries in counted_zones) and one of them
  # has only one entry. That means after checking one polygon timezone_at() already stops.
  # Sorting only really makes sense for closest_timezone_at().
  # :param polygon_id_list:
  # :param nr_of_polygons: length of polygon_id_list
  # :param dont_sort: if this is set to True, the sorting algorithms is skipped
  # :return: sorted list of polygon_ids, sorted list of zone_ids, boolean: do all entries belong to the same zone
  #
  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#165
  def compile_id_list(polygon_id_list, nr_of_polygons, dont_sort: T.unsafe(nil)); end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#123
  def coords_of(line = T.unsafe(nil)); end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#74
  def id_of(line = T.unsafe(nil)); end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#80
  def ids_of(iterable); end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#110
  def polygons_of_shortcut(x = T.unsafe(nil), y = T.unsafe(nil)); end

  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#93
  def shortcuts_of(lng = T.unsafe(nil), lat = T.unsafe(nil)); end

  # this function looks up in which polygons the point could be included
  # to speed things up there are shortcuts being used (stored in the binary file)
  # especially for large polygons it is expensive to check if a point is really included,
  # so certain simplifications are made and even when you get a hit the point might actually
  # not be inside the polygon (for example when there is only one timezone nearby)
  # if you want to make sure a point is really inside a timezone use 'certain_timezone_at'
  # :param lng: longitude of the point in degree (-180 to 180)
  # :param lat: latitude in degree (90 to -90)
  # :return: the timezone name of the matching polygon or None
  #
  # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#392
  def timezone_at(lng: T.unsafe(nil), lat: T.unsafe(nil)); end

  class << self
    # source://timezone_finder//lib/timezone_finder/timezone_finder.rb#68
    def __del__(file); end
  end
end

# source://timezone_finder//lib/timezone_finder/gem_version.rb#2
TimezoneFinder::VERSION = T.let(T.unsafe(nil), String)
