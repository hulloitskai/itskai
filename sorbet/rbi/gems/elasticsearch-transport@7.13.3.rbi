# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `elasticsearch-transport` gem.
# Please instead update this file by running `bin/tapioca gem elasticsearch-transport`.

module Elasticsearch; end

module Elasticsearch::Client
  extend ::Elasticsearch::Client

  # A convenience wrapper for {::Elasticsearch::Transport::Client#initialize}.
  def new(arguments = T.unsafe(nil), &block); end
end

# Module to encapsulate all logging functionality.
#
# @since 7.0.0
module Elasticsearch::Loggable
  # Log a debug message.
  #
  # @example Log a debug message.
  #   log_debug('Message')
  # @param message [String] The message to log.
  # @since 7.0.0
  def log_debug(message); end

  # Log an error message.
  #
  # @example Log an error message.
  #   log_error('Message')
  # @param message [String] The message to log.
  # @since 7.0.0
  def log_error(message); end

  # Log a fatal message.
  #
  # @example Log a fatal message.
  #   log_fatal('Message')
  # @param message [String] The message to log.
  # @since 7.0.0
  def log_fatal(message); end

  # Log an info message.
  #
  # @example Log an info message.
  #   log_info('Message')
  # @param message [String] The message to log.
  # @since 7.0.0
  def log_info(message); end

  # Log a warn message.
  #
  # @example Log a warn message.
  #   log_warn('Message')
  # @param message [String] The message to log.
  # @since 7.0.0
  def log_warn(message); end
end

module Elasticsearch::Transport; end

# Handles communication with an Elasticsearch cluster.
#
# See {file:README.md README} for usage and code examples.
class Elasticsearch::Transport::Client
  include ::Elasticsearch::Transport::MetaHeader
  include ::Elasticsearch::API
  include ::Elasticsearch::API::Shutdown
  include ::Elasticsearch::API::Features
  include ::Elasticsearch::API::DanglingIndices
  include ::Elasticsearch::API::Remote
  include ::Elasticsearch::API::Cat
  include ::Elasticsearch::API::Tasks
  include ::Elasticsearch::API::Snapshot
  include ::Elasticsearch::API::Ingest
  include ::Elasticsearch::API::Indices
  include ::Elasticsearch::API::Nodes
  include ::Elasticsearch::API::Cluster
  include ::Elasticsearch::API::Actions
  include ::Elasticsearch::API::Common

  # Create a client connected to an Elasticsearch cluster.
  #
  # Specify the URL via arguments or set the `ELASTICSEARCH_URL` environment variable.
  #
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option arguments
  # @option api_key
  # @option opaque_id_prefix
  # @option enable_meta_header
  # @param arguments [Hash] a customizable set of options
  # @param api_key [Hash] a customizable set of options
  # @param opaque_id_prefix [Hash] a customizable set of options
  # @param enable_meta_header [Hash] a customizable set of options
  # @return [Client] a new instance of Client
  # @yield [faraday] Access and configure the `Faraday::Connection` instance directly with a block
  def initialize(arguments = T.unsafe(nil), &block); end

  # Performs a request through delegation to {#transport}.
  def perform_request(method, path, params = T.unsafe(nil), body = T.unsafe(nil), headers = T.unsafe(nil)); end

  # Returns the transport object.
  #
  # @see Elasticsearch::Transport::Transport::Base
  # @see Elasticsearch::Transport::Transport::HTTP::Faraday
  def transport; end

  # Returns the transport object.
  #
  # @see Elasticsearch::Transport::Transport::Base
  # @see Elasticsearch::Transport::Transport::HTTP::Faraday
  def transport=(_arg0); end

  private

  # Auto-detect the best adapter (HTTP "driver") available, based on libraries
  # loaded by the user, preferring those with persistent connections
  # ("keep-alive") by default
  #
  # @api private
  # @return [Symbol]
  def __auto_detect_adapter; end

  # Encode credentials for the Authorization Header
  # Credentials is the base64 encoding of id and api_key joined by a colon
  #
  # @see https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html
  def __encode(api_key); end

  # Normalizes and returns hosts configuration.
  #
  # Arrayifies the `hosts_config` argument and extracts `host` and `port` info from strings.
  # Performs shuffling when the `randomize_hosts` option is set.
  #
  # TODO: Refactor, so it's available in Elasticsearch::Transport::Base as well
  #
  # @api private
  # @raise [ArgumentError]
  # @return [Array<Hash>]
  def __extract_hosts(hosts_config); end

  def __parse_host(host); end
  def add_header(header); end
  def extract_cloud_creds(arguments); end
  def set_api_key; end
  def set_compatibility_header; end
end

# The default port to use if connecting using a Cloud ID.
# Updated from 9243 to 443 in client version 7.10.1
#
# @since 7.2.0
Elasticsearch::Transport::Client::DEFAULT_CLOUD_PORT = T.let(T.unsafe(nil), Integer)

# The default host and port to use if not otherwise specified.
#
# @since 7.0.0
Elasticsearch::Transport::Client::DEFAULT_HOST = T.let(T.unsafe(nil), String)

Elasticsearch::Transport::Client::DEFAULT_LOGGER = T.let(T.unsafe(nil), Proc)

# The default port to use if not otherwise specified.
#
# @since 7.2.0
Elasticsearch::Transport::Client::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

Elasticsearch::Transport::Client::DEFAULT_TRACER = T.let(T.unsafe(nil), Proc)
Elasticsearch::Transport::Client::DEFAULT_TRANSPORT_CLASS = Elasticsearch::Transport::Transport::HTTP::Faraday

# Methods for the Elastic meta header used by Cloud.
# X-Elastic-Client-Meta HTTP header which is used by Elastic Cloud and can be disabled when
# instantiating the Client with the :enable_meta_header parameter set to `false`.
module Elasticsearch::Transport::MetaHeader
  # @return [Boolean]
  def called_from?(service); end

  # We return the current version if it's a release, but if it's a pre/alpha/beta release we
  # return <VERSION_NUMBER>p
  def client_meta_version(version); end

  # @return [Boolean]
  def elasticsearch?; end

  # @return [Boolean]
  def enterprise_search?; end

  # This function tries to define the version for the Faraday adapter. If it hasn't been loaded
  # by the time we're calling this method, it's going to report the adapter (if we know it) but
  # return 0 as the version. It won't report anything when using a custom adapter we don't
  # identify.
  #
  # Returns a Hash<adapter_alias, version>
  def meta_header_adapter; end

  def meta_header_engine; end
  def meta_header_service_version; end
  def set_meta_header; end
end

# Class for wrapping a hash that could have sensitive data.
# When printed, the sensitive values will be redacted.
#
# @since 6.1.1
class Elasticsearch::Transport::Redacted < ::Hash
  # @return [Redacted] a new instance of Redacted
  # @since 6.1.1
  def initialize(elements = T.unsafe(nil)); end

  # Get a string representation of the hash.
  #
  # @return [String] The string representation of the hash.
  # @since 6.1.1
  def inspect; end

  # Get a string representation of the hash.
  #
  # @return [String] The string representation of the hash.
  # @since 6.1.1
  def to_s; end

  private

  # @since 6.1.1
  def redact(k, v, method); end

  # @since 6.1.1
  def redacted_string(method); end
end

# The keys whose values will be redacted.
#
# @since 6.1.1
Elasticsearch::Transport::Redacted::SENSITIVE_KEYS = T.let(T.unsafe(nil), Array)

# The replacement string used in place of the value for sensitive keys.
#
# @since 6.1.1
Elasticsearch::Transport::Redacted::STRING_REPLACEMENT = T.let(T.unsafe(nil), String)

module Elasticsearch::Transport::Transport; end

# @abstract Module with common functionality for transport implementations.
module Elasticsearch::Transport::Transport::Base
  include ::Elasticsearch::Loggable

  # Creates a new transport object
  #
  # @option arguments
  # @option arguments
  # @param arguments [Hash] Settings and options for the transport
  # @param block [Proc] Lambda or Proc which can be evaluated in the context of the "session" object
  # @see Client#initialize
  def initialize(arguments = T.unsafe(nil), &block); end

  # @abstract Build and return a connection.
  #   A transport implementation *must* implement this method.
  #   See {HTTP::Faraday#__build_connection} for an example.
  # @api private
  # @raise [NoMethodError]
  # @return [Connections::Connection]
  def __build_connection(host, options = T.unsafe(nil), block = T.unsafe(nil)); end

  # Builds and returns a collection of connections
  #
  # The adapters have to implement the {Base#__build_connection} method.
  #
  # @api private
  # @return [Connections::Collection]
  def __build_connections; end

  # Closes the connections collection
  #
  # @api private
  def __close_connections; end

  # Converts any non-String object to JSON
  #
  # @api private
  def __convert_to_json(o = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns a full URL based on information from host
  #
  # @api private
  # @param host [Hash] Host configuration passed in from {Client}
  def __full_url(host); end

  # Log request and response information
  #
  # @api private
  def __log_response(method, path, params, body, url, response, json, took, duration); end

  # Raise error specific for the HTTP response status or a generic server error
  #
  # @api private
  def __raise_transport_error(response); end

  # Rebuilds the connections collection in the transport.
  #
  # The methods *adds* new connections from the passed hosts to the collection,
  # and *removes* all connections not contained in the passed hosts.
  #
  # @api private
  # @return [Connections::Collection]
  def __rebuild_connections(arguments = T.unsafe(nil)); end

  # Trace the request in the `curl` format
  #
  # @api private
  def __trace(method, path, params, headers, body, url, response, json, took, duration); end

  # Returns the value of attribute connections.
  def connections; end

  # Returns the value of attribute counter.
  def counter; end

  # Returns a connection from the connection pool by delegating to {Connections::Collection#get_connection}.
  #
  # Resurrects dead connection if the `resurrect_after` timeout has passed.
  # Increments the counter and performs connection reloading if the `reload_connections` option is set.
  #
  # @return [Connections::Connection]
  # @see Connections::Collection#get_connection
  def get_connection(options = T.unsafe(nil)); end

  # @abstract Returns an Array of connection errors specific to the transport implementation.
  #   See {HTTP::Faraday#host_unreachable_exceptions} for an example.
  # @return [Array]
  def host_unreachable_exceptions; end

  # Returns the value of attribute hosts.
  def hosts; end

  # Returns the value of attribute last_request_at.
  def last_request_at; end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  # Returns the value of attribute options.
  def options; end

  # Performs a request to Elasticsearch, while handling logging, tracing, marking dead connections,
  # retrying the request and reloading the connections.
  #
  # @abstract The transport implementation has to implement this method either in full,
  #   or by invoking this method with a block. See {HTTP::Faraday#perform_request} for an example.
  # @param method [String] Request method
  # @param path [String] The API endpoint
  # @param params [Hash] Request parameters (will be serialized by {Connections::Connection#full_url})
  # @param body [Hash] Request body (will be serialized by the {#serializer})
  # @param block [Proc] Code block to evaluate, passed from the implementation
  # @param headers [Hash] Request headers (will be serialized by the {#serializer})
  # @raise [NoMethodError] If no block is passed
  # @raise [ServerError] If request failed on server
  # @raise [Error] If no connection is available
  # @return [Response]
  def perform_request(method, path, params = T.unsafe(nil), body = T.unsafe(nil), headers = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # Returns the value of attribute protocol.
  def protocol; end

  # Returns the value of attribute reload_after.
  def reload_after; end

  # Sets the attribute reload_after
  #
  # @param value the value to set the attribute reload_after to.
  def reload_after=(_arg0); end

  # Returns the value of attribute reload_connections.
  def reload_connections; end

  # Reloads and replaces the connection collection based on cluster information
  #
  # @see Sniffer#hosts
  def reload_connections!; end

  # Sets the attribute reload_connections
  #
  # @param value the value to set the attribute reload_connections to.
  def reload_connections=(_arg0); end

  # Returns the value of attribute resurrect_after.
  def resurrect_after; end

  # Sets the attribute resurrect_after
  #
  # @param value the value to set the attribute resurrect_after to.
  def resurrect_after=(_arg0); end

  # Tries to "resurrect" all eligible dead connections
  #
  # @see Connections::Connection#resurrect!
  def resurrect_dead_connections!; end

  # Returns the value of attribute serializer.
  def serializer; end

  # Sets the attribute serializer
  #
  # @param value the value to set the attribute serializer to.
  def serializer=(_arg0); end

  # Returns the value of attribute sniffer.
  def sniffer; end

  # Sets the attribute sniffer
  #
  # @param value the value to set the attribute sniffer to.
  def sniffer=(_arg0); end

  # Returns the value of attribute tracer.
  def tracer; end

  # Sets the attribute tracer
  #
  # @param value the value to set the attribute tracer to.
  def tracer=(_arg0); end

  private

  def apply_headers(client, options); end
  def decompress_response(body); end
  def find_value(hash, regex); end

  # @return [Boolean]
  def gzipped?(body); end

  # @return [Boolean]
  def use_compression?; end

  def user_agent_header(client); end
  def warnings(warning); end
end

Elasticsearch::Transport::Transport::Base::ACCEPT_ENCODING = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::CONTENT_TYPE_REGEX = T.let(T.unsafe(nil), Regexp)
Elasticsearch::Transport::Transport::Base::CONTENT_TYPE_STR = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::DEFAULT_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Requests
Elasticsearch::Transport::Transport::Base::DEFAULT_MAX_RETRIES = T.let(T.unsafe(nil), Integer)

Elasticsearch::Transport::Transport::Base::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Elasticsearch::Transport::Transport::Base::DEFAULT_PROTOCOL = T.let(T.unsafe(nil), String)

# Requests
Elasticsearch::Transport::Transport::Base::DEFAULT_RELOAD_AFTER = T.let(T.unsafe(nil), Integer)

# Seconds
Elasticsearch::Transport::Transport::Base::DEFAULT_RESURRECT_AFTER = T.let(T.unsafe(nil), Integer)

Elasticsearch::Transport::Transport::Base::DEFAULT_SERIALIZER_CLASS = Elasticsearch::Transport::Transport::Serializer::MultiJson
Elasticsearch::Transport::Transport::Base::GZIP = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::GZIP_FIRST_TWO_BYTES = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::HEX_STRING_DIRECTIVE = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::RUBY_ENCODING = T.let(T.unsafe(nil), TrueClass)
Elasticsearch::Transport::Transport::Base::SANITIZED_PASSWORD = T.let(T.unsafe(nil), String)
Elasticsearch::Transport::Transport::Base::USER_AGENT_REGEX = T.let(T.unsafe(nil), Regexp)
Elasticsearch::Transport::Transport::Base::USER_AGENT_STR = T.let(T.unsafe(nil), String)
module Elasticsearch::Transport::Transport::Connections; end

# Wraps the collection of connections for the transport object as an Enumerable object.
#
# @see Base#connections
# @see Selector::Base#select
# @see Connection
class Elasticsearch::Transport::Transport::Connections::Collection
  include ::Enumerable

  # @option arguments
  # @option arguments
  # @option arguments
  # @param arguments [Hash] a customizable set of options
  # @return [Collection] a new instance of Collection
  def initialize(arguments = T.unsafe(nil)); end

  def [](*args); end

  # Add connection(s) to the collection
  #
  # @param connections [Connection, Array] A connection or an array of connections to add
  # @return [self]
  def add(connections); end

  # Returns an Array of alive connections.
  #
  # @return [Array]
  def alive; end

  # Returns an Array of all connections, both dead and alive
  #
  # @return [Array]
  def all; end

  # Returns an Array of alive connections.
  #
  # @return [Array]
  def connections; end

  # Returns an Array of dead connections.
  #
  # @return [Array]
  def dead; end

  def each(&block); end

  # Returns a connection.
  #
  # If there are no alive connections, returns a connection with least failures.
  # Delegates to selector's `#select` method to get the connection.
  #
  # @return [Connection]
  def get_connection(options = T.unsafe(nil)); end

  # Returns an Array of hosts information in this collection as Hashes.
  #
  # @return [Array]
  def hosts; end

  # Remove connection(s) from the collection
  #
  # @param connections [Connection, Array] A connection or an array of connections to remove
  # @return [self]
  def remove(connections); end

  # Returns the value of attribute selector.
  def selector; end

  def size; end
  def slice(*args); end
end

Elasticsearch::Transport::Transport::Connections::Collection::DEFAULT_SELECTOR = Elasticsearch::Transport::Transport::Connections::Selector::RoundRobin

# Wraps the connection information and logic.
#
# The Connection instance wraps the host information (hostname, port, attributes, etc),
# as well as the "session" (a transport client object, such as a {HTTP::Faraday} instance).
#
# It provides methods to construct and properly encode the URLs and paths for passing them
# to the transport client object.
#
# It provides methods to handle connection livecycle (dead, alive, healthy).
class Elasticsearch::Transport::Transport::Connections::Connection
  # @option arguments
  # @option arguments
  # @option arguments
  # @param arguments [Hash] a customizable set of options
  # @return [Connection] a new instance of Connection
  def initialize(arguments = T.unsafe(nil)); end

  # Equality operator based on connection protocol, host, port and attributes
  #
  # @return [Boolean]
  def ==(other); end

  # Marks this connection as alive, ie. it is eligible to be returned from the pool by the selector.
  #
  # @return [self]
  def alive!; end

  # Returns the value of attribute connection.
  def connection; end

  # Marks this connection as dead, incrementing the `failures` counter and
  # storing the current time as `dead_since`.
  #
  # @return [self]
  def dead!; end

  # Returns true when this connection has been marked dead, false otherwise.
  #
  # @return [Boolean]
  def dead?; end

  # Returns the value of attribute dead_since.
  def dead_since; end

  # Returns the value of attribute failures.
  def failures; end

  # Returns the complete endpoint path with serialized parameters.
  #
  # @return [String]
  def full_path(path, params = T.unsafe(nil)); end

  # Returns the complete endpoint URL with host, port, path and serialized parameters.
  #
  # @return [String]
  def full_url(path, params = T.unsafe(nil)); end

  # Marks this connection as healthy, ie. a request has been successfully performed with it.
  #
  # @return [self]
  def healthy!; end

  # Returns the value of attribute host.
  def host; end

  # Returns the value of attribute options.
  def options; end

  # Marks this connection as alive, if the required timeout has passed.
  #
  # @return [self, nil]
  # @see DEFAULT_RESURRECT_TIMEOUT
  # @see #resurrectable?
  def resurrect!; end

  # Returns true if the connection is eligible to be resurrected as alive, false otherwise.
  #
  # @return [Boolean]
  def resurrectable?; end

  # @return [String]
  def to_s; end
end

Elasticsearch::Transport::Transport::Connections::Connection::DEFAULT_RESURRECT_TIMEOUT = T.let(T.unsafe(nil), Integer)
module Elasticsearch::Transport::Transport::Connections::Selector; end

# @abstract Common functionality for connection selector implementations.
module Elasticsearch::Transport::Transport::Connections::Selector::Base
  # @option arguments
  # @param arguments [Hash] a customizable set of options
  def initialize(arguments = T.unsafe(nil)); end

  # Returns the value of attribute connections.
  def connections; end

  # @abstract Selector strategies implement this method to
  #   select and return a connection from the pool.
  # @raise [NoMethodError]
  # @return [Connection]
  def select(options = T.unsafe(nil)); end
end

# "Random connection" selector strategy.
class Elasticsearch::Transport::Transport::Connections::Selector::Random
  include ::Elasticsearch::Transport::Transport::Connections::Selector::Base

  # Returns a random connection from the collection.
  #
  # @return [Connections::Connection]
  def select(options = T.unsafe(nil)); end
end

# "Round-robin" selector strategy (default).
class Elasticsearch::Transport::Transport::Connections::Selector::RoundRobin
  include ::Elasticsearch::Transport::Transport::Connections::Selector::Base

  # @option arguments
  # @param arguments [Hash] a customizable set of options
  # @return [RoundRobin] a new instance of RoundRobin
  def initialize(arguments = T.unsafe(nil)); end

  # Returns the next connection from the collection, rotating them in round-robin fashion.
  #
  # @return [Connections::Connection]
  def select(options = T.unsafe(nil)); end
end

Elasticsearch::Transport::Transport::ERRORS = T.let(T.unsafe(nil), Hash)

# Generic client error
class Elasticsearch::Transport::Transport::Error < ::StandardError; end

module Elasticsearch::Transport::Transport::Errors; end
class Elasticsearch::Transport::Transport::Errors::BadGateway < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::BadRequest < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::BlockedByWindowsParentalControls < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::ClientClosedRequest < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::Conflict < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::ExpectationFailed < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::Forbidden < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::Found < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::GatewayTimeout < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::Gone < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::HTTPToHTTPS < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::HTTPVersionNotSupported < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::ImATeapot < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::InternalServerError < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::LengthRequired < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::MethodNotAllowed < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::MovedPermanently < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::MultipleChoices < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::NotAcceptable < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::NotExtended < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::NotFound < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::NotImplemented < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::NotModified < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::PaymentRequired < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::PermanentRedirect < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::PreconditionFailed < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::ProxyAuthenticationRequired < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::RequestEntityTooLarge < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::RequestHeaderTooLarge < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::RequestTimeout < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::RequestURITooLong < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::RequestedRangeNotSatisfiable < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::SeeOther < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::ServiceUnavailable < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::TemporaryRedirect < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::TooManyConnectionsFromThisIP < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::Unauthorized < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::UnsupportedMediaType < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::UpgradeRequired < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::UseProxy < ::Elasticsearch::Transport::Transport::ServerError; end
class Elasticsearch::Transport::Transport::Errors::VariantAlsoNegotiates < ::Elasticsearch::Transport::Transport::ServerError; end
module Elasticsearch::Transport::Transport::HTTP; end

# The default transport implementation, using the [_Faraday_](https://rubygems.org/gems/faraday)
# library for abstracting the HTTP client.
#
# @see Transport::Base
class Elasticsearch::Transport::Transport::HTTP::Faraday
  include ::Elasticsearch::Loggable
  include ::Elasticsearch::Transport::Transport::Base

  # Builds and returns a connection
  #
  # @return [Connections::Connection]
  def __build_connection(host, options = T.unsafe(nil), block = T.unsafe(nil)); end

  # Returns an array of implementation specific connection errors.
  #
  # @return [Array]
  def host_unreachable_exceptions; end

  # Performs the request by invoking {Transport::Base#perform_request} with a block.
  #
  # @return [Response]
  # @see Transport::Base#perform_request
  def perform_request(method, path, params = T.unsafe(nil), body = T.unsafe(nil), headers = T.unsafe(nil), opts = T.unsafe(nil)); end

  private

  def user_agent_header(client); end
end

Elasticsearch::Transport::Transport::HTTP_STATUSES = T.let(T.unsafe(nil), Hash)

# Wraps the response from Elasticsearch.
class Elasticsearch::Transport::Transport::Response
  # @param status [Integer] Response status code
  # @param body [String] Response body
  # @param headers [Hash] Response headers
  # @return [Response] a new instance of Response
  def initialize(status, body, headers = T.unsafe(nil)); end

  # Returns the value of attribute body.
  def body; end

  # Returns the value of attribute headers.
  def headers; end

  # Returns the value of attribute status.
  def status; end
end

module Elasticsearch::Transport::Transport::Serializer; end

# An abstract class for implementing serializer implementations
module Elasticsearch::Transport::Transport::Serializer::Base
  # @param transport [Object] The instance of transport which uses this serializer
  def initialize(transport = T.unsafe(nil)); end
end

# A default JSON serializer (using [MultiJSON](http://rubygems.org/gems/multi_json))
class Elasticsearch::Transport::Transport::Serializer::MultiJson
  include ::Elasticsearch::Transport::Transport::Serializer::Base

  # Serialize a Hash to JSON string
  def dump(object, options = T.unsafe(nil)); end

  # De-serialize a Hash from JSON string
  def load(string, options = T.unsafe(nil)); end
end

# Elasticsearch server error (HTTP status 5xx)
class Elasticsearch::Transport::Transport::ServerError < ::Elasticsearch::Transport::Transport::Error; end

# Handles node discovery ("sniffing")
class Elasticsearch::Transport::Transport::Sniffer
  # @param transport [Object] A transport instance
  # @return [Sniffer] a new instance of Sniffer
  def initialize(transport); end

  # Retrieves the node list from the Elasticsearch's
  # [_Nodes Info API_](https://www.elastic.co/guide/reference/api/admin-cluster-nodes-info/)
  # and returns a normalized Array of information suitable for passing to transport.
  #
  # Shuffles the collection before returning it when the `randomize_hosts` option is set for transport.
  #
  # @raise [SnifferTimeoutError]
  # @return [Array<Hash>]
  def hosts; end

  # Returns the value of attribute timeout.
  def timeout; end

  # Sets the attribute timeout
  #
  # @param value the value to set the attribute timeout to.
  def timeout=(_arg0); end

  # Returns the value of attribute transport.
  def transport; end

  private

  def parse_address_port(publish_address); end
  def parse_publish_address(publish_address); end
  def perform_sniff_request; end
end

Elasticsearch::Transport::Transport::Sniffer::PROTOCOL = T.let(T.unsafe(nil), String)

# Reloading connections timeout (1 sec by default)
class Elasticsearch::Transport::Transport::SnifferTimeoutError < ::Timeout::Error; end

Elasticsearch::Transport::VERSION = T.let(T.unsafe(nil), String)
Elasticsearch::VERSION = T.let(T.unsafe(nil), String)
