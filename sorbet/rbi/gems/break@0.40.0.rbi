# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `break` gem.
# Please instead update this file by running `bin/tapioca gem break`.

module Break; end

class Break::Command
  extend ::Forwardable

  # @return [Command] a new instance of Command
  def initialize(session); end

  def context(*args, **_arg1, &block); end
  def context!(*args, **_arg1, &block); end

  # @raise [NotImplementedError]
  def execute; end

  def frontend(*args, **_arg1, &block); end

  private

  # Returns the value of attribute session.
  def session; end
end

class Break::Context
  # @return [Context] a new instance of Context
  def initialize(*bindings, depth: T.unsafe(nil)); end

  def binding; end

  # Returns the value of attribute bindings.
  def bindings; end

  # Sets the attribute bindings
  #
  # @param value the value to set the attribute bindings to.
  def bindings=(_arg0); end

  # Returns the value of attribute depth.
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  def depth=(_arg0); end

  def inspect; end
end

class Break::DownCommand < ::Break::TracePointCommand
  def execute(*_arg0); end
  def execute_trace(trace, *_arg1); end
end

module Break::Filter
  extend ::Break::Filter

  # Returns the value of attribute internal.
  def internal; end

  # @return [Boolean]
  def internal?(path); end

  def register_internal(*paths); end
end

module Break::IRB; end

class Break::IRB::Commands < ::Module
  # @return [Commands] a new instance of Commands
  def initialize(session); end

  private

  def define_command(session, name, cls); end
end

class Break::IRB::Frontend
  # @return [Frontend] a new instance of Frontend
  def initialize; end

  def attach(session); end
  def detach; end
  def notify(message); end
  def where; end

  private

  # Trying to instantiate an `IRB:Irb` object with a workspace having a
  # binding coming from `BasicObject`.
  def safely_build_irb_instance(session, workspace); end

  # Evaling `next` is a `SyntaxError` in Ruby. Since IRB does not have
  # commands support in the lexer level, we need to call the `next` command
  # in syntactically correct way.
  def special_case_next_eval(irb_context); end
end

module Break::IRB::Overrides
  def irb; end
end

class Break::NextCommand < ::Break::TracePointCommand
  def execute_trace(trace, *_arg1); end
end

module Break::Pry; end
Break::Pry::Commands = T.let(T.unsafe(nil), Pry::CommandSet)

class Break::Pry::Frontend
  def attach(session); end
  def detach; end
  def notify(message); end
  def where; end
end

module Break::Pry::PryExtensions
  def initialize(options = T.unsafe(nil)); end

  # Returns the value of attribute __break_session__.
  def __break_session__; end

  # Sets the attribute __break_session__
  #
  # @param value the value to set the attribute __break_session__ to.
  def __break_session__=(_arg0); end
end

class Break::Session
  # @return [Session] a new instance of Session
  def initialize(binding, frontend:); end

  def [](key); end
  def []=(key, value); end
  def context; end
  def context!(*bindings, depth: T.unsafe(nil)); end

  # Returns the value of attribute contexts.
  def contexts; end

  def enter; end

  # Returns the value of attribute frontend.
  def frontend; end

  def leave; end
end

class Break::StepCommand < ::Break::TracePointCommand
  def execute_trace(trace, *_arg1); end
end

class Break::TracePointCommand < ::Break::Command
  # @return [TracePointCommand] a new instance of TracePointCommand
  def initialize(*_arg0); end

  def execute(*args); end

  # @raise [NotImplementedError]
  def execute_trace; end

  private

  def context!(*args); end
  def trace_events; end

  class << self
    def trace(*events); end

    # Returns the value of attribute trace_events.
    def trace_events; end
  end
end

class Break::UpCommand < ::Break::TracePointCommand
  def execute(*_arg0); end
  def execute_trace(trace, *_arg1); end
end

Break::VERSION = T.let(T.unsafe(nil), String)

class Break::WhereCommand < ::Break::Command
  def execute(*_arg0); end
end
