# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-dns` gem.
# Please instead update this file by running `bin/tapioca gem net-dns`.


# source://net-dns//lib/net/dns/version.rb#4
module Net::DNS
  include ::Logger::Severity
  include ::Net::DNS::QueryTypes
  include ::Net::DNS::QueryClasses
end

# DNS packet header class
#
# The Net::DNS::Header class represents the header portion of a
# DNS packet. An Header object is created whenever a new packet
# is parsed or as user request.
#
#   header = Net::DNS::Header.new
#   # ;; id = 18123
#   # ;; qr = 0       opCode: 0       aa = 0  tc = 0  rd = 1
#   # ;; ra = 0       ad = 0  cd = 0  rcode = 0
#   # ;; qdCount = 1  anCount = 0     nsCount = 0     arCount = 0
#
#   header.format
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |             18123             |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |0|   0   |0|0|1|0|0| 0 |   0   |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |               1               |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |               0               |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |               0               |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#   #  |               0               |
#   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
#
#   # packet is an instance of Net::DNS::Packet
#   header = packet.header
#   puts "Answer is #{header.auth? ? '' : 'non'} authoritative"
#
# A lot of methods were written to keep a compatibility layer with
# the Perl version of the library, as long as methods name which are
# more or less the same.
#
# source://net-dns//lib/net/dns/header.rb#38
class Net::DNS::Header
  # Creates a new Net::DNS::Header object with the desired values,
  # which can be specified as an Hash argument. When called without
  # arguments, defaults are used. If a data string is passed, values
  # are taken from parsing the string.
  #
  # Examples:
  #
  #   # Create a new Net::DNS::Header object
  #   header = Net::DNS::Header.new
  #
  #   # Create a new Net::DNS::Header object passing values
  #   header = Net::DNS::Header.new(:opCode => 1, :rd => 0)
  #
  #   # Create a new Net::DNS::Header object with binary data
  #   header = Net::DNS::Header.new(data)
  #
  # Default values are:
  #
  #   :id => auto generated
  #   :qr      => 0 # Query response flag
  #   :aa      => 0 # Authoritative answer flag
  #   :tc      => 0 # Truncated packet flag
  #   :ra      => 0 # Recursiond available flag
  #   :rCode   => 0 # Response code (status of the query)
  #   :opCode  => 0 # Operational code (purpose of the query)
  #   :cd      => 0 # Checking disable flag
  #   :ad      => 0 # Only relevant in DNSSEC context
  #   :rd      => 1 # Recursion desired flag
  #   :qdCount => 1 # Number of questions in the dns packet
  #   :anCount => 0 # Number of answer RRs in the dns packet
  #   :nsCount => 0 # Number of authoritative RRs in the dns packet
  #   :arCount => 0 # Number of additional RRs in the dns packet
  #
  # See also each option for a detailed explanation of usage.
  #
  # @raise [ArgumentError]
  # @return [Header] a new instance of Header
  #
  # source://net-dns//lib/net/dns/header.rb#207
  def initialize(arg = T.unsafe(nil)); end

  # Set the +aa+ flag (authoritative answer) to either +true+
  # or +false+. You can also use 0 or 1.
  #
  # This flag indicates whether a DNS answer packet contains
  # authoritative data, meaning that is was generated by a
  # nameserver authoritative for the domain of the question.
  #
  # Must only be set to +true+ in DNS answer packets.
  #
  # source://net-dns//lib/net/dns/header.rb#415
  def aa=(val); end

  # Set the +ad+ flag  to either +true+
  # ot +false+. You can also use 0 or 1.
  #
  # The AD bit is only set on answers where signatures have
  # been cryptographically verified or the server is
  # authoritative for the data and is allowed to set the bit by policy.
  #
  # source://net-dns//lib/net/dns/header.rb#570
  def ad=(val); end

  # Reader for answer section entries number
  #
  # source://net-dns//lib/net/dns/header.rb#166
  def anCount; end

  # Sets the number of RRs in an answer section
  #
  # @raise [WrongCountError]
  #
  # source://net-dns//lib/net/dns/header.rb#622
  def anCount=(val); end

  # Reader for addictional section entries number
  #
  # source://net-dns//lib/net/dns/header.rb#170
  def arCount; end

  # Sets the number of RRs in an addictional section
  #
  # @raise [WrongCountError]
  #
  # source://net-dns//lib/net/dns/header.rb#638
  def arCount=(val); end

  # Checks whether the response is authoritative
  #
  #   if header.auth?
  #     puts "Response is authoritative"
  #   else
  #     puts "Answer is NOT authoritative"
  #   end
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#402
  def auth?; end

  # Set the +cd+ flag (checking disabled) to either +true+
  # ot +false+. You can also use 0 or 1.
  #
  # source://net-dns//lib/net/dns/header.rb#542
  def cd=(val); end

  # Checks whether checking is enabled or disabled.
  #
  # Checking is enabled by default.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#535
  def checking?; end

  # Returns the header data in binary format, appropriate
  # for use in a DNS query packet.
  #
  #   hdata = header.data
  #   puts "Header is #{hdata.size} bytes"
  #
  # source://net-dns//lib/net/dns/header.rb#312
  def data; end

  # Checks for errors in the DNS packet
  #
  #   unless header.error?
  #     puts "No errors in DNS answer packet"
  #   end
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#601
  def error?; end

  # The Net::DNS::Header#format method prints out the header
  # in a special ascii representation of data, in a way
  # similar to those often found on RFCs.
  #
  #   p Net::DNS::Header.new.format
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |             18123             |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |0|   0   |0|0|1|0|0| 0 |   0   |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |               1               |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |               0               |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |               0               |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #   #  |               0               |
  #   #  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  #
  # This can be very usefull for didactical purpouses :)
  #
  # source://net-dns//lib/net/dns/header.rb#286
  def format; end

  # Reader for +id+ attribute
  #
  # source://net-dns//lib/net/dns/header.rb#158
  def id; end

  # Set the ID for the current header. Useful when
  # performing security tests.
  #
  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/header.rb#327
  def id=(val); end

  # Inspect method, prints out all the options and relative values.
  #
  #   p Net::DNS::Header.new
  #   # ;; id = 18123
  #   # ;; qr = 0       opCode: 0       aa = 0  tc = 0  rd = 1
  #   # ;; ra = 0       ad = 0  cd = 0  rcode = 0
  #   # ;; qdCount = 1  anCount = 0     nsCount = 0     arCount = 0
  #
  # This method will maybe be changed in the future to a more pretty
  # way of display output.
  #
  # source://net-dns//lib/net/dns/header.rb#244
  def inspect; end

  # Reader for authority section entries number
  #
  # source://net-dns//lib/net/dns/header.rb#168
  def nsCount; end

  # Sets the number of RRs in an authority section
  #
  # @raise [WrongCountError]
  #
  # source://net-dns//lib/net/dns/header.rb#630
  def nsCount=(val); end

  # Reader for the operational code
  #
  # source://net-dns//lib/net/dns/header.rb#160
  def opCode; end

  # Set the +opCode+ variable to a new value. This fields indicates
  # the type of the question present in the DNS packet; +val+ can be
  # one of the values QUERY, IQUERY or STATUS.
  #
  # * QUERY is the standard DNS query
  # * IQUERY is the inverse query
  # * STATUS is used to query the nameserver for its status
  #
  # Example:
  #
  #   include Net::DNS
  #   header = Header.new
  #   header.opCode = Header::STATUS
  #
  # @raise [WrongOpcodeError]
  #
  # source://net-dns//lib/net/dns/header.rb#388
  def opCode=(val); end

  # Returns a string representation of the +opCode+
  #
  #   puts "Packet is a #{header.opCode_str}"
  #   #=> Packet is a QUERY
  #
  # source://net-dns//lib/net/dns/header.rb#370
  def opCode_str; end

  # Reader for question section entries number
  #
  # source://net-dns//lib/net/dns/header.rb#164
  def qdCount; end

  # Sets the number of entries in a question section
  #
  # @raise [WrongCountError]
  #
  # source://net-dns//lib/net/dns/header.rb#614
  def qdCount=(val); end

  # Set the +qr+ query response flag to be either +true+ or
  # +false+. You can also use the values 0 and 1. This flag
  # indicates if the DNS packet contains a query or an answer,
  # so it should be set to +true+ in DNS answer packets.
  # If +qr+ is +true+, the packet is a response.
  #
  # source://net-dns//lib/net/dns/header.rb#345
  def qr=(val); end

  # Checks whether the header is a query (+qr+ bit set to 0)
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#335
  def query?; end

  # Reader for the rCode instance
  #
  # source://net-dns//lib/net/dns/header.rb#162
  def rCode; end

  # Set the rCode value. This should only be done in DNS
  # answer packets.
  #
  # source://net-dns//lib/net/dns/header.rb#608
  def rCode=(val); end

  # Returns an error array for the header response code, or
  # +nil+ if no error is generated.
  #
  #   error, cause = header.rCode_str
  #   puts "Error #{error} cause by: #{cause}" if error
  #     #=> Error ForErr caused by: The name server
  #     #=> was unable to interpret the query
  #
  # source://net-dns//lib/net/dns/header.rb#591
  def rCode_str; end

  # Checks whether recursion is available.
  # This flag is usually set by nameservers to indicate
  # that they support recursive-type queries.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#509
  def r_available?; end

  # Set the +ra+ flag (recursion available) to either +true+ or
  # +false+. You can also use 0 and 1.
  #
  # This flag must only be set in DNS answer packets.
  #
  # source://net-dns//lib/net/dns/header.rb#518
  def ra=(val); end

  # Alias for Header#recursive= to keep compatibility
  # with the Perl version.
  #
  # source://net-dns//lib/net/dns/header.rb#501
  def rd=(val); end

  # Sets the recursion desidered bit.
  # Remember that recursion query support is
  # optional.
  #
  #   header.recursive = true
  #   hdata = header.data # suitable for sending
  #
  # Consult RFC1034 and RFC1035 for a detailed explanation
  # of how recursion works.
  #
  # source://net-dns//lib/net/dns/header.rb#483
  def recursive=(val); end

  # Checks whether the packet has a recursion bit
  # set, meaning that recursion is desired
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#469
  def recursive?; end

  # Checks whether the header is a response
  # (+qr+ bit set to 1)
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#361
  def response?; end

  # Set the +tc+ flag (truncated packet) to either +true+
  # ot +false+. You can also use 0 or 1.
  #
  # The truncated flag is used in response packets to indicate
  # that the amount of data to be trasmitted exceedes the
  # maximum allowed by the protocol in use, tipically UDP, and
  # that the data present in the packet has been truncated.
  # A different protocol (such has TCP) need to be used to
  # retrieve full data.
  #
  # Must only be set in DNS answer packets.
  #
  # source://net-dns//lib/net/dns/header.rb#453
  def tc=(val); end

  # Checks whether the packet was truncated
  #
  #   # Sending packet using UDP
  #   if header.truncated?
  #     puts "Warning, packet has been truncated!"
  #     # Sending packet using TCP
  #   end
  #   # Do something with the answer
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#437
  def truncated?; end

  # Checks whether +ad+ flag has been set.
  #
  # This flag is only relevant in DNSSEC context.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/header.rb#559
  def verified?; end

  private

  # source://net-dns//lib/net/dns/header.rb#684
  def genID; end

  # source://net-dns//lib/net/dns/header.rb#655
  def new_from_binary(str); end

  # source://net-dns//lib/net/dns/header.rb#677
  def new_from_hash(hash); end

  # source://net-dns//lib/net/dns/header.rb#646
  def new_from_scratch; end

  class << self
    # Creates a new Net::DNS::Header object from binary data, which is
    # passed as a string object as argument.
    # The configurations parameters are taken from parsing the string.
    #
    # Example:
    #
    #   # Create a new Net::DNS::Header object with binary data
    #   header = Net::DNS::Header.new(data)
    #
    #   header.auth?
    #     #=> "true" if it comes from authoritative name server
    #
    # @raise [ArgumentError]
    #
    # source://net-dns//lib/net/dns/header.rb#225
    def parse(arg); end
  end
end

# DNS Header RCode handling class
#
# It should be used internally by Net::DNS::Header class. However, it's still
# possible to instantiate it directly.
#
#   require 'net/dns/header'
#   rcode = Net::DNS::Header::RCode.new 0
#
# The RCode class represents the RCode field in the Header portion of a
# DNS packet. This field (called Response Code) is used to get informations
# about the status of a DNS operation, such as a query or an update. These
# are the values in the original Mockapetris's standard (RFC1035):
#
# * 0               No error condition
# * 1               Format error - The name server was unable to interpret
#                   the query.
# * 2               Server failure - The name server was
#                   unable to process this query due to a
#                   problem with the name server.
# * 3               Name Error - Meaningful only for
#                   responses from an authoritative name
#                   server, this code means that the
#                   domain name referenced in the query does
#                   not exist.
# * 4               Not Implemented - The name server does
#                   not support the requested kind of query.
# * 5               Refused - The name server refuses to
#                   perform the specified operation for
#                   policy reasons.  For example, a name
#                   server may not wish to provide the
#                   information to the particular requester,
#                   or a name server may not wish to perform
#                   a particular operation (e.g., zone
#                   transfer) for particular data.
# * 6-15            Reserved for future use.
#
# In the next DNS RFCs, codes 6-15 has been assigned to the following
# errors:
#
# * 6               YXDomain
# * 7               YXRRSet
# * 8               NXRRSet
# * 9               NotAuth
# * 10              NotZone
#
# More RCodes has to come for TSIGs and other operations.
#
# source://net-dns//lib/net/dns/header.rb#102
class Net::DNS::Header::RCode
  # @raise [ArgumentError]
  # @return [RCode] a new instance of RCode
  #
  # source://net-dns//lib/net/dns/header.rb#135
  def initialize(code); end

  # Returns the value of attribute code.
  #
  # source://net-dns//lib/net/dns/header.rb#131
  def code; end

  # Returns the value of attribute explanation.
  #
  # source://net-dns//lib/net/dns/header.rb#133
  def explanation; end

  # source://net-dns//lib/net/dns/header.rb#143
  def to_s; end

  # Returns the value of attribute type.
  #
  # source://net-dns//lib/net/dns/header.rb#132
  def type; end
end

# source://net-dns//lib/net/dns/names.rb#3
module Net::DNS::Names
  # source://net-dns//lib/net/dns/names.rb#89
  def dn_comp(name, offset, compnames); end

  # Expand a compressed name in a DNS Packet object. Please
  # see RFC1035 for an explanation of how the compression
  # in DNS packets works, how may it be useful and how should
  # be handled.
  #
  # This method accept two parameters: a raw packet data and an
  # offset, which indicates the point in the packet in which the
  # parsing has arrived.
  #
  # source://net-dns//lib/net/dns/names.rb#23
  def dn_expand(packet, offset); end

  # source://net-dns//lib/net/dns/names.rb#75
  def names_array(name); end

  # source://net-dns//lib/net/dns/names.rb#57
  def pack_name(name); end

  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/names.rb#111
  def valid?(name); end
end

# = Net::DNS::Packet
#
# The Net::DNS::Packet class represents an entire DNS packet,
# divided in his main section:
#
# * Header (instance of Net::DNS::Header)
# * Question (array of Net::DNS::Question objects)
# * Answer, Authority, Additional (each formed by an array of Net::DNS::RR
#   objects)
#
# You can use this class whenever you need to create a DNS packet, whether
# in an user application, in a resolver instance (have a look, for instance,
# at the <tt>Net::DNS::Resolver#send</tt> method) or for a nameserver.
#
# For example:
#
#   # Create a packet
#   packet = Net::DNS::Packet.new("www.example.com")
#   mx = Net::DNS::Packet.new("example.com", Net::DNS::MX)
#
#   # Getting packet binary data, suitable for network transmission
#   data = packet.data
#
# A packet object can be created from binary data too, like an
# answer packet just received from a network stream:
#
#   packet = Net::DNS::Packet::parse(data)
#
# Each part of a packet can be gotten by the right accessors:
#
#   header = packet.header     # Instance of Net::DNS::Header class
#   question = packet.question # Instance of Net::DNS::Question class
#
#   # Iterate over additional RRs
#   packet.additional.each do |rr|
#     puts "Got an #{rr.type} record"
#   end
#
# Some iterators have been written to easy the access of those RRs,
# which are often the most important. So instead of doing:
#
#   packet.answer.each do |rr|
#     if rr.type == Net::DNS::RR::Types::A
#       # do something with +rr.address+
#     end
#   end
#
# we can do:
#
#   packet.each_address do |ip|
#     # do something with +ip+
#   end
#
# Be sure you don't miss all the iterators in the class documentation.
#
# == Logging facility
#
# As Net::DNS::Resolver class, Net::DNS::Packet class has its own logging
# facility too. It work in the same way the other one do, so you can
# maybe want to override it or change the file descriptor.
#
#   packet = Net::DNS::Packet.new("www.example.com")
#   packet.logger = $stderr
#
#   # or even
#   packet.logger = Logger.new("/tmp/packet.log")
#
# If the <tt>Net::DNS::Packet</tt> class is directly instantiated by the <tt>Net::DNS::Resolver</tt>
# class, like the great majority of the time, it will use the same logger facility.
#
# Logger level will be set to <tt>Logger::Debug</tt> if <tt>$DEBUG</tt> variable is set.
#
# source://net-dns//lib/net/dns/packet.rb#82
class Net::DNS::Packet
  include ::Net::DNS::Names

  # Creates a new instance of <tt>Net::DNS::Packet</tt> class. Arguments are the
  # canonical name of the resource, an optional type field and an optional
  # class field. The record type and class can be omitted; they default
  # to +A+ and +IN+.
  #
  #   packet = Net::DNS::Packet.new("www.example.com")
  #   packet = Net::DNS::Packet.new("example.com", Net::DNS::MX)
  #   packet = Net::DNS::Packet.new("example.com", Net::DNS::TXT, Net::DNS::CH)
  #
  # This class no longer instantiate object from binary data coming from
  # network streams. Please use <tt>Net::DNS::Packet.parse</tt> instead.
  #
  # @return [Packet] a new instance of Packet
  #
  # source://net-dns//lib/net/dns/packet.rb#112
  def initialize(name, type = T.unsafe(nil), cls = T.unsafe(nil)); end

  # Returns the value of attribute additional.
  #
  # source://net-dns//lib/net/dns/packet.rb#97
  def additional; end

  # Assigns one or an array of <tt>Net::DNS::RR</tt> <tt>object</tt>s
  # to the additional section of this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#308
  def additional=(object); end

  # Returns the value of attribute answer.
  #
  # source://net-dns//lib/net/dns/packet.rb#95
  def answer; end

  # Assigns one or an array of <tt>Net::DNS::RR</tt> <tt>object</tt>s
  # to the answer section of this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#292
  def answer=(object); end

  # Returns the value of attribute answerfrom.
  #
  # source://net-dns//lib/net/dns/packet.rb#98
  def answerfrom; end

  # Returns the value of attribute answersize.
  #
  # source://net-dns//lib/net/dns/packet.rb#99
  def answersize; end

  # Returns the value of attribute authority.
  #
  # source://net-dns//lib/net/dns/packet.rb#96
  def authority; end

  # Assigns one or an array of <tt>Net::DNS::RR</tt> <tt>object</tt>s
  # to the authority section of this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#324
  def authority=(object); end

  # Returns the packet object in binary data, suitable
  # for sending across a network stream.
  #
  #   packet_data = packet.data
  #   puts "Packet is #{packet_data.size} bytes long"
  #
  # source://net-dns//lib/net/dns/packet.rb#133
  def data; end

  # Same as <tt>Net::DNS::Packet#data</tt>, but implements name compression
  # (see RFC1025) for a considerable save of bytes.
  #
  #   packet = Net::DNS::Packet.new("www.example.com")
  #   puts "Size normal is #{packet.data.size} bytes"
  #   puts "Size compressed is #{packet.data_comp.size} bytes"
  #
  # source://net-dns//lib/net/dns/packet.rb#170
  def data_comp; end

  # Iterates every address in the +answer+ section
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  #   packet.each_address do |ip|
  #     ping ip.to_s
  #   end
  #
  # As you can see in the documentation for the <tt>Net::DNS::RR::A</tt> class,
  # the address returned is an instance of <tt>IPAddr</tt> class.
  #
  # source://net-dns//lib/net/dns/packet.rb#347
  def each_address; end

  # Iterates every canonical name in the +answer+ section
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  #   packet.each_cname do |cname|
  #     puts "Canonical name: #{cname}"
  #   end
  #
  # source://net-dns//lib/net/dns/packet.rb#392
  def each_cname; end

  # Iterates every exchange record in the +answer+ section
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  #   packet.each_mx do |pref,name|
  #     puts "Mail exchange #{name} has preference #{pref}"
  #   end
  #
  # source://net-dns//lib/net/dns/packet.rb#377
  def each_mx; end

  # Iterates every nameserver in the +answer+ section
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  #   packet.each_nameserver do |ns|
  #     puts "Nameserver found: #{ns}"
  #   end
  #
  # source://net-dns//lib/net/dns/packet.rb#362
  def each_nameserver; end

  # Iterates every pointer in the +answer+ section
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  #   packet.each_ptr do |ptr|
  #     puts "Pointer for resource: #{ptr}"
  #   end
  #
  # source://net-dns//lib/net/dns/packet.rb#407
  def each_ptr; end

  # Returns the value of attribute header.
  #
  # source://net-dns//lib/net/dns/packet.rb#93
  def header; end

  # Assigns a <tt>Net::DNS::Header</tt> <tt>object</tt>
  # to this <tt>Net::DNS::Packet</tt> instance.
  #
  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/packet.rb#268
  def header=(object); end

  # Returns a string containing a human-readable representation
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#215
  def inspect; end

  # Checks whether the query returned a NXDOMAIN error,
  # meaning the queried domain name doesn't exist.
  #
  #   %w[a.com google.com ibm.com d.com].each do |domain|
  #     response = Net::DNS::Resolver.new.send(domain)
  #     puts "#{domain} doesn't exist" if response.nxdomain?
  #   end
  #   # => a.com doesn't exist
  #   # => d.com doesn't exist
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/packet.rb#436
  def nxdomain?; end

  # Checks if the packet is a QUERY packet
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/packet.rb#123
  def query?; end

  # Returns the value of attribute question.
  #
  # source://net-dns//lib/net/dns/packet.rb#94
  def question; end

  # Assigns a <tt>Net::DNS::Question</tt> <tt>object</tt>
  # to this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#276
  def question=(object); end

  # Returns the packet size in bytes.
  #
  #   Resolver("www.google.com") do |packet|
  #     puts packet.size + " bytes"}
  #   end
  #   # => 484 bytes
  #
  # source://net-dns//lib/net/dns/packet.rb#422
  def size; end

  # Returns a string containing a human-readable representation
  # of this <tt>Net::DNS::Packet</tt> instance.
  #
  # source://net-dns//lib/net/dns/packet.rb#215
  def to_s; end

  # Delegates to <tt>Net::DNS::Header#truncated?</tt>.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/packet.rb#262
  def truncated?; end

  private

  # New packet from binary data
  #
  # source://net-dns//lib/net/dns/packet.rb#463
  def new_from_data(data, from = T.unsafe(nil)); end

  # Parse question section
  #
  # source://net-dns//lib/net/dns/packet.rb#545
  def parse_question(data, offset); end

  class << self
    # Creates a new instance of <tt>Net::DNS::Packet</tt> class from binary data,
    # taken out from a network stream. For example:
    #
    #   # udp_socket is an UDPSocket waiting for a response
    #   ans = udp_socket.recvfrom(1500)
    #   packet = Net::DNS::Packet::parse(ans)
    #
    # An optional +from+ argument can be used to specify the information
    # of the sender. If data is passed as is from a Socket#recvfrom call,
    # the method will accept it.
    #
    # Be sure that your network data is clean from any UDP/TCP header,
    # especially when using RAW sockets.
    #
    # source://net-dns//lib/net/dns/packet.rb#454
    def parse(*args); end
  end
end

# source://net-dns//lib/net/dns.rb#84
Net::DNS::QueryTypes::CAA = T.let(T.unsafe(nil), Integer)

# source://net-dns//lib/net/dns.rb#71
Net::DNS::QueryTypes::SPF = T.let(T.unsafe(nil), Integer)

# source://net-dns//lib/net/dns.rb#83
Net::DNS::QueryTypes::URI = T.let(T.unsafe(nil), Integer)

# =Name
#
# Net::DNS::Question - DNS packet question class
#
# =Synopsis
#
#   require 'net/dns/question'
#
# =Description
#
# This class represent the Question portion of a DNS packet. The number
# of question entries is stored in the +qdCount+ variable of an Header
# object.
#
# A new object can be created passing the name of the query and the type
# of answer desired, plus an optional argument containing the class:
#
#   question = Net::DNS::Question.new("google.com.", Net::DNS::A)
#      #=> "google.com.                   A       IN"
#
# Alternatevly, a new object is created when processing a binary
# packet, as when an answer is received.
# To obtain the binary data from a question object you can use
# the method Question#data:
#
#   question.data
#      #=> "\006google\003com\000\000\001\000\001"
#
# A lot of methods were written to keep a compatibility layer with
# the Perl version of the library, as long as methods name which are
# more or less the same.
#
# source://net-dns//lib/net/dns/question.rb#36
class Net::DNS::Question
  include ::Net::DNS::Names

  # If not specified, +type+ and +cls+ arguments defaults
  # to Net::DNS::A and Net::DNS::IN respectively.
  #
  # @return [Question] a new instance of Question
  #
  # source://net-dns//lib/net/dns/question.rb#66
  def initialize(name, type = T.unsafe(nil), cls = T.unsafe(nil)); end

  # Return the binary data of the objects, plus an offset
  # and an Hash with references to compressed names. For use in
  # Net::DNS::Packet compressed packet creation.
  #
  # source://net-dns//lib/net/dns/question.rb#98
  def comp_data; end

  # Outputs binary data from a Question object
  #
  #   question.data
  #      #=> "\006google\003com\000\000\001\000\001"
  #
  # source://net-dns//lib/net/dns/question.rb#91
  def data; end

  # call-seq:
  #   question.inspect -> string
  #
  # Returns a printable version of question with nice formatting.
  #
  #   q = Net::DNS::Question.new("google.com.", Net::DNS::A)
  #   q.inspect # => "google.com.                  IN      A       "
  #
  # source://net-dns//lib/net/dns/question.rb#126
  def inspect; end

  # +class+ part of a Question entry
  #
  # source://net-dns//lib/net/dns/question.rb#52
  def qClass; end

  # +name+ part of a Question entry
  #
  # source://net-dns//lib/net/dns/question.rb#48
  def qName; end

  # +type+ part of a Question entry
  #
  # source://net-dns//lib/net/dns/question.rb#50
  def qType; end

  # call-seq:
  #   question.to_s -> string
  #
  # Returns a string representation of question.
  # It is the same as <tt>inspect</tt>.
  #
  #   q = Net::DNS::Question.new("google.com.", Net::DNS::A)
  #   q.inspect # => "google.com.                  IN      A       "
  #
  # source://net-dns//lib/net/dns/question.rb#145
  def to_s; end

  private

  # source://net-dns//lib/net/dns/question.rb#151
  def build_qName(str); end

  # source://net-dns//lib/net/dns/question.rb#166
  def check_name(input); end

  # source://net-dns//lib/net/dns/question.rb#175
  def new_from_binary(data); end

  class << self
    # Return a new Net::DNS::Question object created by
    # parsing binary data, such as an answer from the
    # nameserver.
    #
    #   question = Net::DNS::Question.parse(data)
    #   puts "Queried for #{question.qName} type #{question.qType.to_s}"
    #     #=> Queried for example.com type A
    #
    # source://net-dns//lib/net/dns/question.rb#80
    def parse(arg); end
  end
end

# = Net::DNS::RR - DNS Resource Record class
#
# The Net::DNS::RR is the base class for DNS Resource
# Record (RR) objects. A RR is a pack of data that represents
# resources for a DNS zone. The form in which this data is
# shows can be drawed as follow:
#
#   "name  ttl  class  type  data"
#
# The +name+ is the name of the resource, like an canonical
# name for an +A+ record (internet ip address). The +ttl+ is the
# time to live, expressed in seconds. +type+ and +class+ are
# respectively the type of resource (+A+ for ip addresses, +NS+
# for nameservers, and so on) and the class, which is almost
# always +IN+, the Internet class. At the end, +data+ is the
# value associated to the name for that particular type of
# resource record. An example:
#
#   # A record for IP address
#   "www.example.com  86400  IN  A  172.16.100.1"
#
#   # NS record for name server
#   "www.example.com  86400  IN  NS  ns.example.com"
#
# A new RR object can be created in 2 ways: passing a string
# such the ones above, or specifying each field as the pair
# of an hash. See the Net::DNS::RR.new method for details.
#
# source://net-dns//lib/net/dns/rr/types.rb#3
class Net::DNS::RR
  include ::Net::DNS::Names

  # Create a new instance of Net::DNS::RR class, or an instance of
  # any of the subclass of the appropriate type.
  #
  # Argument can be a string or an hash. With a sting, we can pass
  # a RR resource record in the canonical format:
  #
  #   a     = Net::DNS::RR.new("foo.example.com. 86400 A 10.1.2.3")
  #   mx    = Net::DNS::RR.new("example.com. 7200 MX 10 mailhost.example.com.")
  #   cname = Net::DNS::RR.new("www.example.com 300 IN CNAME www1.example.com")
  #   txt   = Net::DNS::RR.new('baz.example.com 3600 HS TXT "text record"')
  #
  # Incidentally, +a+, +mx+, +cname+ and +txt+ objects will be instances of
  # respectively Net::DNS::RR::A, Net::DNS::RR::MX, Net::DNS::RR::CNAME and
  # Net::DNS::RR::TXT classes.
  #
  # The name and RR data are required; all other informations are optional.
  # If omitted, the +TTL+ defaults to 10800, +type+ default to +A+ and the RR class
  # defaults to +IN+.  Omitting the optional fields is useful for creating the
  # empty RDATA sections required for certain dynamic update operations.
  # All names must be fully qualified.  The trailing dot (.) is optional.
  #
  # The preferred method is however passing an hash with keys and values:
  #
  #   rr = Net::DNS::RR.new(
  #                 :name    => "foo.example.com",
  #                 :ttl     => 86400,
  #                 :cls     => "IN",
  #                 :type    => "A",
  #                 :address => "10.1.2.3"
  #         )
  #
  #   rr = Net::DNS::RR.new(
  #                 :name => "foo.example.com",
  #                 :rdata => "10.1.2.3"
  #         )
  #
  # Name and data are required; all the others fields are optionals like
  # we've seen before. The data field can be specified either with the
  # right name of the resource (+:address+ in the example above) or with
  # the generic key +:rdata+. Consult documentation to find the exact name
  # for the resource in each subclass.
  #
  # @return [RR] a new instance of RR
  #
  # source://net-dns//lib/net/dns/rr.rb#105
  def initialize(arg); end

  # Class accessor
  #
  # source://net-dns//lib/net/dns/rr.rb#160
  def cls; end

  # Return the RR object in binary data format, suitable
  # for using in network streams, with names compressed.
  # Must pass as arguments the offset inside the packet
  # and an hash of compressed names.
  #
  # This method is to be used in other classes and is
  # not intended for user space programs.
  #
  # TO FIX in one of the future releases
  #
  # source://net-dns//lib/net/dns/rr.rb#193
  def comp_data(offset, compnames); end

  # Return the RR object in binary data format, suitable
  # for using in network streams.
  #
  #   raw_data = rr.data
  #   puts "RR is #{raw_data.size} bytes long"
  #
  # source://net-dns//lib/net/dns/rr.rb#178
  def data; end

  # Returns a human readable representation of this record.
  # The value is always a String.
  #
  #   mx = Net::DNS::RR.new("example.com. 7200 MX 10 mailhost.example.com.")
  #   #=> example.com.            7200    IN      MX      10 mailhost.example.com.
  #
  # source://net-dns//lib/net/dns/rr.rb#206
  def inspect; end

  # Returns the value of attribute name.
  #
  # source://net-dns//lib/net/dns/rr.rb#150
  def name; end

  # Data belonging to that appropriate class,
  # not to be used (use real accessors instead)
  #
  # source://net-dns//lib/net/dns/rr.rb#170
  def rdata; end

  # Returns an Array with all the attributes for this record.
  #
  #   mx = Net::DNS::RR.new("example.com. 7200 MX 10 mailhost.example.com.")
  #   mx.to_a
  #   #=> ["example.com.", 7200, "IN", "MX", "10 mailhost.example.com."]
  #
  # source://net-dns//lib/net/dns/rr.rb#231
  def to_a; end

  # Returns a String representation of this record.
  #
  #   mx = Net::DNS::RR.new("example.com. 7200 MX 10 mailhost.example.com.")
  #   mx.to_s
  #   #=> "example.com.            7200    IN      MX      10 mailhost.example.com."
  #
  # source://net-dns//lib/net/dns/rr.rb#216
  def to_s; end

  # Returns the value of attribute ttl.
  #
  # source://net-dns//lib/net/dns/rr.rb#152
  def ttl; end

  # Type accessor
  #
  # source://net-dns//lib/net/dns/rr.rb#155
  def type; end

  # source://net-dns//lib/net/dns/rr.rb#164
  def value; end

  private

  # source://net-dns//lib/net/dns/rr.rb#328
  def build_pack; end

  # source://net-dns//lib/net/dns/rr.rb#335
  def get_data; end

  # source://net-dns//lib/net/dns/rr.rb#331
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr.rb#297
  def new_from_binary(data, offset); end

  # source://net-dns//lib/net/dns/rr.rb#270
  def new_from_hash(args); end

  # source://net-dns//lib/net/dns/rr.rb#237
  def new_from_string(rrstring); end

  # source://net-dns//lib/net/dns/rr.rb#339
  def set_type; end

  # Methods to be overridden by subclasses
  #
  # source://net-dns//lib/net/dns/rr.rb#316
  def subclass_new_from_array(arr); end

  # source://net-dns//lib/net/dns/rr.rb#325
  def subclass_new_from_binary(data, offset); end

  # source://net-dns//lib/net/dns/rr.rb#322
  def subclass_new_from_hash(hash); end

  # source://net-dns//lib/net/dns/rr.rb#319
  def subclass_new_from_string(str); end

  class << self
    # source://net-dns//lib/net/dns/rr.rb#345
    def new(*args); end

    # Return a new RR object of the correct type (like Net::DNS::RR::A
    # if the type is A) from a binary string, usually obtained from
    # network stream.
    #
    # This method is used when parsing a binary packet by the Packet
    # class.
    #
    # source://net-dns//lib/net/dns/rr.rb#132
    def parse(data); end

    # Same as RR.parse, but takes an entire packet binary data to
    # perform name expansion. Default when analizing a packet
    # just received from a network stream.
    #
    # Return an instance of appropriate class and the offset
    # pointing at the end of the data parsed.
    #
    # source://net-dns//lib/net/dns/rr.rb#145
    def parse_packet(data, offset); end
  end
end

# = IPv4 Address Record (A)
#
# Class for DNS IPv4 Address (A) resource records.
#
# The resource data is an IPv4 (i.e. 32 bit long) address,
# hold in the instance variable +address+.
#
#   a = Net::DNS::RR::A.new("localhost.movie.edu. 360 IN A 127.0.0.1")
#
#   a = Net::DNS::RR::A.new(:name    => "localhost.movie.edu.",
#                           :ttl     => 360,
#                           :cls     => Net::DNS::IN,
#                           :type    => Net::DNS::A,
#                           :address => "127.0.0.1" )
#
# When computing binary data to transmit the RR, the RDATA section is an
# Internet address expressed as four decimal numbers separated by dots
# without any embedded space (e.g. "10.2.0.52" or "192.0.5.6").
#
# source://net-dns//lib/net/dns/rr/a.rb#24
class Net::DNS::RR::A < ::Net::DNS::RR
  # Gets the current IPv4 address for this record.
  #
  # Returns an instance of IPAddr.
  #
  # source://net-dns//lib/net/dns/rr/a.rb#28
  def address; end

  # Assigns a new IPv4 address to this record, which can be in the
  # form of a <tt>String</tt> or an <tt>IPAddr</tt> object.
  #
  # Examples
  #
  #   a.address = "192.168.0.1"
  #   a.address = IPAddr.new("10.0.0.1")
  #
  # Returns the new allocated instance of IPAddr.
  #
  # source://net-dns//lib/net/dns/rr/a.rb#39
  def address=(string_or_ipaddr); end

  # Gets the standardized value for this record,
  # represented by the value of <tt>address</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/a.rb#49
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/a.rb#103
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/a.rb#83
  def check_address(input); end

  # source://net-dns//lib/net/dns/rr/a.rb#108
  def get_data; end

  # source://net-dns//lib/net/dns/rr/a.rb#79
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/a.rb#75
  def set_type; end

  # source://net-dns//lib/net/dns/rr/a.rb#69
  def subclass_new_from_binary(data, offset); end

  # source://net-dns//lib/net/dns/rr/a.rb#55
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/a.rb#65
  def subclass_new_from_string(str); end
end

# = IPv6 Address Record (AAAA)
#
# Class for DNS IPv6 Address (AAAA) resource records.
#
# source://net-dns//lib/net/dns/rr/aaaa.rb#9
class Net::DNS::RR::AAAA < ::Net::DNS::RR
  # Gets the current IPv6 address for this record.
  #
  # Returns an instance of IPAddr.
  #
  # source://net-dns//lib/net/dns/rr/aaaa.rb#13
  def address; end

  # Assigns a new IPv6 address to this record, which can be in the
  # form of a <tt>String</tt> or an <tt>IPAddr</tt> object.
  #
  # Examples
  #
  #   a.address = "192.168.0.1"
  #   a.address = IPAddr.new("10.0.0.1")
  #
  # Returns the new allocated instance of IPAddr.
  #
  # source://net-dns//lib/net/dns/rr/aaaa.rb#24
  def address=(string_or_ipaddr); end

  # Gets the standardized value for this record,
  # represented by the value of <tt>address</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/aaaa.rb#34
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/aaaa.rb#81
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#64
  def check_address(input); end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#86
  def get_data; end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#60
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#56
  def set_type; end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#50
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/aaaa.rb#40
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/aaaa.rb#46
  def subclass_new_from_string(str); end
end

# = Canonical Name Record (CNAME)
#
# Class for DNS CNAME resource records.
#
# A CNAME record maps an alias or nickname to the real or Canonical name
# which may lie outside the current zone.
# Canonical means expected or real name.
#
# source://net-dns//lib/net/dns/rr/cname.rb#13
class Net::DNS::RR::CNAME < ::Net::DNS::RR
  # Gets the canonical name value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/cname.rb#17
  def cname; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>cname</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/cname.rb#23
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/cname.rb#61
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/cname.rb#52
  def check_name(input); end

  # source://net-dns//lib/net/dns/rr/cname.rb#66
  def get_data; end

  # source://net-dns//lib/net/dns/rr/cname.rb#48
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/cname.rb#44
  def set_type; end

  # source://net-dns//lib/net/dns/rr/cname.rb#39
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/cname.rb#29
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/cname.rb#35
  def subclass_new_from_string(str); end
end

# = Net::DNS::Classes
#
# This is an auxiliary class to handle <tt>Net::DNS::RR</tt>
# class field in a DNS packet.
#
# source://net-dns//lib/net/dns/rr/classes.rb#10
class Net::DNS::RR::Classes
  # Creates a new object representing an RR class. Performs some
  # checks on the argument validity too. Il +cls+ is +nil+, the
  # default value is +ANY+ or the one set with Classes.default=
  #
  # @raise [ArgumentError]
  # @return [Classes] a new instance of Classes
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#27
  def initialize(cls); end

  # Returns the class in number format
  # (default for normal use)
  #
  # FIXME: inspect must return a String.
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#47
  def inspect; end

  # Returns the class in numeric format,
  # usable by the pack methods for data transfers.
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#59
  def to_i; end

  # Returns the class in string format,
  # ex. "IN" or "CH" or such a string.
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#53
  def to_s; end

  private

  # Initialize a new instance from the Class value.
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#120
  def initialize_from_num(num); end

  # Initialize a new instance from a Class name.
  #
  # source://net-dns//lib/net/dns/rr/classes.rb#113
  def initialize_from_str(str); end

  class << self
    # source://net-dns//lib/net/dns/rr/classes.rb#63
    def default; end

    # Be able to control the default class to assign when
    # cls argument is +nil+. Default to +IN+
    #
    # @raise [ArgumentError]
    #
    # source://net-dns//lib/net/dns/rr/classes.rb#69
    def default=(str); end

    # Gives in output the keys from the +Classes+ hash
    # in a format suited for regexps
    #
    # source://net-dns//lib/net/dns/rr/classes.rb#106
    def regexp; end

    # Returns whether <tt>cls</tt> is a valid RR class.
    #
    #   Net::DNS::RR::Classes.valid?("IN")
    #   # => true
    #   Net::DNS::RR::Classes.valid?(1)
    #   # => true
    #   Net::DNS::RR::Classes.valid?("Q")
    #   # => false
    #   Net::DNS::RR::Classes.valid?(256)
    #   # => false
    #   Net::DNS::RR::Classes.valid?(Hash.new)
    #   # => ArgumentError
    #
    # FIXME: valid? should never raise.
    #
    # ==== Raises
    # ArgumentError:: if <tt>cls</tt> isn't either a String or a Fixnum
    #
    # @return [Boolean]
    #
    # source://net-dns//lib/net/dns/rr/classes.rb#93
    def valid?(cls); end
  end
end

# = System Information Record (HINFO)
#
# Class for DNS HINFO resource records.
#
# Allows definition of the Hardware type and Operating System (OS) in use at a host.
# For security reasons these records are rarely used on public servers.
# If a space exists in the field it must be enclosed in quotes.
# Single space between CPU and OS parameters.
#
# source://net-dns//lib/net/dns/rr/hinfo.rb#14
class Net::DNS::RR::HINFO < ::Net::DNS::RR
  # Gets the CPU value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#18
  def cpu; end

  # Gets the OS value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#23
  def os; end

  # Gets a list of all the attributes for this record.
  #
  # Returns an Array of values.
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#36
  def to_a; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>cpu</tt> and <tt>os</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#29
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/hinfo.rb#79
  def build_pack; end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#73
  def check_hinfo(input); end

  # source://net-dns//lib/net/dns/rr/hinfo.rb#86
  def get_data; end

  # source://net-dns//lib/net/dns/rr/hinfo.rb#69
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/hinfo.rb#65
  def set_type; end

  # source://net-dns//lib/net/dns/rr/hinfo.rb#53
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/hinfo.rb#42
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/hinfo.rb#49
  def subclass_new_from_string(str); end
end

# = Mail Rename Record (MR)
#
# Class for DNS MR resource records.
#
# source://net-dns//lib/net/dns/rr/mr.rb#9
class Net::DNS::RR::MR < ::Net::DNS::RR
  # Gets the newname value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/mr.rb#13
  def newname; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>newname</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/mr.rb#19
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/mr.rb#57
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/mr.rb#48
  def check_name(input); end

  # source://net-dns//lib/net/dns/rr/mr.rb#62
  def get_data; end

  # source://net-dns//lib/net/dns/rr/mr.rb#44
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/mr.rb#40
  def set_type; end

  # source://net-dns//lib/net/dns/rr/mr.rb#35
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/mr.rb#25
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/mr.rb#31
  def subclass_new_from_string(str); end
end

# = Mail Exchange Record (MX)
#
# Class for DNS MX resource records.
#
# A MX record specifies the name and relative preference of mail servers
# (mail exchangers in the DNS jargon) for the zone.
# The MX RR is used by SMTP (Mail) Agents to route mail for the domain.
#
# source://net-dns//lib/net/dns/rr/mx.rb#13
class Net::DNS::RR::MX < ::Net::DNS::RR
  # Gets the exchange value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/mx.rb#22
  def exchange; end

  # Gets the preference value.
  #
  # Returns an Integer.
  #
  # source://net-dns//lib/net/dns/rr/mx.rb#17
  def preference; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>preference</tt> and <tt>exchange</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/mx.rb#28
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/mx.rb#69
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/mx.rb#60
  def check_mx(input); end

  # source://net-dns//lib/net/dns/rr/mx.rb#74
  def get_data; end

  # source://net-dns//lib/net/dns/rr/mx.rb#56
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/mx.rb#52
  def set_type; end

  # source://net-dns//lib/net/dns/rr/mx.rb#45
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/mx.rb#34
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/mx.rb#41
  def subclass_new_from_string(str); end
end

# = Name Server Record (NS)
#
# Class for DNS NS resource records.
#
# source://net-dns//lib/net/dns/rr/ns.rb#9
class Net::DNS::RR::NS < ::Net::DNS::RR
  # Gets the name server value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/ns.rb#13
  def nsdname; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>nsdname</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/ns.rb#19
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/ns.rb#57
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/ns.rb#48
  def check_name(input); end

  # source://net-dns//lib/net/dns/rr/ns.rb#62
  def get_data; end

  # source://net-dns//lib/net/dns/rr/ns.rb#44
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/ns.rb#40
  def set_type; end

  # source://net-dns//lib/net/dns/rr/ns.rb#35
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/ns.rb#25
  def subclass_new_from_hash(options); end

  # source://net-dns//lib/net/dns/rr/ns.rb#31
  def subclass_new_from_string(str); end
end

# = Pointer Record (PTR)
#
# Class for DNS Pointer (PTR) resource records.
#
# Pointer records are the opposite of A and AAAA RRs
# and are used in Reverse Map zone files to map
# an IP address (IPv4 or IPv6) to a host name.
#
# source://net-dns//lib/net/dns/rr/ptr.rb#13
class Net::DNS::RR::PTR < ::Net::DNS::RR
  # Gets the PTR value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/ptr.rb#17
  def ptr; end

  # Gets the PTR value.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/ptr.rb#17
  def ptrdname; end

  # Gets the standardized value for this record,
  # represented by the value of <tt>ptrdname</tt>.
  #
  # Returns a String.
  #
  # source://net-dns//lib/net/dns/rr/ptr.rb#27
  def value; end

  private

  # source://net-dns//lib/net/dns/rr/ptr.rb#33
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/ptr.rb#67
  def check_name(input); end

  # source://net-dns//lib/net/dns/rr/ptr.rb#38
  def get_data; end

  # source://net-dns//lib/net/dns/rr/ptr.rb#63
  def get_inspect; end

  # source://net-dns//lib/net/dns/rr/ptr.rb#59
  def set_type; end

  # source://net-dns//lib/net/dns/rr/ptr.rb#52
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/ptr.rb#42
  def subclass_new_from_hash(args); end

  # source://net-dns//lib/net/dns/rr/ptr.rb#48
  def subclass_new_from_string(str); end
end

# ------------------------------------------------------------
# RR type SOA
# ------------------------------------------------------------
#
# source://net-dns//lib/net/dns/rr/soa.rb#7
class Net::DNS::RR::SOA < ::Net::DNS::RR
  # Returns the value of attribute expire.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#13
  def expire; end

  # Returns the value of attribute minimum.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#14
  def minimum; end

  # Returns the value of attribute mname.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#8
  def mname; end

  # Returns the value of attribute refresh.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#11
  def refresh; end

  # Returns the value of attribute retry.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#12
  def retry; end

  # Returns the value of attribute rname.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#9
  def rname; end

  # Returns the value of attribute serial.
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#10
  def serial; end

  private

  # source://net-dns//lib/net/dns/rr/soa.rb#18
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/soa.rb#24
  def get_data; end

  # source://net-dns//lib/net/dns/rr/soa.rb#28
  def get_inspect; end

  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/rr/soa.rb#49
  def number?(num); end

  # source://net-dns//lib/net/dns/rr/soa.rb#73
  def set_type; end

  # source://net-dns//lib/net/dns/rr/soa.rb#64
  def subclass_new_from_binary(data, offset); end

  # source://net-dns//lib/net/dns/rr/soa.rb#32
  def subclass_new_from_hash(args); end

  # source://net-dns//lib/net/dns/rr/soa.rb#55
  def subclass_new_from_string(str); end
end

# ------------------------------------------------------------
# RR type SRV
# ------------------------------------------------------------
#
# source://net-dns//lib/net/dns/rr/srv.rb#7
class Net::DNS::RR::SRV < ::Net::DNS::RR
  # Returns the value of attribute host.
  #
  # source://net-dns//lib/net/dns/rr/srv.rb#11
  def host; end

  # Returns the value of attribute port.
  #
  # source://net-dns//lib/net/dns/rr/srv.rb#10
  def port; end

  # Returns the value of attribute priority.
  #
  # source://net-dns//lib/net/dns/rr/srv.rb#8
  def priority; end

  # Returns the value of attribute weight.
  #
  # source://net-dns//lib/net/dns/rr/srv.rb#9
  def weight; end

  private

  # source://net-dns//lib/net/dns/rr/srv.rb#15
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/srv.rb#38
  def set_type; end

  # source://net-dns//lib/net/dns/rr/srv.rb#19
  def subclass_new_from_binary(data, offset); end
end

# ------------------------------------------------------------
# RR type TXT
# ------------------------------------------------------------
#
# source://net-dns//lib/net/dns/rr/txt.rb#7
class Net::DNS::RR::TXT < ::Net::DNS::RR
  # Returns the value of attribute txt.
  #
  # source://net-dns//lib/net/dns/rr/txt.rb#8
  def txt; end

  private

  # source://net-dns//lib/net/dns/rr/txt.rb#12
  def build_pack; end

  # source://net-dns//lib/net/dns/rr/txt.rb#21
  def get_data; end

  # source://net-dns//lib/net/dns/rr/txt.rb#50
  def set_type; end

  # source://net-dns//lib/net/dns/rr/txt.rb#35
  def subclass_new_from_binary(data, offset); end

  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/txt.rb#25
  def subclass_new_from_hash(args); end

  # source://net-dns//lib/net/dns/rr/txt.rb#31
  def subclass_new_from_string(str); end
end

# This is an auxiliary class to handle RR type field in a DNS packet.
#
# source://net-dns//lib/net/dns/rr/types.rb#5
class Net::DNS::RR::Types
  # Creates a new object representing an RR type. Performs some
  # checks on the argument validity too. Il +type+ is +nil+, the
  # default value is +ANY+ or the one set with Types.default=
  #
  # @return [Types] a new instance of Types
  #
  # source://net-dns//lib/net/dns/rr/types.rb#136
  def initialize(type); end

  # Returns the type in number format
  # (default for normal use)
  #
  # source://net-dns//lib/net/dns/rr/types.rb#155
  def inspect; end

  # Returns the type in numeric format,
  # usable by the pack methods for data transfers
  #
  # source://net-dns//lib/net/dns/rr/types.rb#167
  def to_i; end

  # Returns the type in string format,
  # i.d. "A" or "NS" or such a string.
  #
  # source://net-dns//lib/net/dns/rr/types.rb#161
  def to_s; end

  # source://net-dns//lib/net/dns/rr/types.rb#171
  def to_str; end

  private

  # Contructor for numeric data type.
  #
  # @raise [ArgumentError]
  #
  # source://net-dns//lib/net/dns/rr/types.rb#193
  def new_from_num(type); end

  # Constructor for string data type.
  #
  # source://net-dns//lib/net/dns/rr/types.rb#178
  def new_from_string(type); end

  class << self
    # source://net-dns//lib/net/dns/rr/types.rb#88
    def default; end

    # Be able to control the default type to assign when
    # type is +nil+. Default to +A+
    #
    # @raise [ArgumentError]
    #
    # source://net-dns//lib/net/dns/rr/types.rb#94
    def default=(str); end

    # Gives in output the keys from the +Types+ hash
    # in a format suited for regexps
    #
    # source://net-dns//lib/net/dns/rr/types.rb#128
    def regexp; end

    # Returns the type in string format, as "A" or "NS",
    # given the numeric value
    #
    # source://net-dns//lib/net/dns/rr/types.rb#114
    def to_str(type); end

    # Checks whether +type+ is a valid RR type.
    #
    # @return [Boolean]
    #
    # source://net-dns//lib/net/dns/rr/types.rb#101
    def valid?(type); end
  end
end

# = Net::DNS::Resolver - DNS resolver class
#
# The Net::DNS::Resolver class implements a complete DNS resolver written
# in pure Ruby, without a single C line of code. It has all of the
# tipical properties of an evoluted resolver, and a bit of OO which
# comes from having used Ruby.
#
# This project started as a porting of the Net::DNS Perl module,
# written by Martin Fuhr, but turned out (in the last months) to be
# an almost complete rewriting. Well, maybe some of the features of
# the Perl version are still missing, but guys, at least this is
# readable code!
#
# == Environment
#
# The Following Environment variables can also be used to configure
# the resolver:
#
# * +RES_NAMESERVERS+: A space-separated list of nameservers to query.
#
#      # Bourne Shell
#      $ RES_NAMESERVERS="192.168.1.1 192.168.2.2 192.168.3.3"
#      $ export RES_NAMESERVERS
#
#      # C Shell
#      % setenv RES_NAMESERVERS "192.168.1.1 192.168.2.2 192.168.3.3"
#
# * +RES_SEARCHLIST+: A space-separated list of domains to put in the
#   search list.
#
#      # Bourne Shell
#      $ RES_SEARCHLIST="example.com sub1.example.com sub2.example.com"
#      $ export RES_SEARCHLIST
#
#      # C Shell
#      % setenv RES_SEARCHLIST "example.com sub1.example.com sub2.example.com"
#
# * +LOCALDOMAIN+: The default domain.
#
#      # Bourne Shell
#      $ LOCALDOMAIN=example.com
#      $ export LOCALDOMAIN
#
#      # C Shell
#      % setenv LOCALDOMAIN example.com
#
# * +RES_OPTIONS+: A space-separated list of resolver options to set.
#   Options that take values are specified as option:value.
#
#      # Bourne Shell
#      $ RES_OPTIONS="retrans:3 retry:2 debug"
#      $ export RES_OPTIONS
#
#      # C Shell
#      % setenv RES_OPTIONS "retrans:3 retry:2 debug"
#
# source://net-dns//lib/net/dns/resolver/timeouts.rb#5
class Net::DNS::Resolver
  # Creates a new resolver object.
  #
  # Argument +config+ can either be empty or be an hash with
  # some configuration parameters. To know what each parameter
  # do, look at the description of each.
  # Some example:
  #
  #   # Use the sistem defaults
  #   res = Net::DNS::Resolver.new
  #
  #   # Specify a configuration file
  #   res = Net::DNS::Resolver.new(:config_file => '/my/dns.conf')
  #
  #   # Set some option
  #   res = Net::DNS::Resolver.new(:nameservers => "172.16.1.1",
  #                                :recursive => false,
  #                                :retry => 10)
  #
  # == Config file
  #
  # Net::DNS::Resolver uses a config file to read the usual
  # values a resolver needs, such as nameserver list and
  # domain names. On UNIX systems the defaults are read from the
  # following files, in the order indicated:
  #
  # * /etc/resolv.conf
  # * $HOME/.resolv.conf
  # * ./.resolv.conf
  #
  # The following keywords are recognized in resolver configuration files:
  #
  # * domain: the default domain.
  # * search: a space-separated list of domains to put in the search list.
  # * nameserver: a space-separated list of nameservers to query.
  #
  # Files except for /etc/resolv.conf must be owned by the effective userid
  # running the program or they won't be read.  In addition, several environment
  # variables can also contain configuration information; see Environment
  # in the main description for Resolver class.
  #
  # On Windows Systems, an attempt is made to determine the system defaults
  # using the registry.  This is still a work in progress; systems with many
  # dynamically configured network interfaces may confuse Net::DNS.
  #
  # You can include a configuration file of your own when creating a resolver
  # object:
  #
  #   # Use my own configuration file
  #   my $res = Net::DNS::Resolver->new(config_file => '/my/dns.conf');
  #
  # This is supported on both UNIX and Windows.  Values pulled from a custom
  # configuration file override the the system's defaults, but can still be
  # overridden by the other arguments to Resolver::new.
  #
  # Explicit arguments to Resolver::new override both the system's defaults
  # and the values of the custom configuration file, if any.
  #
  # == Parameters
  #
  # The following arguments to Resolver::new are supported:
  #
  # * nameservers: an array reference of nameservers to query.
  # * searchlist:  an array reference of domains.
  # * recurse
  # * debug
  # * domain
  # * port
  # * srcaddr
  # * srcport
  # * tcp_timeout
  # * udp_timeout
  # * retrans
  # * retry
  # * usevc
  # * stayopen
  # * igntc
  # * defnames
  # * dnsrch
  # * persistent_tcp
  # * persistent_udp
  # * dnssec
  #
  # For more information on any of these options, please consult the
  # method of the same name.
  #
  # == Disclaimer
  #
  # Part of the above documentation is taken from the one in the
  # Net::DNS::Resolver Perl module.
  #
  # @return [Resolver] a new instance of Resolver
  #
  # source://net-dns//lib/net/dns/resolver.rb#233
  def initialize(config = T.unsafe(nil)); end

  # Performs a zone transfer for the zone passed as a parameter.
  #
  # It is actually only a wrapper to a send with type set as Net::DNS::AXFR,
  # since it is using the same infrastucture.
  #
  # source://net-dns//lib/net/dns/resolver.rb#1016
  def axfr(name, cls = T.unsafe(nil)); end

  # Checks whether the +defname+ flag has been activate.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#605
  def defname; end

  # Set the flag +defname+ in a boolean state. if +defname+ is true,
  # calls to Resolver#query will append the default domain to names
  # that contain no dots.
  # Example:
  #
  #   # Domain example.com
  #   res.defname = true
  #   res.query("machine1")
  #     #=> This will perform a query for machine1.example.com
  #
  # Default is true.
  #
  # source://net-dns//lib/net/dns/resolver.rb#622
  def defname=(bool); end

  # Checks whether the +defname+ flag has been activate.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#605
  def defname?; end

  # Get the state of the dns_search flag.
  #
  # source://net-dns//lib/net/dns/resolver.rb#633
  def dns_search; end

  # Set the flag +dns_search+ in a boolean state. If +dns_search+
  # is true, when using the Resolver#search method will be applied
  # the search list. Default is true.
  #
  # source://net-dns//lib/net/dns/resolver.rb#641
  def dns_search=(bool); end

  # Get the state of the dns_search flag.
  #
  # source://net-dns//lib/net/dns/resolver.rb#633
  def dnsrch; end

  # Set the flag +dns_search+ in a boolean state. If +dns_search+
  # is true, when using the Resolver#search method will be applied
  # the search list. Default is true.
  #
  # source://net-dns//lib/net/dns/resolver.rb#641
  def dnsrch=(bool); end

  # Return a string with the default domain.
  #
  # source://net-dns//lib/net/dns/resolver.rb#375
  def domain; end

  # Set the domain for the query.
  #
  # source://net-dns//lib/net/dns/resolver.rb#380
  def domain=(name); end

  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#681
  def ignore_truncated; end

  # source://net-dns//lib/net/dns/resolver.rb#686
  def ignore_truncated=(bool); end

  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#681
  def ignore_truncated?; end

  # Return a string representing the resolver state, suitable
  # for printing on the screen.
  #
  #   puts "Resolver state:"
  #   puts res.state
  #
  # source://net-dns//lib/net/dns/resolver.rb#587
  def inspect; end

  # Set a new log file for the logger facility of the resolver
  # class. Could be a file descriptor too:
  #
  #   res.log_file = $stderr
  #
  # Note that a new logging facility will be create, destroing
  # the old one, which will then be impossibile to recover.
  #
  # source://net-dns//lib/net/dns/resolver.rb#773
  def log_file=(log); end

  # Set the log level for the built-in logging facility.
  #
  # The log level can be one of the following:
  #
  # - +Net::DNS::DEBUG+
  # - +Net::DNS::INFO+
  # - +Net::DNS::WARN+
  # - +Net::DNS::ERROR+
  # - +Net::DNS::FATAL+
  #
  # Note that if the global variable $DEBUG is set (like when the
  # -d switch is used at the command line) the logger level is
  # automatically set at DEGUB.
  #
  # For further informations, see Logger documentation in the
  # Ruby standard library.
  #
  # source://net-dns//lib/net/dns/resolver.rb#820
  def log_level=(level); end

  # This one permits to have a personal logger facility to handle
  # resolver messages, instead of new built-in one, which is set up
  # for a +$stdout+ (or +$stderr+) use.
  #
  # If you want your own logging facility you can create a new instance
  # of the +Logger+ class:
  #
  #   log = Logger.new("/tmp/resolver.log","weekly",2*1024*1024)
  #   log.level = Logger::DEBUG
  #   log.progname = "ruby_resolver"
  #
  # and then pass it to the resolver:
  #
  #   res.logger = log
  #
  # Note that this will destroy the precedent logger.
  #
  # source://net-dns//lib/net/dns/resolver.rb#796
  def logger=(logger); end

  # Performs an MX query for the domain name passed as parameter.
  #
  # It actually uses the same methods a normal Resolver query would
  # use, but automatically sort the results based on preferences
  # and returns an ordered array.
  #
  #   res = Net::DNS::Resolver.new
  #   res.mx("google.com")
  #
  # source://net-dns//lib/net/dns/resolver.rb#1030
  def mx(name, cls = T.unsafe(nil)); end

  # Get the list of resolver nameservers, in a dotted decimal format-
  #
  #   res.nameservers
  #     #=> ["192.168.0.1","192.168.0.2"]
  #
  # source://net-dns//lib/net/dns/resolver.rb#317
  def nameserver; end

  # Set the list of resolver nameservers.
  # +arg+ can be a single ip address or an array of addresses.
  #
  #   res.nameservers = "192.168.0.1"
  #   res.nameservers = ["192.168.0.1","192.168.0.2"]
  #
  # If you want you can specify the addresses as IPAddr instances.
  #
  #   ip = IPAddr.new("192.168.0.3")
  #   res.nameservers << ip
  #   #=> ["192.168.0.1","192.168.0.2","192.168.0.3"]
  #
  # The default is 127.0.0.1 (localhost)
  #
  # source://net-dns//lib/net/dns/resolver.rb#337
  def nameserver=(arg); end

  # Get the list of resolver nameservers, in a dotted decimal format-
  #
  #   res.nameservers
  #     #=> ["192.168.0.1","192.168.0.2"]
  #
  # source://net-dns//lib/net/dns/resolver.rb#317
  def nameservers; end

  # Set the list of resolver nameservers.
  # +arg+ can be a single ip address or an array of addresses.
  #
  #   res.nameservers = "192.168.0.1"
  #   res.nameservers = ["192.168.0.1","192.168.0.2"]
  #
  # If you want you can specify the addresses as IPAddr instances.
  #
  #   ip = IPAddr.new("192.168.0.3")
  #   res.nameservers << ip
  #   #=> ["192.168.0.1","192.168.0.2","192.168.0.3"]
  #
  # The default is 127.0.0.1 (localhost)
  #
  # source://net-dns//lib/net/dns/resolver.rb#337
  def nameservers=(arg); end

  # Return the defined size of the packet.
  #
  # source://net-dns//lib/net/dns/resolver.rb#385
  def packet_size; end

  # Get the port number to which the resolver sends queries.
  #
  #   puts "Sending queries to port #{res.port}"
  #
  # source://net-dns//lib/net/dns/resolver.rb#393
  def port; end

  # Set the port number to which the resolver sends queries.  This can be useful
  # for testing a nameserver running on a non-standard port.
  #
  #   res.port = 10053
  #
  # The default is port 53.
  #
  # source://net-dns//lib/net/dns/resolver.rb#404
  def port=(num); end

  # Return a string representing the resolver state, suitable
  # for printing on the screen.
  #
  #   puts "Resolver state:"
  #   puts res.state
  #
  # source://net-dns//lib/net/dns/resolver.rb#587
  def print; end

  # Performs a DNS query for the given name.  Neither the
  # searchlist nor the default domain will be appended.
  #
  # The argument list can be either a Net::DNS::Packet object
  # or a name string plus optional type and class, which if
  # omitted default to +A+ and +IN+.
  #
  # Returns a Net::DNS::Packet object.
  #
  #   # Executes the query with a +Packet+ object
  #   send_packet = Net::DNS::Packet.new("host.example.com", Net::DNS::NS, Net::DNS::HS)
  #   packet = res.query(send_packet)
  #
  #   # Executes the query with a host, type and cls
  #   packet = res.query("host.example.com")
  #   packet = res.query("host.example.com", Net::DNS::NS)
  #   packet = res.query("host.example.com", Net::DNS::NS, Net::DNS::HS)
  #
  # If the name is an IP address (Ipv4 or IPv6), in the form of a string
  # or a IPAddr object, then an appropriate PTR query will be performed:
  #
  #   ip = IPAddr.new("172.16.100.2")
  #   packet = res.query(ip)
  #
  #   packet = res.query("172.16.100.2")
  #
  # Use +packet.header.ancount+ or +packet.answer+ to find out if there
  # were any records in the answer section.
  #
  # source://net-dns//lib/net/dns/resolver.rb#940
  def query(argument, type = T.unsafe(nil), cls = T.unsafe(nil)); end

  # This method will return true if the resolver is configured to
  # perform recursive queries.
  #
  #   print "The resolver will perform a "
  #   print res.recursive? ? "" : "not "
  #   puts "recursive query"
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#559
  def recurse; end

  # Sets whether or not the resolver should perform recursive
  # queries. Default is true.
  #
  #   res.recursive = false # perform non-recursive query
  #
  # source://net-dns//lib/net/dns/resolver.rb#570
  def recurse=(bool); end

  # This method will return true if the resolver is configured to
  # perform recursive queries.
  #
  #   print "The resolver will perform a "
  #   print res.recursive? ? "" : "not "
  #   puts "recursive query"
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#559
  def recursive; end

  # Sets whether or not the resolver should perform recursive
  # queries. Default is true.
  #
  #   res.recursive = false # perform non-recursive query
  #
  # source://net-dns//lib/net/dns/resolver.rb#570
  def recursive=(bool); end

  # This method will return true if the resolver is configured to
  # perform recursive queries.
  #
  #   print "The resolver will perform a "
  #   print res.recursive? ? "" : "not "
  #   puts "recursive query"
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#559
  def recursive?; end

  # Return the retrasmission interval (in seconds) the resolvers has
  # been set on.
  #
  # source://net-dns//lib/net/dns/resolver.rb#518
  def retrans; end

  # Set the retrasmission interval in seconds. Default 5 seconds.
  #
  # source://net-dns//lib/net/dns/resolver.rb#524
  def retrans=(num); end

  # Set the number of times the resolver will try a query.
  # Default 4 times.
  #
  # source://net-dns//lib/net/dns/resolver.rb#543
  def retry=(num); end

  # Return the retrasmission interval (in seconds) the resolvers has
  # been set on.
  #
  # source://net-dns//lib/net/dns/resolver.rb#518
  def retry_interval; end

  # Set the retrasmission interval in seconds. Default 5 seconds.
  #
  # source://net-dns//lib/net/dns/resolver.rb#524
  def retry_interval=(num); end

  # The number of times the resolver will try a query.
  #
  #   puts "Will try a max of #{res.retry_number} queries"
  #
  # source://net-dns//lib/net/dns/resolver.rb#537
  def retry_number; end

  # Set the number of times the resolver will try a query.
  # Default 4 times.
  #
  # source://net-dns//lib/net/dns/resolver.rb#543
  def retry_number=(num); end

  # Performs a DNS query for the given name, applying the searchlist if
  # appropriate.  The search algorithm is as follows:
  #
  # 1. If the name contains at least one dot, try it as is.
  # 2. If the name doesn't end in a dot then append each item in the search
  #    list to the name.  This is only done if +dns_search+ is true.
  # 3. If the name doesn't contain any dots, try it as is.
  #
  # The record type and class can be omitted; they default to +A+ and +IN+.
  #
  #   packet = res.search('mailhost')
  #   packet = res.search('mailhost.example.com')
  #   packet = res.search('example.com', Net::DNS::MX)
  #   packet = res.search('user.passwd.example.com', Net::DNS::TXT, Net::DNS::HS)
  #
  # If the name is an IP address (Ipv4 or IPv6), in the form of a string
  # or a +IPAddr+ object, then an appropriate PTR query will be performed:
  #
  #   ip = IPAddr.new("172.16.100.2")
  #   packet = res.search(ip)
  #   packet = res.search("192.168.10.254")
  #
  # Returns a Net::DNS::Packet object. If you need to examine the response packet
  # whether it contains any answers or not, use the Resolver#query method instead.
  #
  # source://net-dns//lib/net/dns/resolver.rb#849
  def search(name, type = T.unsafe(nil), cls = T.unsafe(nil)); end

  # Get the resolver search list, returned as an array of entries.
  #
  #   res.searchlist
  #   #=> ["example.com","a.example.com","b.example.com"]
  #
  # source://net-dns//lib/net/dns/resolver.rb#281
  def searchlist; end

  # Set the resolver searchlist.
  # +arg+ can be a single string or an array of strings.
  #
  #   res.searchstring = "example.com"
  #   res.searchstring = ["example.com","a.example.com","b.example.com"]
  #
  # Note that you can also append a new name to the searchlist.
  #
  #   res.searchlist << "c.example.com"
  #   res.searchlist
  #   #=> ["example.com","a.example.com","b.example.com","c.example.com"]
  #
  # The default is an empty array.
  #
  # source://net-dns//lib/net/dns/resolver.rb#299
  def searchlist=(arg); end

  # Get the local address from which the resolver sends queries
  #
  #   puts "Sending queries using source address #{res.source_address}"
  #
  # source://net-dns//lib/net/dns/resolver.rb#446
  def source_address; end

  # Set the local source address from which the resolver sends its queries.
  #
  #   res.source_address = "172.16.100.1"
  #   res.source_address = IPAddr.new("172.16.100.1")
  #
  # You can specify +arg+ as either a string containing the ip address
  # or an instance of IPAddr class.
  #
  # Normally this can be used to force queries out a specific interface
  # on a multi-homed host. In this case, you should of course need to
  # know the addresses of the interfaces.
  #
  # Another way to use this option is for some kind of spoofing attacks
  # towards weak nameservers, to probe the security of your network.
  # This includes specifing ranged attacks such as DoS and others. For
  # a paper on DNS security, checks http://www.marcoceresa.com/security/
  #
  # Note that if you want to set a non-binded source address you need
  # root priviledges, as raw sockets will be used to generate packets.
  # The class will then generate an exception if you're not root.
  #
  # The default is 0.0.0.0, meaning any local address (chosen on routing needs).
  #
  # source://net-dns//lib/net/dns/resolver.rb#480
  def source_address=(addr); end

  # Get the local ipv6 address from which the resolver sends queries
  #
  # source://net-dns//lib/net/dns/resolver.rb#453
  def source_address_inet6; end

  # Get the value of the source port number.
  #
  #   puts "Sending queries using port #{res.source_port}"
  #
  # source://net-dns//lib/net/dns/resolver.rb#416
  def source_port; end

  # Set the local source port from which the resolver sends its queries.
  #
  #   res.source_port = 40000
  #
  # Note that if you want to set a port you need root priviledges, as
  # raw sockets will be used to generate packets. The class will then
  # generate the exception ResolverPermissionError if you're not root.
  #
  # The default is 0, which means that the port will be chosen by the
  # underlaying layers.
  #
  # source://net-dns//lib/net/dns/resolver.rb#432
  def source_port=(num); end

  # Get the local address from which the resolver sends queries
  #
  #   puts "Sending queries using source address #{res.source_address}"
  #
  # source://net-dns//lib/net/dns/resolver.rb#446
  def srcaddr; end

  # Set the local source address from which the resolver sends its queries.
  #
  #   res.source_address = "172.16.100.1"
  #   res.source_address = IPAddr.new("172.16.100.1")
  #
  # You can specify +arg+ as either a string containing the ip address
  # or an instance of IPAddr class.
  #
  # Normally this can be used to force queries out a specific interface
  # on a multi-homed host. In this case, you should of course need to
  # know the addresses of the interfaces.
  #
  # Another way to use this option is for some kind of spoofing attacks
  # towards weak nameservers, to probe the security of your network.
  # This includes specifing ranged attacks such as DoS and others. For
  # a paper on DNS security, checks http://www.marcoceresa.com/security/
  #
  # Note that if you want to set a non-binded source address you need
  # root priviledges, as raw sockets will be used to generate packets.
  # The class will then generate an exception if you're not root.
  #
  # The default is 0.0.0.0, meaning any local address (chosen on routing needs).
  #
  # source://net-dns//lib/net/dns/resolver.rb#480
  def srcaddr=(addr); end

  # Get the value of the source port number.
  #
  #   puts "Sending queries using port #{res.source_port}"
  #
  # source://net-dns//lib/net/dns/resolver.rb#416
  def srcport; end

  # Set the local source port from which the resolver sends its queries.
  #
  #   res.source_port = 40000
  #
  # Note that if you want to set a port you need root priviledges, as
  # raw sockets will be used to generate packets. The class will then
  # generate the exception ResolverPermissionError if you're not root.
  #
  # The default is 0, which means that the port will be chosen by the
  # underlaying layers.
  #
  # source://net-dns//lib/net/dns/resolver.rb#432
  def srcport=(num); end

  # Return a string representing the resolver state, suitable
  # for printing on the screen.
  #
  #   puts "Resolver state:"
  #   puts res.state
  #
  # source://net-dns//lib/net/dns/resolver.rb#587
  def state; end

  # Return an object representing the value of the stored TCP
  # timeout the resolver will use in is queries. This object
  # is an instance of the class +TcpTimeout+, and two methods
  # are available for printing informations: TcpTimeout#to_s
  # and TcpTimeout#pretty_to_s.
  #
  # Here's some example:
  #
  #   puts "Timeout of #{res.tcp_timeout} seconds" # implicit to_s
  #     #=> Timeout of 150 seconds
  #
  #   puts "You set a timeout of " + res.tcp_timeout.pretty_to_s
  #     #=> You set a timeout of 2 minutes and 30 seconds
  #
  # If the timeout is infinite, a string "infinite" will be returned.
  #
  # source://net-dns//lib/net/dns/resolver.rb#712
  def tcp_timeout; end

  # Set the value of TCP timeout for resolver queries that
  # will be performed using TCP. A value of 0 means that
  # the timeout will be infinite.
  # The value is stored internally as a +TcpTimeout+ object, see
  # the description for Resolver#tcp_timeout
  #
  # Default is 5 seconds.
  #
  # source://net-dns//lib/net/dns/resolver.rb#724
  def tcp_timeout=(secs); end

  # Return an object representing the value of the stored UDP
  # timeout the resolver will use in is queries. This object
  # is an instance of the class +UdpTimeout+, and two methods
  # are available for printing information: UdpTimeout#to_s
  # and UdpTimeout#pretty_to_s.
  #
  # Here's some example:
  #
  #   puts "Timeout of #{res.udp_timeout} seconds" # implicit to_s
  #     #=> Timeout of 150 seconds
  #
  #   puts "You set a timeout of " + res.udp_timeout.pretty_to_s
  #     #=> You set a timeout of 2 minutes and 30 seconds
  #
  # If the timeout is zero, a string "not defined" will
  # be returned.
  #
  # source://net-dns//lib/net/dns/resolver.rb#746
  def udp_timeout; end

  # Set the value of UDP timeout for resolver queries that
  # will be performed using UDP. A value of 0 means that
  # the timeout will not be used, and the resolver will use
  # only +retry_number+ and +retry_interval+ parameters.
  #
  # Default is 5 seconds.
  #
  # The value is stored internally as a +UdpTimeout+ object, see
  # the description for Resolver#udp_timeout.
  #
  # source://net-dns//lib/net/dns/resolver.rb#760
  def udp_timeout=(secs); end

  # Get the state of the use_tcp flag.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#654
  def use_tcp; end

  # If +use_tcp+ is true, the resolver will perform all queries
  # using TCP virtual circuits instead of UDP datagrams, which
  # is the default for the DNS protocol.
  #
  #   res.use_tcp = true
  #   res.query "host.example.com"
  #     #=> Sending TCP segments...
  #
  # Default is false.
  #
  # source://net-dns//lib/net/dns/resolver.rb#670
  def use_tcp=(bool); end

  # Get the state of the use_tcp flag.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#654
  def use_tcp?; end

  # Get the state of the use_tcp flag.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#654
  def usevc; end

  # If +use_tcp+ is true, the resolver will perform all queries
  # using TCP virtual circuits instead of UDP datagrams, which
  # is the default for the DNS protocol.
  #
  #   res.use_tcp = true
  #   res.query "host.example.com"
  #     #=> Sending TCP segments...
  #
  # Default is false.
  #
  # source://net-dns//lib/net/dns/resolver.rb#670
  def usevc=(bool); end

  private

  # source://net-dns//lib/net/dns/resolver.rb#1099
  def make_query_packet(string, type, cls); end

  # source://net-dns//lib/net/dns/resolver.rb#1089
  def nameservers_from_name(arg); end

  # Parses a configuration file specified as the argument.
  #
  # source://net-dns//lib/net/dns/resolver.rb#1041
  def parse_config_file; end

  # Parses environment variables.
  #
  # source://net-dns//lib/net/dns/resolver.rb#1067
  def parse_environment_variables; end

  # source://net-dns//lib/net/dns/resolver.rb#1128
  def query_tcp(_packet, packet_data); end

  # source://net-dns//lib/net/dns/resolver.rb#1174
  def query_udp(_packet, packet_data); end

  # FIXME: a ? method should never raise.
  #
  # @return [Boolean]
  #
  # source://net-dns//lib/net/dns/resolver.rb#1202
  def valid?(name); end

  class << self
    # Returns true if running on a Windows platform.
    #
    # Note. This method doesn't rely on the RUBY_PLATFORM constant
    # because the comparison will fail when running on JRuby.
    # On JRuby RUBY_PLATFORM == 'java'.
    #
    # @return [Boolean]
    #
    # source://net-dns//lib/net/dns/resolver.rb#138
    def platform_windows?; end

    # Quick resolver method. Bypass the configuration using
    # the defaults.
    #
    #   Net::DNS::Resolver.start "www.google.com"
    #
    # source://net-dns//lib/net/dns/resolver.rb#129
    def start(*params); end
  end
end

# source://net-dns//lib/net/dns/resolver/timeouts.rb#6
class Net::DNS::Resolver::DnsTimeout
  # @raise [ArgumentError]
  # @return [DnsTimeout] a new instance of DnsTimeout
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#9
  def initialize(seconds); end

  # source://net-dns//lib/net/dns/resolver/timeouts.rb#21
  def pretty_to_s; end

  # Returns the value of attribute seconds.
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#7
  def seconds; end

  # Executes the method's block. If the block execution terminates before +sec+
  # seconds has passed, it returns true. If not, it terminates the execution
  # and raises Timeout::Error.
  # If @seconds is 0 or nil, no timeout is set.
  #
  # @raise [LocalJumpError]
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#29
  def timeout(&block); end

  # Returns a string representation of the timeout corresponding
  # to the number of <tt>@seconds</tt>.
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#17
  def to_s; end

  private

  # source://net-dns//lib/net/dns/resolver/timeouts.rb#37
  def transform(secs); end
end

# source://net-dns//lib/net/dns/resolver/timeouts.rb#53
class Net::DNS::Resolver::TcpTimeout < ::Net::DNS::Resolver::DnsTimeout
  # @return [TcpTimeout] a new instance of TcpTimeout
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#54
  def initialize(seconds); end
end

# source://net-dns//lib/net/dns/resolver/timeouts.rb#60
class Net::DNS::Resolver::UdpTimeout < ::Net::DNS::Resolver::DnsTimeout
  # @return [UdpTimeout] a new instance of UdpTimeout
  #
  # source://net-dns//lib/net/dns/resolver/timeouts.rb#61
  def initialize(seconds); end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://net-dns//lib/net/dns/resolver.rb#19
  def Resolver(name, type = T.unsafe(nil), cls = T.unsafe(nil)); end
end
