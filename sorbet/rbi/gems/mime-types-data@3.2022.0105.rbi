# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mime-types-data` gem.
# Please instead update this file by running `bin/tapioca gem mime-types-data`.

# The namespace for MIME applications, tools, and libraries.
module MIME; end

# MIME::Types is a registry of MIME types. It is both a class (created with
# MIME::Types.new) and a default registry (loaded automatically or through
# interactions with MIME::Types.[] and MIME::Types.type_for).
#
# == The Default mime-types Registry
#
# The default mime-types registry is loaded automatically when the library
# is required (<tt>require 'mime/types'</tt>), but it may be lazily loaded
# (loaded on first use) with the use of the environment variable
# +RUBY_MIME_TYPES_LAZY_LOAD+ having any value other than +false+. The
# initial startup is about 14× faster (~10 ms vs ~140 ms), but the
# registry will be loaded at some point in the future.
#
# The default mime-types registry can also be loaded from a Marshal cache
# file specific to the version of MIME::Types being loaded. This will be
# handled automatically with the use of a file referred to in the
# environment variable +RUBY_MIME_TYPES_CACHE+. MIME::Types will attempt to
# load the registry from this cache file (MIME::Type::Cache.load); if it
# cannot be loaded (because the file does not exist, there is an error, or
# the data is for a different version of mime-types), the default registry
# will be loaded from the normal JSON version and then the cache file will
# be *written* to the location indicated by +RUBY_MIME_TYPES_CACHE+. Cache
# file loads just over 4½× faster (~30 ms vs ~140 ms).
# loads.
#
# Notes:
# * The loading of the default registry is *not* atomic; when using a
#   multi-threaded environment, it is recommended that lazy loading is not
#   used and mime-types is loaded as early as possible.
# * Cache files should be specified per application in a multiprocess
#   environment and should be initialized during deployment or before
#   forking to minimize the chance that the multiple processes will be
#   trying to write to the same cache file at the same time, or that two
#   applications that are on different versions of mime-types would be
#   thrashing the cache.
# * Unless cache files are preinitialized, the application using the
#   mime-types cache file must have read/write permission to the cache file.
#
# == Usage
#  require 'mime/types'
#
#  plaintext = MIME::Types['text/plain']
#  print plaintext.media_type           # => 'text'
#  print plaintext.sub_type             # => 'plain'
#
#  puts plaintext.extensions.join(" ")  # => 'asc txt c cc h hh cpp'
#
#  puts plaintext.encoding              # => 8bit
#  puts plaintext.binary?               # => false
#  puts plaintext.ascii?                # => true
#  puts plaintext.obsolete?             # => false
#  puts plaintext.registered?           # => true
#  puts plaintext.provisional?          # => false
#  puts plaintext == 'text/plain'       # => true
#  puts MIME::Type.simplified('x-appl/x-zip') # => 'appl/zip'
class MIME::Types
  include ::Enumerable
  extend ::Enumerable

  # Creates a new MIME::Types registry.
  #
  # @return [Types] a new instance of Types
  def initialize; end

  # Returns a list of MIME::Type objects, which may be empty. The optional
  # flag parameters are <tt>:complete</tt> (finds only complete MIME::Type
  # objects) and <tt>:registered</tt> (finds only MIME::Types that are
  # registered). It is possible for multiple matches to be returned for
  # either type (in the example below, 'text/plain' returns two values --
  # one for the general case, and one for VMS systems).
  #
  #   puts "\nMIME::Types['text/plain']"
  #   MIME::Types['text/plain'].each { |t| puts t.to_a.join(", ") }
  #
  #   puts "\nMIME::Types[/^image/, complete: true]"
  #   MIME::Types[/^image/, :complete => true].each do |t|
  #     puts t.to_a.join(", ")
  #   end
  #
  # If multiple type definitions are returned, returns them sorted as
  # follows:
  #   1. Complete definitions sort before incomplete ones;
  #   2. IANA-registered definitions sort before LTSW-recorded
  #      definitions.
  #   3. Current definitions sort before obsolete ones;
  #   4. Obsolete definitions with use-instead clauses sort before those
  #      without;
  #   5. Obsolete definitions use-instead clauses are compared.
  #   6. Sort on name.
  def [](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

  # Add one or more MIME::Type objects to the set of known types. If the
  # type is already known, a warning will be displayed.
  #
  # The last parameter may be the value <tt>:silent</tt> or +true+ which
  # will suppress duplicate MIME type warnings.
  def add(*types); end

  # Add a single MIME::Type object to the set of known types. If the +type+ is
  # already known, a warning will be displayed. The +quiet+ parameter may be a
  # truthy value to suppress that warning.
  def add_type(type, quiet = T.unsafe(nil)); end

  # Returns the number of known type variants.
  def count; end

  # Iterates through the type variants.
  def each; end

  def inspect; end

  # Return the list of MIME::Types which belongs to the file based on its
  # filename extension. If there is no extension, the filename will be used
  # as the matching criteria on its own.
  #
  # This will always return a merged, flatten, priority sorted, unique array.
  #
  #   puts MIME::Types.type_for('citydesk.xml')
  #     => [application/xml, text/xml]
  #   puts MIME::Types.type_for('citydesk.gif')
  #     => [image/gif]
  #   puts MIME::Types.type_for(%w(citydesk.xml citydesk.gif))
  #     => [application/xml, image/gif, text/xml]
  def of(filename); end

  # Return the list of MIME::Types which belongs to the file based on its
  # filename extension. If there is no extension, the filename will be used
  # as the matching criteria on its own.
  #
  # This will always return a merged, flatten, priority sorted, unique array.
  #
  #   puts MIME::Types.type_for('citydesk.xml')
  #     => [application/xml, text/xml]
  #   puts MIME::Types.type_for('citydesk.gif')
  #     => [image/gif]
  #   puts MIME::Types.type_for(%w(citydesk.xml citydesk.gif))
  #     => [application/xml, image/gif, text/xml]
  def type_for(filename); end

  private

  def add_type_variant!(mime_type); end
  def index_extensions!(mime_type); end
  def match(pattern); end
  def prune_matches(matches, complete, registered); end
  def reindex_extensions!(mime_type); end

  class << self
    # MIME::Types#[] against the default MIME::Types registry.
    def [](type_id, complete: T.unsafe(nil), registered: T.unsafe(nil)); end

    # MIME::Types#add against the default MIME::Types registry.
    def add(*types); end

    # MIME::Types#count against the default MIME::Types registry.
    def count; end

    # MIME::Types#each against the default MIME::Types registry.
    def each; end

    # Configure the MIME::Types logger. This defaults to an instance of a
    # logger that passes messages (unformatted) through to Kernel#warn.
    def logger; end

    # Configure the MIME::Types logger. This defaults to an instance of a
    # logger that passes messages (unformatted) through to Kernel#warn.
    def logger=(_arg0); end

    def new(*_arg0); end

    # MIME::Types#type_for against the default MIME::Types registry.
    def of(filename); end

    # MIME::Types#type_for against the default MIME::Types registry.
    def type_for(filename); end

    private

    def __instances__; end
    def __types__; end

    # @return [Boolean]
    def lazy_load?; end

    def load_default_mime_types(mode = T.unsafe(nil)); end
    def load_mode; end
    def reindex_extensions(type); end
  end
end

# Caching of MIME::Types registries is advisable if you will be loading
# the default registry relatively frequently. With the class methods on
# MIME::Types::Cache, any MIME::Types registry can be marshaled quickly
# and easily.
#
# The cache is invalidated on a per-data-version basis; a cache file for
# version 3.2015.1118 will not be reused with version 3.2015.1201.
class MIME::Types::Cache < ::Struct
  def data; end
  def data=(_); end
  def version; end
  def version=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end

    # Attempts to load the cache from the file provided as a parameter or in
    # the environment variable +RUBY_MIME_TYPES_CACHE+. Returns +nil+ if the
    # file does not exist, if the file cannot be loaded, or if the data in
    # the cache version is different than this version.
    def load(cache_file = T.unsafe(nil)); end

    def members; end
    def new(*_arg0); end

    # Attempts to save the types provided to the cache file provided.
    #
    # If +types+ is not provided or is +nil+, the cache will contain the
    # current MIME::Types default registry.
    #
    # If +cache_file+ is not provided or is +nil+, the cache will be written
    # to the file specified in the environment variable
    # +RUBY_MIME_TYPES_CACHE+. If there is no cache file specified either
    # directly or through the environment, this method will return +nil+
    def save(types = T.unsafe(nil), cache_file = T.unsafe(nil)); end
  end
end

module MIME::Types::Data; end

# The path that will be used for loading the MIME::Types data. The
# default location is __FILE__/../../../../data, which is where the data
# lives in the gem installation of the mime-types-data library.
#
# The MIME::Types::Loader will load all JSON or columnar files contained
# in this path.
#
# System maintainer note: this is the constant to change when packaging
# mime-types for your system. It is recommended that the path be
# something like /usr/share/ruby/mime-types/.
MIME::Types::Data::PATH = T.let(T.unsafe(nil), String)

MIME::Types::Data::VERSION = T.let(T.unsafe(nil), String)

# The release version of Ruby MIME::Types
MIME::Types::VERSION = T.let(T.unsafe(nil), String)
