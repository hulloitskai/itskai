# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `typhoeus` gem.
# Please instead update this file by running `bin/tapioca gem typhoeus`.

module Faraday
  class << self
    def default_adapter; end
    def default_adapter=(adapter); end
    def default_connection; end
    def default_connection=(_arg0); end
    def default_connection_options; end
    def default_connection_options=(options); end
    def ignore_env_proxy; end
    def ignore_env_proxy=(_arg0); end
    def lib_path; end
    def lib_path=(_arg0); end
    def new(url = T.unsafe(nil), options = T.unsafe(nil), &block); end
    def require_lib(*libs); end
    def require_libs(*libs); end
    def respond_to_missing?(symbol, include_private = T.unsafe(nil)); end
    def root_path; end
    def root_path=(_arg0); end

    private

    def method_missing(name, *args, &block); end
  end
end

class Faraday::Adapter
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper

  def initialize(_app = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  def call(env); end
  def close; end
  def connection(env); end

  private

  def request_timeout(type, options); end
  def save_response(env, status, body, headers = T.unsafe(nil), reason_phrase = T.unsafe(nil)); end
end

Faraday::Adapter::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Faraday::Adapter::TIMEOUT_KEYS = T.let(T.unsafe(nil), Hash)

# Adapter to use Faraday with Typhoeus.
#
# @example Use Typhoeus.
#   require 'faraday'
#   require 'typhoeus'
#   require 'typhoeus/adapters/faraday'
#
#   conn = Faraday.new(url: "www.example.com") do |faraday|
#   faraday.adapter :typhoeus
#
#   # You can include Typhoeus options to be used for every request
#   # faraday.adapter :typhoeus, forbid_reuse: true, maxredirs: 1
#   end
#
#   response = conn.get("/")
class Faraday::Adapter::Typhoeus < ::Faraday::Adapter
  # Initialize the Typhoeus adapter
  #
  # @option [
  # @param app [App] Farday app
  # @param [ [Hash] a customizable set of options
  # @return [void]
  def initialize(app, adapter_options = T.unsafe(nil)); end

  # Hook into Faraday and perform the request with Typhoeus.
  #
  # @param env [Hash] The environment.
  # @return [void]
  # def call(env); end

  private

  def configure_proxy(req, env); end
  def configure_socket(req, env); end
  def configure_ssl(req, env); end
  def configure_timeout(req, env); end

  # @return [Boolean]
  def parallel?(env); end

  def perform_request(env); end
  def read_body(env); end
  def request(env); end
  def typhoeus_request(env); end

  class << self
    # Setup Hydra with provided options.
    #
    # @example Setup Hydra.
    #   Faraday::Adapter::Typhoeus.setup_parallel_manager
    #   #=> #<Typhoeus::Hydra ... >
    # @return [Typhoeus::Hydra] The hydra.
    def setup_parallel_manager(options = T.unsafe(nil)); end
  end
end

Faraday::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Faraday::CompositeReadIO = Faraday::Multipart::CompositeReadIO
Faraday::FilePart = Multipart::Post::UploadIO
Faraday::METHODS_WITH_BODY = T.let(T.unsafe(nil), Array)
Faraday::METHODS_WITH_QUERY = T.let(T.unsafe(nil), Array)
Faraday::ParamPart = Faraday::Multipart::ParamPart
Faraday::Parts = Multipart::Post::Parts
Faraday::Timer = Timeout
Faraday::UploadIO = Multipart::Post::UploadIO
Faraday::VERSION = T.let(T.unsafe(nil), String)

module Rack
  class << self
    def release; end
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files
Rack::GET = T.let(T.unsafe(nil), String)
Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)
Rack::MockSession = Rack::Test::Session
Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)
Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
module Rack::Typhoeus; end
module Rack::Typhoeus::Middleware; end

# This Rack middleware takes care of the proper deserialization of
# the nested params encoded by Typhoeus.
#
# @author Dwayne Macgowan
# @example Require the railtie when using Rails.
#   require 'typhoeus/railtie'
# @example Include the middleware for Rack based applications.
#   use Rack::Typhoeus::Middleware::ParamsDecoder
# @example Use the helper directly. Not recommended as b/c the interface might change.
#   require 'rack/typhoeus/middleware/params_decoder/helper'
#   include Rack::Typhoeus::Middleware::ParamsDecoder::Helper
#   decode!(params)
# @since 0.5.4
class Rack::Typhoeus::Middleware::ParamsDecoder
  include ::Rack::Typhoeus::Middleware::ParamsDecoder::Helper

  # @return [ParamsDecoder] a new instance of ParamsDecoder
  # @since 0.5.4
  def initialize(app); end

  # @since 0.5.4
  def call(env); end

  private

  # Persist params change in environment. Extracted from:
  # https://github.com/rack/rack/blob/master/lib/rack/request.rb#L243
  #
  # @since 0.5.4
  def update_params(req, k, v); end
end

module Rack::Typhoeus::Middleware::ParamsDecoder::Helper
  def decode(hash); end

  # Recursively decodes Typhoeus encoded arrays in given Hash.
  #
  # @param hash [Hash] . This Hash will be modified!
  # @return [Hash] Hash with properly decoded nested arrays.
  def decode!(hash); end

  # Recursively decodes Typhoeus encoded arrays in given Hash.
  #
  # @author Dwayne Macgowan
  # @example Use directly in a Rails controller.
  #   class ApplicationController
  #   before_filter :decode_typhoeus_arrays
  #   end
  def decode_typhoeus_arrays; end

  private

  # If the Hash is an array encoded by typhoeus an array is returned
  # else the self is returned
  #
  # @param hash [Hash] The Hash to convert into an Array.
  # @return [Arraya/Hash]
  def convert(hash); end

  # Checks if Hash is an Array encoded as a Hash.
  # Specifically will check for the Hash to have this
  # form: {'0' => v0, '1' => v1, .., 'n' => vN }
  #
  # @param hash [Hash]
  # @return [Boolean] True if its a encoded Array, else false.
  def encoded?(hash); end
end

Rack::UNLINK = T.let(T.unsafe(nil), String)
Rack::VERSION = T.let(T.unsafe(nil), Array)

# Typhoeus is a HTTP client library based on Ethon which
# wraps libcurl. Sitting on top of libcurl makes Typhoeus
# very reliable and fast.
#
# There are some gems using Typhoeus like
# {https://github.com/myronmarston/vcr VCR},
# {https://github.com/bblimke/webmock WebMock} or
# {https://github.com/technoweenie/faraday Faraday}. VCR
# and WebMock provide their own adapter whereas
# Faraday relies on {Faraday::Adapter::Typhoeus}
# since Typhoeus version 0.5.
#
# @example Make a request with the shortcut.
#   response = Typhoeus.get("www.example.com")
# @example Simplest request.
#   response = Typhoeus::Request.new("www.example.com").run
# @example Request with url parameters.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   params: {a: 1}
#   ).run
# @example Request with a body.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   body: {b: 2}
#   ).run
# @example Request with parameters and body.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   params: {a: 1},
#   body: {b: 2}
#   ).run
# @example Create a request and allow follow redirections.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   followlocation: true
#   ).run
# @example Use the hydra to do multiple requests.
#   hydra = Typhoeus::Hydra.new
#   requests = (0..9).map{ Typhoeus::Request.new("www.example.com") }
#   requests.each{ |request| hydra.queue(request) }
#   hydra.run
# @see Typhoeus::Request
# @see Typhoeus::Hydra
# @see Faraday::Adapter::Typhoeus
# @since 0.5.0
module Typhoeus
  extend ::Typhoeus::Request::Actions
  extend ::Typhoeus::Request::Callbacks::Types

  class << self
    # Add before callbacks.
    #
    # @example Add before callback.
    #   Typhoeus.before { |request| p request.base_url }
    # @param block [Block] The callback.
    # @return [Array<Block>] All before blocks.
    # @since 0.5.0
    # @yield [Typhoeus::Request]
    def before(&block); end

    # Set the Typhoeus configuration options by passing a block.
    #
    # @example Set the configuration options within a block.
    #   Typhoeus.configure do |config|
    #   config.verbose = true
    #   end
    # @example Set the configuration directly.
    #   Typhoeus::Config.verbose = true
    # @return [Typhoeus::Config] The configuration.
    # @see Typhoeus::Config
    # @since 0.5.0
    # @yield [Typhoeus::Config]
    def configure; end

    # Stub out a specific request.
    #
    # @example Stub a request and get a lazily-constructed response containing data from actual widgets that exist in the system when the stubbed request is made.
    #   Typhoeus.stub("www.example.com/widgets") do
    #   actual_widgets = Widget.all
    #   Typhoeus::Response.new(
    #   :body => actual_widgets.inject([]) do |ids, widget|
    #   ids << widget.id
    #   end.join(",")
    #   )
    #   end
    # @example Stub a request and get specified response.
    #   expected = Typhoeus::Response.new
    #   Typhoeus.stub("www.example.com").and_return(expected)
    #
    #   actual = Typhoeus.get("www.example.com")
    #   expected == actual
    #   #=> true
    # @example Stub a request and get a lazily-constructed response in the format requested.
    #   Typhoeus.stub("www.example.com") do |request|
    #   accept = (request.options[:headers]||{})['Accept'] || "application/json"
    #   format = accept.split(",").first
    #   body_obj = { 'things' => [ { 'id' => 'foo' } ] }
    #
    #   Typhoeus::Response.new(
    #   :headers => {
    #   'Content-Type' => format
    #   },
    #   :body => SERIALIZERS[format].serialize(body_obj)
    #   )
    #   end
    # @param options [Hash] The options to stub out.
    # @param base_url [String] The url to stub out.
    # @return [Typhoeus::Expectation] The expecatation.
    # @see Typhoeus::Expectation
    # @since 0.5.0
    def stub(base_url, options = T.unsafe(nil), &block); end

    # Execute given block as if block connection is turned off.
    # The old block connection state is restored afterwards.
    #
    # @example Make a real request, no matter if it's blocked.
    #   Typhoeus::Config.block_connection = true
    #   Typhoeus.get("www.example.com").code
    #   #=> raise Typhoeus::Errors::NoStub
    #
    #   Typhoeus.with_connection do
    #   Typhoeus.get("www.example.com").code
    #   #=> :ok
    #   end
    # @return [Object] Returns the return value of the block.
    # @see Typhoeus::Config.block_connection
    # @since 0.5.0
    # @yield Yields control to the block after disabling block_connection.
    #   Afterwards, the block_connection is set to its original
    #   value.
    def with_connection; end
  end
end

module Typhoeus::Cache; end

# This module provides a simple way to cache HTTP responses in using the Rails cache.
class Typhoeus::Cache::Rails
  # @example Use the Rails cache setup to cache Typhoeus responses.
  #   Typhoeus::Config.cache = Typhoeus::Cache::Rails.new
  # @option options
  # @param cache [ActiveSupport::Cache::Store] A Rails cache backend. Defaults to Rails.cache.
  # @param options [Hash] Options
  # @return [Rails] a new instance of Rails
  def initialize(cache = T.unsafe(nil), options = T.unsafe(nil)); end

  def get(request); end
  def set(request, response); end
end

# The Typhoeus configuration used to set global
# options.
#
# @example Set the configuration options within a block.
#   Typhoeus.configure do |config|
#   config.verbose = true
#   end
# @example Set the configuration directly.
#   Typhoeus::Config.verbose = true
module Typhoeus::Config
  extend ::Typhoeus::Config

  # Defines whether the connection is blocked.
  # Defaults to false. When set to true, only
  # stubbed requests are allowed. A
  # {Typhoeus::Errors::NoStub} error is raised,
  # when trying to do a real request. It's possible
  # to work around inside
  # {Typhoeus.with_connection}.
  #
  # @return [Boolean]
  # @see Typhoeus::Request::BlockConnection
  # @see Typhoeus::Hydra::BlockConnection
  # @see Typhoeus#with_connection
  # @see Typhoeus::Errors::NoStub
  def block_connection; end

  # Defines whether the connection is blocked.
  # Defaults to false. When set to true, only
  # stubbed requests are allowed. A
  # {Typhoeus::Errors::NoStub} error is raised,
  # when trying to do a real request. It's possible
  # to work around inside
  # {Typhoeus.with_connection}.
  #
  # @return [Boolean]
  # @see Typhoeus::Request::BlockConnection
  # @see Typhoeus::Hydra::BlockConnection
  # @see Typhoeus#with_connection
  # @see Typhoeus::Errors::NoStub
  def block_connection=(_arg0); end

  # Defines whether requests are cached.
  #
  # @return [Object]
  # @see Typhoeus::Hydra::Cacheable
  # @see Typhoeus::Request::Cacheable
  def cache; end

  # Defines whether requests are cached.
  #
  # @return [Object]
  # @see Typhoeus::Hydra::Cacheable
  # @see Typhoeus::Request::Cacheable
  def cache=(_arg0); end

  # Defines whether GET requests are memoized when using the {Typhoeus::Hydra}.
  #
  # @return [Boolean]
  # @see Typhoeus::Hydra
  # @see Typhoeus::Hydra::Memoizable
  def memoize; end

  # Defines whether GET requests are memoized when using the {Typhoeus::Hydra}.
  #
  # @return [Boolean]
  # @see Typhoeus::Hydra
  # @see Typhoeus::Hydra::Memoizable
  def memoize=(_arg0); end

  # Defines wether to use a proxy server for every request.
  #
  # @return [String]
  # @see Typhoeus::Request#set_defaults
  def proxy; end

  # Defines wether to use a proxy server for every request.
  #
  # @return [String]
  # @see Typhoeus::Request#set_defaults
  def proxy=(_arg0); end

  # Defines whether to use a default user agent.
  #
  # @return [String]
  # @see Typhoeus::Request#set_defaults
  def user_agent; end

  # Defines whether to use a default user agent.
  #
  # @return [String]
  # @see Typhoeus::Request#set_defaults
  def user_agent=(_arg0); end

  # Defines whether curls debug output is shown.
  # Unfortunately it prints to stderr.
  #
  # @return [Boolean]
  # @see http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTVERBOSE
  def verbose; end

  # Defines whether curls debug output is shown.
  # Unfortunately it prints to stderr.
  #
  # @return [Boolean]
  # @see http://curl.haxx.se/libcurl/c/curl_easy_setopt.html#CURLOPTVERBOSE
  def verbose=(_arg0); end
end

# This is a Factory for easies to be used in the hydra.
# Before an easy is ready to be added to a multi the
# on_complete callback to be set.
# This is done by this class.
#
# @api private
class Typhoeus::EasyFactory
  # Create an easy factory.
  #
  # @api private
  # @example Create easy factory.
  #   Typhoeus::Hydra::EasyFactory.new(request, hydra)
  # @param request [Request] The request to build an easy for.
  # @param hydra [Hydra] The hydra to build an easy for.
  # @return [EasyFactory] a new instance of EasyFactory
  def initialize(request, hydra = T.unsafe(nil)); end

  # Return the easy in question.
  #
  # @api private
  # @example Return easy.
  #   easy_factory.easy
  # @return [Ethon::Easy] The easy.
  def easy; end

  # Fabricated easy.
  #
  # @api private
  # @example Prepared easy.
  #   easy_factory.get
  # @return [Ethon::Easy] The easy.
  def get; end

  # Returns the hydra provided.
  #
  # @api private
  # @return [Typhoeus::Hydra]
  def hydra; end

  # Returns the request provided.
  #
  # @api private
  # @return [Typhoeus::Request]
  def request; end

  private

  # @api private
  def provide_help(option); end

  # @api private
  def sanitize(options); end

  # @api private
  def sanitize_timeout!(options, timeout); end

  # Sets on_complete callback on easy in order to be able to
  # track progress.
  #
  # @api private
  # @example Set callback.
  #   easy_factory.set_callback
  # @return [Ethon::Easy] The easy.
  def set_callback; end
end

# @api private
Typhoeus::EasyFactory::CHANGED_OPTIONS = T.let(T.unsafe(nil), Hash)

# @api private
Typhoeus::EasyFactory::REMOVED_OPTIONS = T.let(T.unsafe(nil), Set)

# @api private
Typhoeus::EasyFactory::RENAMED_OPTIONS = T.let(T.unsafe(nil), Hash)

# @api private
Typhoeus::EasyFactory::SANITIZE_IGNORE = T.let(T.unsafe(nil), Set)

# @api private
Typhoeus::EasyFactory::SANITIZE_TIMEOUT = T.let(T.unsafe(nil), Set)

# This namespace contains all errors raised by Typhoeus.
module Typhoeus::Errors; end

# Raises when block connection is turned on
# and making a real request.
class Typhoeus::Errors::NoStub < ::Typhoeus::Errors::TyphoeusError
  # @return [NoStub] a new instance of NoStub
  def initialize(request); end
end

# Default typhoeus error class for all custom errors.
class Typhoeus::Errors::TyphoeusError < ::StandardError; end

# This class represents an expectation. It is part
# of the stubbing mechanism. An expectation contains
# a url and options, like a request. They are compared
# to the request url and options in order to evaluate
# whether they match. If that's the case, the attached
# responses are returned one by one.
#
# @example Stub a request and get specified response.
#   expected = Typhoeus::Response.new
#   Typhoeus.stub("www.example.com").and_return(expected)
#
#   actual = Typhoeus.get("www.example.com")
#   expected == actual
#   #=> true
# @example Stub a request and get a lazily-constructed response containing data from actual widgets that exist in the system when the stubbed request is made.
#   Typhoeus.stub("www.example.com/widgets") do
#   actual_widgets = Widget.all
#   Typhoeus::Response.new(
#   :body => actual_widgets.inject([]) do |ids, widget|
#   ids << widget.id
#   end.join(",")
#   )
#   end
# @example Stub a request and get a lazily-constructed response in the format requested.
#   Typhoeus.stub("www.example.com") do |request|
#   accept = (request.options[:headers]||{})['Accept'] || "application/json"
#   format = accept.split(",").first
#   body_obj = { 'things' => [ { 'id' => 'foo' } ] }
#
#   Typhoeus::Response.new(
#   :headers => {
#   'Content-Type' => format
#   },
#   :body => SERIALIZERS[format].serialize(body_obj)
#   )
#   end
class Typhoeus::Expectation
  # Creates an expectation.
  #
  # @api private
  # @example Create expectation.
  #   Typhoeus::Expectation.new(base_url)
  # @return [Expectation] The created expectation.
  def initialize(base_url, options = T.unsafe(nil)); end

  # Specify what should be returned,
  # when this expectation is hit.
  #
  # @example Add response.
  #   expectation.and_return(response)
  # @return [void]
  def and_return(response = T.unsafe(nil), &block); end

  # @api private
  def base_url; end

  # @api private
  def from; end

  # Checks whether this expectation matches
  # the provided request.
  #
  # @api private
  # @example Check if request matches.
  #   expectation.matches? request
  # @param request [Request] The request to check.
  # @return [Boolean] True when matches, else false.
  def matches?(request); end

  # @api private
  def options; end

  # Return the response. When there are
  # multiple responses, they are returned one
  # by one.
  #
  # @api private
  # @example Return response.
  #   expectation.response
  # @return [Response] The response.
  def response(request); end

  # Return canned responses.
  #
  # @api private
  # @example Return responses.
  #   expectation.responses
  # @return [Array<Typhoeus::Response>] The responses.
  def responses; end

  # Set from value to mark an expectaion. Useful for
  # other libraries, e.g. WebMock.
  #
  # @api private
  # @example Mark expectation.
  #   expectation.from(:webmock)
  # @param value [String] Value to set.
  # @return [Expectation] Returns self.
  def stubbed_from(value); end

  private

  # Check whether the options matches the request options.
  # I checks options and original options.
  #
  # @return [Boolean]
  def options_match?(request); end

  # Check whether the base_url matches the request url.
  # The base_url can be a string, regex or nil. String and
  # regexp are checked, nil is always true, else false.
  #
  # Nil serves as a placeholder in case you want to match
  # all urls.
  #
  # @return [Boolean]
  def url_match?(request_url); end

  class << self
    # Returns all expectations.
    #
    # @example Return expectations.
    #   Typhoeus::Expectation.all
    # @return [Array<Typhoeus::Expectation>] The expectations.
    def all; end

    # Clears expectations. This is handy while
    # testing, and you want to make sure that
    # you don't get canned responses.
    #
    # @example Clear expectations.
    #   Typhoeus::Expectation.clear
    def clear; end

    # @api private
    def find_by(request); end

    # Returns stubbed response matching the
    # provided request.
    #
    # @api private
    # @example Find response
    #   Typhoeus::Expectation.response_for(request)
    # @return [Typhoeus::Response] The stubbed response from a
    #   matching expectation, or nil if no matching expectation
    #   is found.
    def response_for(request); end
  end
end

# Hydra manages making parallel HTTP requests. This
# is achieved by using libcurls multi interface:
# http://curl.haxx.se/libcurl/c/libcurl-multi.html
# The benefits are that you don't have to worry running
# the requests by yourself.
#
# Hydra will also handle how many requests you can
# make in parallel. Things will get flakey if you
# try to make too many requests at the same time.
# The built in limit is 200. When more requests than
# that are queued up, hydra will save them for later
# and start the requests as others are finished. You
# can raise or lower the concurrency limit through
# the Hydra constructor.
#
# Regarding the asynchronous behavior of the hydra,
# it is important to know that this is completely hidden
# from the developer and you are free to apply
# whatever technique you want to your code. That should not
# conflict with libcurls internal concurrency mechanism.
#
# @example Use the hydra to do multiple requests.
#   hydra = Typhoeus::Hydra.new
#   requests = (0..9).map{ Typhoeus::Request.new("www.example.com") }
#   requests.each{ |request| hydra.queue(request) }
#   hydra.run
# @note Callbacks are going to delay the request
#   execution.
class Typhoeus::Hydra
  include ::Typhoeus::Hydra::Addable
  include ::Typhoeus::Hydra::Runnable
  include ::Typhoeus::Hydra::Memoizable
  include ::Typhoeus::Hydra::Cacheable
  include ::Typhoeus::Hydra::BlockConnection
  include ::Typhoeus::Hydra::Stubbable
  include ::Typhoeus::Hydra::Before
  include ::Typhoeus::Hydra::Queueable

  # Create a new hydra. All
  # {http://rubydoc.info/github/typhoeus/ethon/Ethon/Multi#initialize-instance_method Ethon::Multi#initialize}
  # options are also available.
  #
  # @example Create a hydra.
  #   Typhoeus::Hydra.new
  # @example Create a hydra with max_concurrency.
  #   Typhoeus::Hydra.new(max_concurrency: 20)
  # @option options
  # @param options [Hash] The options hash.
  # @return [Hydra] a new instance of Hydra
  # @see http://rubydoc.info/github/typhoeus/ethon/Ethon/Multi#initialize-instance_method Ethon::Multi#initialize
  def initialize(options = T.unsafe(nil)); end

  # @example Set max_concurrency.
  #   Typhoeus::Hydra.new(max_concurrency: 20)
  def max_concurrency; end

  # @example Set max_concurrency.
  #   Typhoeus::Hydra.new(max_concurrency: 20)
  def max_concurrency=(_arg0); end

  # @api private
  def multi; end

  class << self
    # Returns a memoized hydra instance.
    #
    # @example Get a hydra.
    #   Typhoeus::Hydra.hydra
    # @return [Typhoeus::Hydra] A new hydra.
    def hydra; end
  end
end

# This module handles the request adding on
# hydra.
#
# @api private
module Typhoeus::Hydra::Addable
  # Adds request to multi.
  #
  # @api private
  # @example Add request.
  #   hydra.add(request)
  # @param request [Typhoeus::Request] to add.
  # @return [void]
  def add(request); end
end

# This module provides a way to hook into before
# a request gets queued in hydra. This is very powerful
# and you should be careful because when you accidently
# return a falsy value the request won't be executed.
#
# @api private
module Typhoeus::Hydra::Before
  # Overrride add in order to execute callbacks in
  # Typhoeus.before. Will break and return when a
  # callback returns nil, false or a response. Calls super
  # otherwise.
  #
  # @api private
  # @example Add the request.
  #   hydra.add(request)
  def add(request); end
end

# This module handles the blocked connection request mode on
# the hydra side, where only stubbed requests
# are allowed.
# Connection blocking needs to be turned on:
#   Typhoeus.configure do |config|
#     config.block_connection = true
#   end
#
# When trying to do real requests a NoStub error
# is raised.
#
# @api private
module Typhoeus::Hydra::BlockConnection
  # Overrides add in order to check before if block connection
  # is turned on. If thats the case a NoStub error is
  # raised.
  #
  # @api private
  # @example Add the request.
  #   hydra.add(request)
  # @param request [Request] The request to enqueue.
  def add(request); end
end

module Typhoeus::Hydra::Cacheable
  def add(request); end
end

# This module handles the GET request memoization
# on the hydra side. Memoization needs to be turned
# on:
#   Typhoeus.configure do |config|
#     config.memoize = true
#   end
#
# @api private
module Typhoeus::Hydra::Memoizable
  # Overrides add in order to check before if request
  # is memoizable and already in memory. If thats the case,
  # super is not called, instead the response is set and
  # the on_complete callback called.
  #
  # @api private
  # @example Add the request.
  #   hydra.add(request)
  # @param request [Request] The request to add.
  # @return [Request] The added request.
  def add(request); end

  # Return the memory.
  #
  # @api private
  # @example Return the memory.
  #   hydra.memory
  # @return [Hash] The memory.
  def memory; end

  # Overrides run to make sure the memory is cleared after
  # each run.
  #
  # @api private
  # @example Run hydra.
  #   hydra.run
  def run; end
end

# This module handles the request queueing on
# hydra.
#
# @api private
module Typhoeus::Hydra::Queueable
  # Abort the current hydra run as good as
  # possible. This means that it only
  # clears the queued requests and can't do
  # anything about already running requests.
  #
  # @api private
  # @example Abort hydra.
  #   hydra.abort
  def abort; end

  # Removes a request from queued_requests and
  # adds it to the hydra in order to be
  # performed next.
  #
  # @api private
  # @example Dequeue request.
  #   hydra.dequeue
  # @since 0.6.4
  def dequeue; end

  # Removes requests from queued_requests and
  # adds them to the hydra until max_concurrency
  # is reached.
  #
  # @api private
  # @example Dequeue requests.
  #   hydra.dequeue_many
  # @since 0.6.8
  def dequeue_many; end

  # Enqueues a request in order to be performed
  # by the hydra. This can even be done while
  # the hydra is running. Also sets hydra on
  # request.
  #
  # @api private
  # @example Queue request.
  #   hydra.queue(request)
  def queue(request); end

  # Pushes a request to the front of the queue,
  # to be performed by the hydra. Also sets hydra
  # on request
  #
  # @api private
  # @example Queue reques.
  #   hydra.queue_front(request)
  def queue_front(request); end

  # Return the queued requests.
  #
  # @api private
  # @example Return queued requests.
  #   hydra.queued_requests
  # @return [Array<Typhoeus::Request>] The queued requests.
  def queued_requests; end
end

# This module contains logic to run a hydra.
module Typhoeus::Hydra::Runnable
  # Start the hydra run.
  #
  # @example Start hydra run.
  #   hydra.run
  # @return [Symbol] Return value from multi.perform.
  def run; end
end

# This module handles stubbing on the hydra side.
# It plays well with the block_connection configuration,
# which raises when you make a request which is not stubbed.
#
# @api private
module Typhoeus::Hydra::Stubbable
  # Override add in order to check for matching expecations.
  # When an expecation is found, super is not called. Instead a
  # canned response is assigned to the request.
  #
  # @api private
  # @example Add the request.
  #   hydra.add(request)
  def add(request); end
end

# The easy pool stores already initialized
# easy handles for future use. This is useful
# because creating them is expensive.
#
# @api private
module Typhoeus::Pool
  class << self
    # Clear the pool
    #
    # @api private
    def clear; end

    # @api private
    def easies; end

    # Return an easy from the pool.
    #
    # @api private
    # @example Return easy.
    #   Typhoeus::Pool.get
    # @return [Ethon::Easy] The easy.
    def get; end

    # Releases easy into the pool. The easy handle is
    # reset before it gets back in.
    #
    # @api private
    # @example Release easy.
    #   Typhoeus::Pool.release(easy)
    def release(easy); end

    # Use yielded easy, will be released automatically afterwards.
    #
    # @api private
    # @example Use easy.
    #   Typhoeus::Pool.with_easy do |easy|
    #   # use easy
    #   end
    def with_easy(&block); end
  end
end

# This class represents a request.
#
# @example Make a request with the shortcut.
#   response = Typhoeus.get("www.example.com")
# @example Simplest request.
#   response = Typhoeus::Request.new("www.example.com").run
# @example Request with url parameters.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   params: {a: 1}
#   ).run
# @example Request with a body.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   body: {b: 2}
#   ).run
# @example Request with parameters and body.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   params: {a: 1},
#   body: {b: 2}
#   ).run
# @example Create a request and allow follow redirections.
#   response = Typhoeus::Request.new(
#   "www.example.com",
#   followlocation: true
#   ).run
# @see Typhoeus::Hydra
# @see Typhoeus::Response
# @see Typhoeus::Request::Actions
class Typhoeus::Request
  include ::Typhoeus::Request::Callbacks::Types
  include ::Typhoeus::Request::Callbacks
  include ::Typhoeus::Request::Streamable
  include ::Typhoeus::Request::Marshal
  include ::Typhoeus::Request::Operations
  include ::Typhoeus::Request::Responseable
  include ::Typhoeus::Request::Memoizable
  include ::Typhoeus::Request::Cacheable
  include ::Typhoeus::Request::BlockConnection
  include ::Typhoeus::Request::Stubbable
  include ::Typhoeus::Request::Before
  extend ::Typhoeus::Request::Actions

  # Creates a new request.
  #
  # @example Request with url parameters.
  #   response = Typhoeus::Request.new(
  #   "www.example.com",
  #   params: {a: 1}
  #   ).run
  # @example Simplest request.
  #   response = Typhoeus::Request.new("www.example.com").run
  # @example Request with a body.
  #   response = Typhoeus::Request.new(
  #   "www.example.com",
  #   body: {b: 2}
  #   ).run
  # @example Request with parameters and body.
  #   response = Typhoeus::Request.new(
  #   "www.example.com",
  #   params: {a: 1},
  #   body: {b: 2}
  #   ).run
  # @example Create a request and allow follow redirections.
  #   response = Typhoeus::Request.new(
  #   "www.example.com",
  #   followlocation: true
  #   ).run
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Typhoeus::Request] The request.
  # @see Typhoeus::Hydra
  # @see Typhoeus::Response
  # @see Typhoeus::Request::Actions
  def initialize(base_url, options = T.unsafe(nil)); end

  # Returns the provided base url.
  #
  # @return [String]
  def base_url; end

  # Returns the provided base url.
  #
  # @return [String]
  def base_url=(_arg0); end

  # @api private
  # @return [Boolean]
  def block_connection; end

  # @api private
  # @return [Boolean]
  def block_connection=(_arg0); end

  # Returns a cache key for use with caching methods that required a string
  # for a key. Will get used by ActiveSupport::Cache stores automatically.
  #
  # @return [String] The cache key.
  def cache_key; end

  # Mimics libcurls POST body generation. This is not accurate, but good
  # enough for VCR.
  #
  # @api private
  # @return [String] The encoded body.
  #   otherwise.
  def encoded_body; end

  # Returns whether other is equal to self.
  #
  # @api private
  # @example Are request equal?
  #   request.eql?(other_request)
  # @param other [Object] The object to check.
  # @return [Boolean] Returns true if equal, else false.
  def eql?(other); end

  # Overrides Object#hash.
  #
  # @api private
  # @return [Integer] The integer representing the request.
  def hash; end

  # Returns the hydra in which the request ran, if any.
  #
  # @api private
  # @return [Typhoeus::Hydra]
  def hydra; end

  # Returns the hydra in which the request ran, if any.
  #
  # @api private
  # @return [Typhoeus::Hydra]
  def hydra=(_arg0); end

  # Returns options, which includes default parameters.
  #
  # @return [Hash]
  def options; end

  # Returns options, which includes default parameters.
  #
  # @return [Hash]
  def options=(_arg0); end

  # Returns the original options provided.
  #
  # @api private
  # @return [Hash]
  def original_options; end

  # Returns the original options provided.
  #
  # @api private
  # @return [Hash]
  def original_options=(_arg0); end

  # Return the url.
  # In contrast to base_url which returns the value you specified, url returns
  # the full url including the parameters.
  #
  # @example Get the url.
  #   request.url
  # @since 0.5.5
  def url; end

  private

  # Checks if two hashes are equal or not, discarding
  # first-level hash order.
  #
  # @param left [Hash]
  # @param right [Hash] hash to check for equality
  # @return [Boolean] Returns true if hashes have
  #   same values for same keys and same length,
  #   even if the keys are given in a different order.
  def fuzzy_hash_eql?(left, right); end

  def hashable_string_for(obj); end

  # Sets default header and verbose when turned on.
  def set_defaults; end
end

# Module containing logic about shortcuts to
# http methods. Like
#   Typhoeus.get("www.example.com")
module Typhoeus::Request::Actions
  # Make a delete request.
  #
  # @example Make delete request.
  #   Typhoeus.delete("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def delete(base_url, options = T.unsafe(nil)); end

  # Make a get request.
  #
  # @example Make get request.
  #   Typhoeus.get("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def get(base_url, options = T.unsafe(nil)); end

  # Make a head request.
  #
  # @example Make head request.
  #   Typhoeus.head("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def head(base_url, options = T.unsafe(nil)); end

  # Make a options request.
  #
  # @example Make options request.
  #   Typhoeus.options("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def options(base_url, options = T.unsafe(nil)); end

  # Make a patch request.
  #
  # @example Make patch request.
  #   Typhoeus.patch("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def patch(base_url, options = T.unsafe(nil)); end

  # Make a post request.
  #
  # @example Make post request.
  #   Typhoeus.post("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def post(base_url, options = T.unsafe(nil)); end

  # Make a put request.
  #
  # @example Make put request.
  #   Typhoeus.put("www.example.com")
  # @note See {http://rubydoc.info/github/typhoeus/ethon/Ethon/Easy/Options Ethon::Easy::Options} for more options.
  # @option options
  # @option options
  # @param options [Hash] a customizable set of options
  # @param base_url [String] The url to request.
  # @param options [options] The options.
  # @return [Response] The new response.
  def put(base_url, options = T.unsafe(nil)); end
end

# This module provides a way to hook into before
# a request runs. This is very powerful
# and you should be careful because when you accidently
# return a falsy value the request won't be executed.
#
# @api private
module Typhoeus::Request::Before
  # Overrride run in order to execute callbacks in
  # Typhoeus.before. Will break and return when a
  # callback returns nil or false. Calls super
  # otherwise.
  #
  # @api private
  # @example Run the request.
  #   request.run
  def run; end
end

# This module handles the blocked connection request mode on
# the request side, where only stubbed requests
# are allowed.
# Connection blocking needs to be turned on:
#   Typhoeus.configure do |config|
#     config.block_connection = true
#   end
#
# When trying to do real requests a NoStub error
# is raised.
#
# @api private
module Typhoeus::Request::BlockConnection
  # Returns wether a request is blocked or not. Takes
  # request.block_connection and Typhoeus::Config.block_connection
  # into consideration.
  #
  # @api private
  # @example Blocked?
  #   request.blocked?
  # @return [Boolean] True if blocked, false else.
  def blocked?; end

  # Overrides run in order to check before if block connection
  # is turned on. If thats the case a NoStub error is
  # raised.
  #
  # @api private
  # @example Run request.
  #   request.run
  # @raise [Typhoeus::Errors::NoStub] If connection is blocked
  #   and no stub defined.
  def run; end
end

module Typhoeus::Request::Cacheable
  def cache_ttl; end

  # @return [Boolean]
  def cacheable?; end

  def cached_response; end
  def response=(response); end
  def run; end

  private

  def cache; end
end

# This module contains the logic for the response callbacks.
#
# You can set multiple callbacks, which are then executed
# in the same order.
#
#   request.on_complete { |response| p 1 }
#   request.on_complete { |response| p 2 }
#   request.execute_callbacks
#   #=> 1
#   #=> 2
#
# You can clear the callbacks:
#
#   request.on_complete { |response| p 1 }
#   request.on_complete { |response| p 2 }
#   request.on_complete.clear
#   request.execute_callbacks
#   #=> nil
#
# @note If you're using the Hydra to execute multiple
#   requests, then callbacks are delaying the
#   request execution.
module Typhoeus::Request::Callbacks
  # Execute necessary callback and yields response. This
  # include in every case on_complete and on_progress, on_success
  # if successful and on_failure if not.
  #
  # @api private
  # @example Execute callbacks.
  #   request.execute_callbacks
  # @return [void]
  def execute_callbacks; end

  # Execute the headers callbacks and yields response.
  #
  # @api private
  # @example Execute callbacks.
  #   request.execute_headers_callbacks
  # @return [Array<Object>] The results of the on_headers callbacks.
  def execute_headers_callbacks(response); end
end

module Typhoeus::Request::Callbacks::Types
  # Set on_complete callback.
  #
  # @example Set on_complete.
  #   request.on_complete { |response| p "yay" }
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_complete blocks.
  # @yield [Typhoeus::Response]
  def on_complete(&block); end

  # Set on_failure callback.
  #
  # @example Set on_failure.
  #   request.on_failure { |response| p "yay" }
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_failure blocks.
  # @yield [Typhoeus::Response]
  def on_failure(&block); end

  # Set on_headers callback.
  #
  # @example Set on_headers.
  #   request.on_headers { |response| p "yay" }
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_headers blocks.
  # @yield [Typhoeus::Response]
  def on_headers(&block); end

  # Set on_progress callback.
  #
  # @example Set on_progress.
  #   request.on_progress do |dltotal, dlnow, ultotal, ulnow|
  #   puts "dltotal (#{dltotal}), dlnow (#{dlnow}), ultotal (#{ultotal}), ulnow (#{ulnow})"
  #   end
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_progress blocks.
  # @yield [Typhoeus::Response]
  def on_progress(&block); end

  # Set on_success callback.
  #
  # @example Set on_success.
  #   request.on_success { |response| p "yay" }
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_success blocks.
  # @yield [Typhoeus::Response]
  def on_success(&block); end
end

# This module contains custom serializer.
module Typhoeus::Request::Marshal
  # Return the important data needed to serialize this Request, except the
  # request callbacks and `hydra`, since they cannot be marshalled.
  def marshal_dump; end

  # Load.
  def marshal_load(attributes); end
end

# This module handles the GET request memoization
# on the request side. Memoization needs to be turned
# on:
#   Typhoeus.configure do |config|
#     config.memoize = true
#   end
#
# @api private
module Typhoeus::Request::Memoizable
  # Return whether a request is memoizable.
  #
  # @api private
  # @example Is request memoizable?
  #   request.memoizable?
  # @return [Boolean] Return true if memoizable, false else.
  def memoizable?; end

  # Override response setter and memoizes response
  # if the request is memoizable.
  #
  # @api private
  # @example Set response.
  #   request.response = response
  # @param response [Response] The response to set.
  def response=(response); end
end

# This module contains everything what is necessary
# to make a single request.
module Typhoeus::Request::Operations
  # Sets a response, the request on the response
  # and executes the callbacks.
  #
  # @param response [Typhoeus::Response] The response.
  # @param bypass_memoization [Boolean] Wether to bypass
  #   memoization or not. Decides how the response is set.
  # @return [Typhoeus::Response] The response.
  def finish(response, bypass_memoization = T.unsafe(nil)); end

  # Run a request.
  #
  # @example Run a request.
  #   Typhoeus::Request.new("www.example.com").run
  # @return [Response] The response.
  def run; end
end

# This module contains logic for having a reponse
# getter and setter.
module Typhoeus::Request::Responseable
  # Return the response.
  #
  # @example Return response.
  #   request.response
  # @return [Response] The response.
  def response; end

  # Set the response.
  #
  # @example Set response.
  #   request.response = response
  # @param value [Response] The response to set.
  def response=(value); end
end

# This module contians the logic for response streaming.
module Typhoeus::Request::Streamable
  # Set on_body callback.
  #
  # This callback will be called each time a portion of the body is read from the socket.
  # Setting an on_body callback will cause the response body to be empty.
  #
  # @example Set on_body.
  #   request.on_body { |body_chunk, response| puts "Got #{body_chunk.bytesize} bytes" }
  # @param block [Block] The block to execute.
  # @return [Array<Block>] All on_body blocks.
  # @yield [Typhoeus::Response, String]
  def on_body(&block); end

  # Is this request using streaming?
  #
  # @return [Boolean] True if any on_body blocks have been set.
  def streaming?; end
end

# This module handles stubbing on the request side.
# It plays well with the block_connection configuration,
# which raises when you make a request which is not stubbed.
#
# @api private
module Typhoeus::Request::Stubbable
  # Override run in order to check for matching expectations.
  # When an expectation is found, super is not called. Instead a
  # canned response is assigned to the request.
  #
  # @api private
  # @example Run the request.
  #   request.run
  # @return [Response] The response.
  def run; end
end

# This class represents the response.
class Typhoeus::Response
  include ::Typhoeus::Response::Informations
  include ::Typhoeus::Response::Status
  include ::Typhoeus::Response::Cacheable

  # Create a new response.
  #
  # @example Create a response.
  #   Response.new
  # @param options [Hash] The options hash.
  # @return [Response] The new response.
  def initialize(options = T.unsafe(nil)); end

  # Returns the handled_response if it has
  # been defined; otherwise, returns the response
  #
  # @return [Object] The result of callbacks
  #   done on the response or the original response.
  def handled_response; end

  # Set the handled response.
  def handled_response=(_arg0); end

  # Returns whether this request is mocked
  # or not.
  #
  # @api private
  def mock; end

  # @api private
  def mock=(_arg0); end

  # Returns whether this request is mocked
  # or not.
  #
  # @api private
  def mock?; end

  # The provided options, which contain all the
  # informations about the request.
  #
  # @return [Hash]
  def options; end

  # The provided options, which contain all the
  # informations about the request.
  #
  # @return [Hash]
  def options=(_arg0); end

  # Remembers the corresponding request.
  #
  # @example Get request.
  #   request = Typhoeus::Request.new("www.example.com")
  #   response = request.run
  #   request == response.request
  #   #=> true
  # @return [Typhoeus::Request]
  def request; end

  # Remembers the corresponding request.
  #
  # @example Get request.
  #   request = Typhoeus::Request.new("www.example.com")
  #   response = request.run
  #   request == response.request
  #   #=> true
  # @return [Typhoeus::Request]
  def request=(_arg0); end
end

module Typhoeus::Response::Cacheable
  # Set the cache status, if we got response from cache
  # it will have cached? == true
  def cached=(_arg0); end

  # @return [Boolean]
  def cached?; end
end

# This class represents the response header.
# It can be accessed like a hash.
# Values can be strings (normal case) or arrays of strings (for duplicates headers)
#
# @api private
class Typhoeus::Response::Header
  # Create a new header.
  #
  # @api private
  # @example Create new header.
  #   Header.new(raw)
  # @param raw [String] The raw header.
  # @return [Header] a new instance of Header
  def initialize(raw); end

  # @api private
  def [](key); end

  # Parses the raw header.
  #
  # @api private
  # @example Parse header.
  #   header.parse
  def parse; end

  private

  # Processes line and saves the result.
  #
  # @api private
  # @return [void]
  def process_line(header); end

  # Sets key value pair for self and @sanitized.
  #
  # @api private
  # @return [void]
  def process_pair(key, value); end

  # Returns the raw header or empty string.
  #
  # @api private
  # @example Return raw header.
  #   header.raw
  # @return [String] The raw header.
  def raw; end

  # Sets the default proc for the specified hash independent of the Ruby version.
  #
  # @api private
  # @return [void]
  def set_default_proc_on(hash, default_proc); end

  # Sets value for key in specified hash
  #
  # @api private
  # @return [void]
  def set_value(key, value, hash); end
end

# This module contains logic about informations
# on a response.
module Typhoeus::Response::Informations
  # Return the time, in seconds, it took from the start
  # until the SSL/SSH connect/handshake to the remote
  # host was completed. This time is most often very near
  # to the pre transfer time, except for cases such as HTTP
  # pipelining where the pretransfer time can be delayed
  # due to waits in line for the pipeline and more.
  #
  # @example Get appconnect_time.
  #   response.appconnect_time
  # @return [Float] The appconnect_time.
  def app_connect_time; end

  # Return the time, in seconds, it took from the start
  # until the SSL/SSH connect/handshake to the remote
  # host was completed. This time is most often very near
  # to the pre transfer time, except for cases such as HTTP
  # pipelining where the pretransfer time can be delayed
  # due to waits in line for the pipeline and more.
  #
  # @example Get appconnect_time.
  #   response.appconnect_time
  # @return [Float] The appconnect_time.
  def appconnect_time; end

  # Return the http response body.
  #
  # @example Get response_body.
  #   response.response_body
  # @return [String] The response_body.
  def body; end

  # Return the last received HTTP, FTP or SMTP response code.
  # The value will be zero if no server response code has
  # been received. Note that a proxy's CONNECT response should
  # be read with http_connect_code and not this.
  #
  # @example Get response_code.
  #   response.response_code
  # @return [Integer] The response_code.
  def code; end

  # Return the time, in seconds, it took from the start
  # until the connect to the remote host (or proxy) was completed.
  #
  # @example Get connect_time.
  #   response.connect_time
  # @return [Float] The connect_time.
  def connect_time; end

  def debug_info; end

  # Return the last used effective url.
  #
  # @example Get effective_url.
  #   response.effective_url
  # @return [String] The effective_url.
  def effective_url; end

  # Returns the response header.
  #
  # @example Return headers.
  #   response.headers
  # @return [Typhoeus::Header] The response header.
  def headers; end

  # Returns the response header.
  #
  # @example Return headers.
  #   response.headers
  # @return [Typhoeus::Header] The response header.
  def headers_hash; end

  # Return the available http auth methods.
  # Bitmask indicating the authentication method(s)
  # available.
  #
  # @example Get httpauth_avail.
  #   response.httpauth_avail
  # @return [Integer] The bitmask.
  def httpauth_avail; end

  # Return the time, in seconds, it took from the
  # start until the name resolving was completed.
  #
  # @example Get namelookup_time.
  #   response.namelookup_time
  # @return [Float] The namelookup_time.
  def name_lookup_time; end

  # Return the time, in seconds, it took from the
  # start until the name resolving was completed.
  #
  # @example Get namelookup_time.
  #   response.namelookup_time
  # @return [Float] The namelookup_time.
  def namelookup_time; end

  # Return the time, in seconds, it took from the start
  # until the file transfer is just about to begin. This
  # includes all pre-transfer commands and negotiations
  # that are specific to the particular protocol(s) involved.
  # It does not involve the sending of the protocol-
  # specific request that triggers a transfer.
  #
  # @example Get pretransfer_time.
  #   response.pretransfer_time
  # @return [Float] The pretransfer_time.
  def pretransfer_time; end

  # Return the string holding the IP address of the most recent
  # connection done with this curl handle. This string
  # may be IPv6 if that's enabled.
  #
  # @example Get primary_ip.
  #   response.primary_ip
  # @return [String] The primary_ip.
  def primary_ip; end

  # Return the total number of redirections that were
  # actually followed
  #
  # @example Get redirect_count.
  #   response.redirect_count
  # @return [Integer] The redirect_count.
  def redirect_count; end

  # Return the time, in seconds, it took for all redirection steps
  # include name lookup, connect, pretransfer and transfer before the
  # final transaction was started. time_redirect shows the complete
  # execution time for multiple redirections.
  #
  # @example Get redirect_time.
  #   response.redirect_time
  # @return [Float] The redirect_time.
  def redirect_time; end

  # Return all redirections in between as multiple
  # responses with header.
  #
  # @example Return redirections.
  #   response.redirections
  # @return [Array<Typhoeus::Response>] The redirections
  def redirections; end

  def request_size; end

  # Return the http response body.
  #
  # @example Get response_body.
  #   response.response_body
  # @return [String] The response_body.
  def response_body; end

  # Return the last received HTTP, FTP or SMTP response code.
  # The value will be zero if no server response code has
  # been received. Note that a proxy's CONNECT response should
  # be read with http_connect_code and not this.
  #
  # @example Get response_code.
  #   response.response_code
  # @return [Integer] The response_code.
  def response_code; end

  # Return the http response headers.
  #
  # @example Get response_headers.
  #   response.response_headers
  # @return [String] The response_headers.
  def response_headers; end

  # Return libcurls return value.
  #
  # @example Get return_code.
  #   response.return_code
  # @return [Symbol] The return_code.
  def return_code; end

  # Returns a string describing the return.
  #
  # @example Get return_message.
  #   response.return_message
  # @return [String] The return_message.
  # @since 0.6.2
  def return_message; end

  # Return the time, in seconds, it took from the start
  # until the first byte is received by libcurl. This
  # includes pretransfer time and also the time the
  # server needs to calculate the result.
  #
  # @example Get starttransfer_time.
  #   response.starttransfer_time
  # @return [Float] The starttransfer_time.
  def start_transfer_time; end

  # Return the time, in seconds, it took from the start
  # until the first byte is received by libcurl. This
  # includes pretransfer time and also the time the
  # server needs to calculate the result.
  #
  # @example Get starttransfer_time.
  #   response.starttransfer_time
  # @return [Float] The starttransfer_time.
  def starttransfer_time; end

  # Return the total time in seconds for the previous
  # transfer, including name resolving, TCP connect etc.
  #
  # @example Get total_time.
  #   response.total_time
  # @return [Float] The total_time.
  def time; end

  # Return the total time in seconds for the previous
  # transfer, including name resolving, TCP connect etc.
  #
  # @example Get total_time.
  #   response.total_time
  # @return [Float] The total_time.
  def total_time; end
end

# This module contains logic about the http
# status.
module Typhoeus::Response::Status
  # Return whether the response is a failure.
  #
  # @example Return if the response was failed.
  #   response.failure?
  # @return [Boolean] Return true if failure, false else.
  def failure?; end

  # Return the http version.
  #
  # @example Return http version.
  #   response.http_version
  # @return [String] The http version.
  def http_version; end

  # Return wether the response is modified.
  #
  # @example Return if the response was modified.
  #   response.modified?
  # @return [Boolean] Return true if modified, false else.
  def modified?; end

  # Return the status message if present.
  #
  # @example Return status message.
  #   reesponse.status_message
  # @return [String] The message.
  def status_message; end

  # Return whether the response is a success.
  #
  # @example Return if the response was successful.
  #   response.success?
  # @return [Boolean] Return true if successful, false else.
  def success?; end

  # Return whether the response is timed out.
  #
  # @example Return if the response timed out.
  #   response.timed_out?
  # @return [Boolean] Return true if timed out, false else.
  def timed_out?; end

  private

  def first_header_line; end

  # @return [Boolean]
  def has_bad_response_code?; end

  # @return [Boolean]
  def has_good_response_code?; end
end

# The default Typhoeus user agent.
#
# @since 0.5.0
Typhoeus::USER_AGENT = T.let(T.unsafe(nil), String)

# The current Typhoeus version.
Typhoeus::VERSION = T.let(T.unsafe(nil), String)
