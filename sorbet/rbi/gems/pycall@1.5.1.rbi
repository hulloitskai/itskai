# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `pycall` gem.
# Please instead update this file by running `bin/tapioca gem pycall`.

# source://pycall//lib/pycall.rb#1
module PyCall
  private

  def after_fork; end

  # source://pycall//lib/pycall.rb#13
  def builtins; end

  # source://pycall//lib/pycall.rb#17
  def callable?(obj); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#184
  def check_isclass(pyptr); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#179
  def check_ismodule(pyptr); end

  # source://pycall//lib/pycall.rb#66
  def delattr(obj, name); end

  # source://pycall//lib/pycall.rb#28
  def dir(obj); end

  # source://pycall//lib/pycall.rb#39
  def eval(expr, globals: T.unsafe(nil), locals: T.unsafe(nil)); end

  # source://pycall//lib/pycall.rb#44
  def exec(code, globals: T.unsafe(nil), locals: T.unsafe(nil)); end

  # source://pycall//lib/pycall.rb#53
  def getattr(*args); end

  # source://pycall//lib/pycall.rb#58
  def hasattr?(obj, name); end

  # source://pycall//lib/pycall.rb#81
  def import_module(name); end

  # source://pycall//lib/pycall.rb#85
  def iterable(obj); end

  # source://pycall//lib/pycall.rb#89
  def len(obj); end

  # source://pycall//lib/pycall.rb#70
  def same?(left, right); end

  # source://pycall//lib/pycall.rb#62
  def setattr(obj, name, val); end

  # source://pycall//lib/pycall.rb#100
  def sys; end

  # source://pycall//lib/pycall.rb#104
  def tuple(iterable = T.unsafe(nil)); end

  # source://pycall//lib/pycall.rb#113
  def with(ctx); end

  def without_gvl; end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#100
  def wrap_class(pytypeptr); end

  # source://pycall//lib/pycall/pymodule_wrapper.rb#37
  def wrap_module(pymodptr); end

  def wrap_ruby_object(_arg0); end

  class << self
    def after_fork; end

    # source://pycall//lib/pycall.rb#13
    def builtins; end

    # @return [Boolean]
    #
    # source://pycall//lib/pycall.rb#17
    def callable?(obj); end

    # @raise [TypeError]
    #
    # source://pycall//lib/pycall/pyobject_wrapper.rb#184
    def check_isclass(pyptr); end

    # @raise [TypeError]
    #
    # source://pycall//lib/pycall/pyobject_wrapper.rb#179
    def check_ismodule(pyptr); end

    # source://pycall//lib/pycall.rb#66
    def delattr(obj, name); end

    # source://pycall//lib/pycall.rb#28
    def dir(obj); end

    # source://pycall//lib/pycall.rb#39
    def eval(expr, globals: T.unsafe(nil), locals: T.unsafe(nil)); end

    # source://pycall//lib/pycall.rb#44
    def exec(code, globals: T.unsafe(nil), locals: T.unsafe(nil)); end

    # source://pycall//lib/pycall.rb#53
    def getattr(*args); end

    # @return [Boolean]
    #
    # source://pycall//lib/pycall.rb#58
    def hasattr?(obj, name); end

    # source://pycall//lib/pycall.rb#81
    def import_module(name); end

    # source://pycall//lib/pycall/init.rb#24
    def init(python = T.unsafe(nil)); end

    # source://pycall//lib/pycall.rb#85
    def iterable(obj); end

    # source://pycall//lib/pycall.rb#89
    def len(obj); end

    # @return [Boolean]
    #
    # source://pycall//lib/pycall.rb#70
    def same?(left, right); end

    # source://pycall//lib/pycall.rb#62
    def setattr(obj, name, val); end

    # source://pycall//lib/pycall.rb#100
    def sys; end

    # source://pycall//lib/pycall.rb#104
    def tuple(iterable = T.unsafe(nil)); end

    # source://pycall//lib/pycall.rb#113
    def with(ctx); end

    def without_gvl; end

    # source://pycall//lib/pycall/pytypeobject_wrapper.rb#100
    def wrap_class(pytypeptr); end

    # source://pycall//lib/pycall/pymodule_wrapper.rb#37
    def wrap_module(pymodptr); end

    def wrap_ruby_object(_arg0); end
  end
end

module PyCall::Conversion
  private

  def from_ruby(_arg0); end
  def register_python_type_mapping(_arg0, _arg1); end
  def to_ruby(_arg0); end
  def unregister_python_type_mapping(_arg0); end

  class << self
    def from_ruby(_arg0); end
    def register_python_type_mapping(_arg0, _arg1); end
    def to_ruby(_arg0); end
    def unregister_python_type_mapping(_arg0); end
  end
end

# source://pycall//lib/pycall/dict.rb#0
class PyCall::Dict
  include ::PyCall::PyObjectWrapper
  include ::Enumerable
  extend ::PyCall::PyObjectWrapper
  extend ::PyCall::PyTypeObjectWrapper

  # source://pycall//lib/pycall/dict.rb#24
  def [](key); end

  # source://pycall//lib/pycall/dict.rb#30
  def delete(key); end

  # source://pycall//lib/pycall/dict.rb#36
  def each(&block); end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/dict.rb#16
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/dict.rb#16
  def include?(key); end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/dict.rb#16
  def key?(key); end

  # source://pycall//lib/pycall/dict.rb#12
  def length; end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/dict.rb#16
  def member?(key); end

  # source://pycall//lib/pycall/dict.rb#42
  def to_h; end

  class << self
    # source://pycall//lib/pycall/dict.rb#8
    def new(h); end
  end
end

# source://pycall//lib/pycall/error.rb#2
class PyCall::Error < ::StandardError; end

module PyCall::GCGuard; end

# source://pycall//lib/pycall/iterable_wrapper.rb#2
class PyCall::IterableWrapper
  include ::Enumerable

  # @return [IterableWrapper] a new instance of IterableWrapper
  #
  # source://pycall//lib/pycall/iterable_wrapper.rb#5
  def initialize(obj); end

  # source://pycall//lib/pycall/iterable_wrapper.rb#16
  def each; end

  private

  # source://pycall//lib/pycall/iterable_wrapper.rb#9
  def check_iterable(obj); end
end

# source://pycall//lib/pycall/libpython.rb#2
module PyCall::LibPython
  class << self
    # source://pycall//lib/pycall/init.rb#36
    def handle; end
  end
end

module PyCall::LibPython::API
  private

  def PyList_GetItem(_arg0, _arg1); end
  def PyList_Size(_arg0); end
  def PyObject_Dir(_arg0); end
  def builtins_module_ptr; end

  class << self
    def PyList_GetItem(_arg0, _arg1); end
    def PyList_Size(_arg0); end
    def PyObject_Dir(_arg0); end
    def builtins_module_ptr; end
  end
end

PyCall::LibPython::API::None = T.let(T.unsafe(nil), PyCall::PyPtr)
PyCall::LibPython::API::PyBool_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyDict_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyFloat_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyInt_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyList_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyLong_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyModule_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyString_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyType_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)
PyCall::LibPython::API::PyUnicode_Type = T.let(T.unsafe(nil), PyCall::PyTypePtr)

# source://pycall//lib/pycall/libpython/finder.rb#7
module PyCall::LibPython::Finder
  class << self
    # source://pycall//lib/pycall/libpython/finder.rb#69
    def candidate_names(python_config); end

    # @yield []
    #
    # source://pycall//lib/pycall/libpython/finder.rb#99
    def candidate_paths(python_config); end

    # source://pycall//lib/pycall/libpython/finder.rb#40
    def find_libpython(python = T.unsafe(nil)); end

    # @raise [::PyCall::PythonNotFound]
    #
    # source://pycall//lib/pycall/libpython/finder.rb#28
    def find_python_config(python = T.unsafe(nil)); end

    # source://pycall//lib/pycall/libpython/finder.rb#141
    def investigate_python_config(python); end

    # source://pycall//lib/pycall/libpython/finder.rb#165
    def make_libpaths(python_config); end

    # source://pycall//lib/pycall/libpython/finder.rb#119
    def normalize_path(path, suffix, apple_p = T.unsafe(nil)); end

    # source://pycall//lib/pycall/libpython/finder.rb#161
    def python_investigator_py; end

    # Strip off .so or .dylib
    #
    # source://pycall//lib/pycall/libpython/finder.rb#137
    def remove_suffix_apple(path); end

    private

    # @return [Boolean]
    #
    # source://pycall//lib/pycall/libpython/finder.rb#195
    def apple?; end

    # @return [Boolean]
    #
    # source://pycall//lib/pycall/libpython/finder.rb#210
    def debug?; end

    # source://pycall//lib/pycall/libpython/finder.rb#205
    def debug_report(message); end

    # source://pycall//lib/pycall/libpython/finder.rb#199
    def dlopen(libname); end

    # @return [Boolean]
    #
    # source://pycall//lib/pycall/libpython/finder.rb#191
    def windows?; end
  end
end

# source://pycall//lib/pycall/libpython/finder.rb#19
PyCall::LibPython::Finder::LIBPREFIX = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/libpython/finder.rb#20
PyCall::LibPython::Finder::LIBSUFFIX = T.let(T.unsafe(nil), String)

module PyCall::LibPython::Helpers
  private

  def call_object(*_arg0); end
  def callable?(_arg0); end
  def compare(_arg0, _arg1, _arg2); end
  def define_wrapper_method(_arg0, _arg1); end
  def delattr(_arg0, _arg1); end
  def delitem(_arg0, _arg1); end
  def dict_contains(_arg0, _arg1); end
  def dict_each(_arg0); end
  def getattr(*_arg0); end
  def getitem(_arg0, _arg1); end
  def hasattr?(_arg0, _arg1); end
  def import_module(*_arg0); end
  def sequence_contains(_arg0, _arg1); end
  def sequence_each(_arg0); end
  def setattr(_arg0, _arg1, _arg2); end
  def setitem(_arg0, _arg1, _arg2); end
  def str(_arg0); end
  def unicode_literals?; end

  class << self
    def call_object(*_arg0); end
    def callable?(_arg0); end
    def compare(_arg0, _arg1, _arg2); end
    def define_wrapper_method(_arg0, _arg1); end
    def delattr(_arg0, _arg1); end
    def delitem(_arg0, _arg1); end
    def dict_contains(_arg0, _arg1); end
    def dict_each(_arg0); end
    def getattr(*_arg0); end
    def getitem(_arg0, _arg1); end
    def hasattr?(_arg0, _arg1); end
    def import_module(*_arg0); end
    def sequence_contains(_arg0, _arg1); end
    def sequence_each(_arg0); end
    def setattr(_arg0, _arg1, _arg2); end
    def setitem(_arg0, _arg1, _arg2); end
    def str(_arg0); end
    def unicode_literals?; end
  end
end

PyCall::LibPython::PYTHON_DESCRIPTION = T.let(T.unsafe(nil), String)
PyCall::LibPython::PYTHON_VERSION = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/error.rb#8
class PyCall::LibPythonFunctionNotFound < ::PyCall::Error; end

# source://pycall//lib/pycall/list.rb#0
class PyCall::List
  include ::PyCall::PyObjectWrapper
  include ::Enumerable
  extend ::PyCall::PyObjectWrapper
  extend ::PyCall::PyTypeObjectWrapper

  # source://pycall//lib/pycall/list.rb#22
  def <<(item); end

  # source://pycall//lib/pycall/list.rb#16
  def each(&block); end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/list.rb#8
  def include?(item); end

  # source://pycall//lib/pycall/list.rb#12
  def length; end

  # source://pycall//lib/pycall/list.rb#26
  def push(*items); end

  # source://pycall//lib/pycall/list.rb#30
  def sort; end

  # source://pycall//lib/pycall/list.rb#34
  def sort!; end

  # source://pycall//lib/pycall/list.rb#39
  def to_a; end

  # source://pycall//lib/pycall/list.rb#39
  def to_ary; end
end

# source://pycall//lib/pycall/init.rb#47
PyCall::PYTHON_DESCRIPTION = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/init.rb#46
PyCall::PYTHON_VERSION = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/pyerror.rb#4
class PyCall::PyError < ::PyCall::Error
  # @return [PyError] a new instance of PyError
  #
  # source://pycall//lib/pycall/pyerror.rb#5
  def initialize(type, value, traceback); end

  # source://pycall//lib/pycall/pyerror.rb#14
  def to_s; end

  # Returns the value of attribute traceback.
  #
  # source://pycall//lib/pycall/pyerror.rb#12
  def traceback; end

  # Returns the value of attribute type.
  #
  # source://pycall//lib/pycall/pyerror.rb#12
  def type; end

  # Returns the value of attribute value.
  #
  # source://pycall//lib/pycall/pyerror.rb#12
  def value; end

  private

  # source://pycall//lib/pycall/pyerror.rb#25
  def format_traceback; end

  class << self
    def fetch; end
    def occurred?; end
  end
end

# source://pycall//lib/pycall/pymodule_wrapper.rb#4
module PyCall::PyModuleWrapper
  include ::PyCall::PyObjectWrapper

  # source://pycall//lib/pycall/pymodule_wrapper.rb#7
  def [](*args); end
end

# source://pycall//lib/pycall/pyobject_wrapper.rb#4
module PyCall::PyObjectWrapper
  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def !=(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def <(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def <=(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def ==(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def >(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#72
  def >=(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#84
  def [](*key); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#88
  def []=(*key, value); end

  # Returns the value of attribute __pyptr__.
  #
  # source://pycall//lib/pycall/pyobject_wrapper.rb#5
  def __pyptr__; end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#92
  def call(*args); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#148
  def coerce(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#152
  def dup; end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#160
  def inspect; end

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/pyobject_wrapper.rb#60
  def kind_of?(cls); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#35
  def method_missing(name, *args); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#172
  def to_f; end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#168
  def to_i; end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#164
  def to_s; end

  private

  # @return [Boolean]
  #
  # source://pycall//lib/pycall/pyobject_wrapper.rb#55
  def respond_to_missing?(name, include_private); end

  class << self
    # source://pycall//lib/pycall/pyobject_wrapper.rb#7
    def extend_object(obj); end
  end
end

# source://pycall//lib/pycall/pyobject_wrapper.rb#15
PyCall::PyObjectWrapper::OPERATOR_METHOD_NAMES = T.let(T.unsafe(nil), Hash)

# source://pycall//lib/pycall/pyobject_wrapper.rb#96
class PyCall::PyObjectWrapper::SwappedOperationAdapter
  # @return [SwappedOperationAdapter] a new instance of SwappedOperationAdapter
  #
  # source://pycall//lib/pycall/pyobject_wrapper.rb#97
  def initialize(obj); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#119
  def %(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#135
  def &(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#111
  def *(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#123
  def **(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#103
  def +(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#107
  def -(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#115
  def /(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#127
  def <<(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#131
  def >>(other); end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#139
  def ^(other); end

  # Returns the value of attribute obj.
  #
  # source://pycall//lib/pycall/pyobject_wrapper.rb#101
  def obj; end

  # source://pycall//lib/pycall/pyobject_wrapper.rb#143
  def |(other); end
end

class PyCall::PyPtr < ::BasicObject
  def initialize(_arg0); end

  def ==(_arg0); end
  def ===(_arg0); end
  def __address__; end
  def __ob_refcnt__; end
  def __ob_type__; end
  def class; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def is_a?(_arg0); end
  def kind_of?(_arg0); end
  def nil?; end
  def none?; end
  def null?; end
  def object_id; end

  class << self
    def decref(_arg0); end
    def incref(_arg0); end
    def sizeof(_arg0); end
  end
end

PyCall::PyPtr::NULL = T.let(T.unsafe(nil), PyCall::PyPtr)

class PyCall::PyRubyPtr < ::PyCall::PyPtr
  def __ruby_object_id__; end
end

# source://pycall//lib/pycall/pytypeobject_wrapper.rb#4
module PyCall::PyTypeObjectWrapper
  include ::PyCall::PyObjectWrapper

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#52
  def <(other); end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#41
  def ===(other); end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#19
  def inherited(subclass); end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#23
  def new(*args); end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#27
  def wrap_pyptr(pyptr); end

  private

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#73
  def register_python_type_mapping; end

  class << self
    # source://pycall//lib/pycall/pytypeobject_wrapper.rb#7
    def extend_object(cls); end
  end
end

class PyCall::PyTypePtr < ::PyCall::PyPtr
  def <(_arg0); end
  def ===(_arg0); end
  def __ob_size__; end
  def __tp_basicsize__; end
  def __tp_flags__; end
  def __tp_name__; end
end

# source://pycall//lib/pycall/error.rb#5
class PyCall::PythonNotFound < ::PyCall::Error; end

# source://pycall//lib/pycall/slice.rb#0
class PyCall::Slice
  include ::PyCall::PyObjectWrapper
  extend ::PyCall::PyObjectWrapper
  extend ::PyCall::PyTypeObjectWrapper

  class << self
    # source://pycall//lib/pycall/slice.rb#4
    def all; end
  end
end

# source://pycall//lib/pycall/version.rb#2
PyCall::VERSION = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/version.rb#4
module PyCall::Version; end

# source://pycall//lib/pycall/version.rb#6
PyCall::Version::MAJOR = T.let(T.unsafe(nil), Integer)

# source://pycall//lib/pycall/version.rb#6
PyCall::Version::MICRO = T.let(T.unsafe(nil), Integer)

# source://pycall//lib/pycall/version.rb#6
PyCall::Version::MINOR = T.let(T.unsafe(nil), Integer)

# source://pycall//lib/pycall/version.rb#7
PyCall::Version::STRING = T.let(T.unsafe(nil), String)

# source://pycall//lib/pycall/version.rb#5
PyCall::Version::TAG = T.let(T.unsafe(nil), T.untyped)

# source://pycall//lib/pycall/pytypeobject_wrapper.rb#80
class PyCall::WrapperClassCache < ::PyCall::WrapperObjectCache
  # @return [WrapperClassCache] a new instance of WrapperClassCache
  #
  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#81
  def initialize; end

  # source://pycall//lib/pycall/pytypeobject_wrapper.rb#87
  def check_wrapper_object(wrapper_object); end

  class << self
    # source://pycall//lib/pycall/pytypeobject_wrapper.rb#93
    def instance; end
  end
end

# source://pycall//lib/pycall/pymodule_wrapper.rb#19
class PyCall::WrapperModuleCache < ::PyCall::WrapperObjectCache
  # @return [WrapperModuleCache] a new instance of WrapperModuleCache
  #
  # source://pycall//lib/pycall/pymodule_wrapper.rb#20
  def initialize; end

  # source://pycall//lib/pycall/pymodule_wrapper.rb#24
  def check_wrapper_object(wrapper_object); end

  class << self
    # source://pycall//lib/pycall/pymodule_wrapper.rb#30
    def instance; end
  end
end

# source://pycall//lib/pycall/wrapper_object_cache.rb#2
class PyCall::WrapperObjectCache
  # @return [WrapperObjectCache] a new instance of WrapperObjectCache
  #
  # source://pycall//lib/pycall/wrapper_object_cache.rb#52
  def initialize(*restricted_pytypes); end

  # source://pycall//lib/pycall/wrapper_object_cache.rb#86
  def check_wrapper_object(wrapper_object); end

  # source://pycall//lib/pycall/wrapper_object_cache.rb#63
  def lookup(pyptr); end

  class << self
    # source://pycall//lib/pycall/wrapper_object_cache.rb#18
    def get_key(pyptr); end
  end
end

# source://pycall//lib/pycall/wrapper_object_cache.rb#13
PyCall::WrapperObjectCache::WMAP_SUPPORT_INT_KEY = T.let(T.unsafe(nil), TrueClass)
