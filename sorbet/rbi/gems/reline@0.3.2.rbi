# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reline` gem.
# Please instead update this file by running `bin/tapioca gem reline`.

module Reline
  extend ::Forwardable
  extend ::SingleForwardable

  class << self
    # source://reline//reline.rb#557
    def core; end

    # source://reline//reline.rb#553
    def encoding_system_needs; end

    # source://reline//reline.rb#534
    def insert_text(*args, &block); end

    # source://reline//reline.rb#577
    def line_editor; end

    # source://reline//reline.rb#573
    def ungetc(c); end
  end
end

class Reline::ANSI
  class << self
    # source://reline//reline/ansi.rb#332
    def clear_screen; end

    # source://reline//reline/ansi.rb#244
    def cursor_pos; end

    # source://reline//reline/ansi.rb#347
    def deprep(otio); end

    # @return [Boolean]
    #
    # source://reline//reline/ansi.rb#205
    def empty_buffer?; end

    # source://reline//reline/ansi.rb#24
    def encoding; end

    # source://reline//reline/ansi.rb#323
    def erase_after_cursor; end

    # source://reline//reline/ansi.rb#227
    def get_screen_size; end

    # source://reline//reline/ansi.rb#193
    def getc; end

    # source://reline//reline/ansi.rb#164
    def getc_with_bracketed_paste; end

    # source://reline//reline/ansi.rb#299
    def hide_cursor; end

    # @return [Boolean]
    #
    # source://reline//reline/ansi.rb#201
    def in_pasting?; end

    # source://reline//reline/ansi.rb#146
    def inner_getc; end

    # source://reline//reline/ansi.rb#136
    def input=(val); end

    # source://reline//reline/ansi.rb#279
    def move_cursor_column(x); end

    # source://reline//reline/ansi.rb#291
    def move_cursor_down(x); end

    # source://reline//reline/ansi.rb#283
    def move_cursor_up(x); end

    # source://reline//reline/ansi.rb#141
    def output=(val); end

    # source://reline//reline/ansi.rb#342
    def prep; end

    # source://reline//reline/ansi.rb#216
    def retrieve_keybuffer; end

    # source://reline//reline/ansi.rb#327
    def scroll_down(x); end

    # source://reline//reline/ansi.rb#32
    def set_default_key_bindings(config); end

    # source://reline//reline/ansi.rb#88
    def set_default_key_bindings_comprehensive_list(config); end

    # source://reline//reline/ansi.rb#64
    def set_default_key_bindings_terminfo(config); end

    # source://reline//reline/ansi.rb#237
    def set_screen_size(rows, columns); end

    # source://reline//reline/ansi.rb#338
    def set_winch_handler(&handler); end

    # source://reline//reline/ansi.rb#311
    def show_cursor; end

    # source://reline//reline/ansi.rb#212
    def ungetc(c); end

    # @return [Boolean]
    #
    # source://reline//reline/ansi.rb#28
    def win?; end
  end
end

# source://reline//reline/ansi.rb#7
Reline::ANSI::CAPNAME_KEY_BINDINGS = T.let(T.unsafe(nil), Hash)

# source://reline//reline/ansi.rb#163
Reline::ANSI::END_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

# source://reline//reline/ansi.rb#162
Reline::ANSI::START_BRACKETED_PASTE = T.let(T.unsafe(nil), String)

class Reline::Config
  # @return [Config] a new instance of Config
  #
  # source://reline//reline/config.rb#50
  def initialize; end

  # source://reline//reline/config.rb#172
  def add_default_key_binding(keystroke, target); end

  # source://reline//reline/config.rb#168
  def add_default_key_binding_by_keymap(keymap, keystroke, target); end

  # source://reline//reline/config.rb#160
  def add_oneshot_key_binding(keystroke, target); end

  # Returns the value of attribute autocompletion.
  #
  # source://reline//reline/config.rb#48
  def autocompletion; end

  # Sets the attribute autocompletion
  #
  # @param value the value to set the attribute autocompletion to.
  #
  # source://reline//reline/config.rb#48
  def autocompletion=(_arg0); end

  # source://reline//reline/config.rb#342
  def bind_key(key, func_name); end

  # source://reline//reline/config.rb#45
  def bind_tty_special_chars; end

  # source://reline//reline/config.rb#45
  def bind_tty_special_chars=(_arg0); end

  # source://reline//reline/config.rb#259
  def bind_variable(name, value); end

  # source://reline//reline/config.rb#45
  def blink_matching_paren; end

  # source://reline//reline/config.rb#45
  def blink_matching_paren=(_arg0); end

  # source://reline//reline/config.rb#45
  def byte_oriented; end

  # source://reline//reline/config.rb#45
  def byte_oriented=(_arg0); end

  # source://reline//reline/config.rb#45
  def completion_ignore_case; end

  # source://reline//reline/config.rb#45
  def completion_ignore_case=(_arg0); end

  # source://reline//reline/config.rb#45
  def convert_meta; end

  # source://reline//reline/config.rb#45
  def convert_meta=(_arg0); end

  # source://reline//reline/config.rb#45
  def disable_completion; end

  # source://reline//reline/config.rb#45
  def disable_completion=(_arg0); end

  # source://reline//reline/config.rb#87
  def editing_mode; end

  # source://reline//reline/config.rb#91
  def editing_mode=(val); end

  # @return [Boolean]
  #
  # source://reline//reline/config.rb#95
  def editing_mode_is?(*val); end

  # source://reline//reline/config.rb#45
  def emacs_mode_string; end

  # source://reline//reline/config.rb#45
  def emacs_mode_string=(_arg0); end

  # source://reline//reline/config.rb#45
  def enable_bracketed_paste; end

  # source://reline//reline/config.rb#45
  def enable_bracketed_paste=(_arg0); end

  # source://reline//reline/config.rb#45
  def enable_keypad; end

  # source://reline//reline/config.rb#45
  def enable_keypad=(_arg0); end

  # source://reline//reline/config.rb#45
  def expand_tilde; end

  # source://reline//reline/config.rb#45
  def expand_tilde=(_arg0); end

  # source://reline//reline/config.rb#229
  def handle_directive(directive, file, no); end

  # source://reline//reline/config.rb#45
  def history_preserve_point; end

  # source://reline//reline/config.rb#45
  def history_preserve_point=(_arg0); end

  # source://reline//reline/config.rb#45
  def history_size; end

  # source://reline//reline/config.rb#45
  def history_size=(_arg0); end

  # source://reline//reline/config.rb#45
  def horizontal_scroll_mode; end

  # source://reline//reline/config.rb#45
  def horizontal_scroll_mode=(_arg0); end

  # source://reline//reline/config.rb#45
  def input_meta; end

  # source://reline//reline/config.rb#45
  def input_meta=(_arg0); end

  # source://reline//reline/config.rb#103
  def inputrc_path; end

  # source://reline//reline/config.rb#45
  def isearch_terminators; end

  # source://reline//reline/config.rb#45
  def isearch_terminators=(_arg0); end

  # source://reline//reline/config.rb#152
  def key_bindings; end

  # source://reline//reline/config.rb#356
  def key_notation_to_code(notation); end

  # source://reline//reline/config.rb#99
  def keymap; end

  # source://reline//reline/config.rb#45
  def keyseq_timeout; end

  # source://reline//reline/config.rb#45
  def keyseq_timeout=(_arg0); end

  # source://reline//reline/config.rb#45
  def mark_directories; end

  # source://reline//reline/config.rb#45
  def mark_directories=(_arg0); end

  # source://reline//reline/config.rb#45
  def mark_modified_lines; end

  # source://reline//reline/config.rb#45
  def mark_modified_lines=(_arg0); end

  # source://reline//reline/config.rb#45
  def mark_symlinked_directories; end

  # source://reline//reline/config.rb#45
  def mark_symlinked_directories=(_arg0); end

  # source://reline//reline/config.rb#45
  def match_hidden_files; end

  # source://reline//reline/config.rb#45
  def match_hidden_files=(_arg0); end

  # source://reline//reline/config.rb#45
  def meta_flag; end

  # source://reline//reline/config.rb#45
  def meta_flag=(_arg0); end

  # source://reline//reline/config.rb#45
  def output_meta; end

  # source://reline//reline/config.rb#45
  def output_meta=(_arg0); end

  # source://reline//reline/config.rb#45
  def page_completions; end

  # source://reline//reline/config.rb#45
  def page_completions=(_arg0); end

  # source://reline//reline/config.rb#390
  def parse_keyseq(str); end

  # source://reline//reline/config.rb#45
  def prefer_visible_bell; end

  # source://reline//reline/config.rb#45
  def prefer_visible_bell=(_arg0); end

  # source://reline//reline/config.rb#45
  def print_completions_horizontally; end

  # source://reline//reline/config.rb#45
  def print_completions_horizontally=(_arg0); end

  # source://reline//reline/config.rb#133
  def read(file = T.unsafe(nil)); end

  # source://reline//reline/config.rb#182
  def read_lines(lines, file = T.unsafe(nil)); end

  # source://reline//reline/config.rb#76
  def reset; end

  # source://reline//reline/config.rb#176
  def reset_default_key_bindings; end

  # source://reline//reline/config.rb#164
  def reset_oneshot_key_bindings; end

  # source://reline//reline/config.rb#337
  def retrieve_string(str); end

  # source://reline//reline/config.rb#45
  def show_all_if_ambiguous; end

  # source://reline//reline/config.rb#45
  def show_all_if_ambiguous=(_arg0); end

  # source://reline//reline/config.rb#45
  def show_all_if_unmodified; end

  # source://reline//reline/config.rb#45
  def show_all_if_unmodified=(_arg0); end

  # source://reline//reline/config.rb#45
  def show_mode_in_prompt; end

  # source://reline//reline/config.rb#45
  def show_mode_in_prompt=(_arg0); end

  # Returns the value of attribute test_mode.
  #
  # source://reline//reline/config.rb#2
  def test_mode; end

  # source://reline//reline/config.rb#45
  def vi_cmd_mode_string; end

  # source://reline//reline/config.rb#45
  def vi_cmd_mode_string=(_arg0); end

  # source://reline//reline/config.rb#45
  def vi_ins_mode_string; end

  # source://reline//reline/config.rb#45
  def vi_ins_mode_string=(_arg0); end

  # source://reline//reline/config.rb#45
  def visible_stats; end

  # source://reline//reline/config.rb#45
  def visible_stats=(_arg0); end

  private

  # source://reline//reline/config.rb#129
  def default_inputrc_path; end

  # @return [Boolean]
  #
  # source://reline//reline/config.rb#398
  def seven_bit_encoding?(encoding); end
end

class Reline::Config::InvalidInputrc < ::RuntimeError
  # Returns the value of attribute file.
  #
  # source://reline//reline/config.rb#7
  def file; end

  # Sets the attribute file
  #
  # @param value the value to set the attribute file to.
  #
  # source://reline//reline/config.rb#7
  def file=(_arg0); end

  # Returns the value of attribute lineno.
  #
  # source://reline//reline/config.rb#7
  def lineno; end

  # Sets the attribute lineno
  #
  # @param value the value to set the attribute lineno to.
  #
  # source://reline//reline/config.rb#7
  def lineno=(_arg0); end
end

# source://reline//reline/config.rb#4
Reline::Config::KEYSEQ_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/config.rb#10
Reline::Config::VARIABLE_NAMES = T.let(T.unsafe(nil), Array)

# source://reline//reline/config.rb#43
Reline::Config::VARIABLE_NAME_SYMBOLS = T.let(T.unsafe(nil), Array)

class Reline::Core
  extend ::Forwardable

  # @return [Core] a new instance of Core
  # @yield [_self]
  # @yieldparam _self [Reline::Core] the object that the method was called on
  #
  # source://reline//reline.rb#77
  def initialize; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#167
  def add_dialog_proc(name_sym, p, context = T.unsafe(nil)); end

  # source://reline//reline.rb#480
  def ambiguous_width; end

  # source://reline//reline.rb#64
  def auto_indent_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#152
  def auto_indent_proc=(p); end

  # source://reline//reline.rb#64
  def basic_quote_characters; end

  # source://reline//reline.rb#109
  def basic_quote_characters=(v); end

  # source://reline//reline.rb#64
  def basic_word_break_characters; end

  # source://reline//reline.rb#101
  def basic_word_break_characters=(v); end

  # source://reline//reline.rb#64
  def completer_quote_characters; end

  # source://reline//reline.rb#113
  def completer_quote_characters=(v); end

  # source://reline//reline.rb#64
  def completer_word_break_characters; end

  # source://reline//reline.rb#105
  def completer_word_break_characters=(v); end

  # source://reline//reline.rb#64
  def completion_append_character; end

  # source://reline//reline.rb#89
  def completion_append_character=(val); end

  # source://reline//reline.rb#129
  def completion_case_fold; end

  # source://reline//reline.rb#125
  def completion_case_fold=(v); end

  # source://reline//reline.rb#64
  def completion_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#137
  def completion_proc=(p); end

  # source://reline//reline.rb#133
  def completion_quote_character; end

  # Returns the value of attribute config.
  #
  # source://reline//reline.rb#66
  def config; end

  # Sets the attribute config
  #
  # @param value the value to set the attribute config to.
  #
  # source://reline//reline.rb#66
  def config=(_arg0); end

  # source://reline//reline.rb#173
  def dialog_proc(name_sym); end

  # source://reline//reline.rb#64
  def dig_perfect_match_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#161
  def dig_perfect_match_proc=(p); end

  # source://reline//reline.rb#201
  def emacs_editing_mode; end

  # @return [Boolean]
  #
  # source://reline//reline.rb#210
  def emacs_editing_mode?; end

  # source://reline//reline.rb#85
  def encoding; end

  # source://reline//reline.rb#64
  def filename_quote_characters; end

  # source://reline//reline.rb#117
  def filename_quote_characters=(v); end

  # source://reline//reline.rb#214
  def get_screen_size; end

  # @raise [TypeError]
  #
  # source://reline//reline.rb#177
  def input=(val); end

  # Returns the value of attribute key_stroke.
  #
  # source://reline//reline.rb#67
  def key_stroke; end

  # Sets the attribute key_stroke
  #
  # @param value the value to set the attribute key_stroke to.
  #
  # source://reline//reline.rb#67
  def key_stroke=(_arg0); end

  # Returns the value of attribute last_incremental_search.
  #
  # source://reline//reline.rb#69
  def last_incremental_search; end

  # Sets the attribute last_incremental_search
  #
  # @param value the value to set the attribute last_incremental_search to.
  #
  # source://reline//reline.rb#69
  def last_incremental_search=(_arg0); end

  # Returns the value of attribute line_editor.
  #
  # source://reline//reline.rb#68
  def line_editor; end

  # Sets the attribute line_editor
  #
  # @param value the value to set the attribute line_editor to.
  #
  # source://reline//reline.rb#68
  def line_editor=(_arg0); end

  # Returns the value of attribute output.
  #
  # source://reline//reline.rb#70
  def output; end

  # @raise [TypeError]
  #
  # source://reline//reline.rb#188
  def output=(val); end

  # source://reline//reline.rb#64
  def output_modifier_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#142
  def output_modifier_proc=(p); end

  # source://reline//reline.rb#64
  def pre_input_hook; end

  # source://reline//reline.rb#157
  def pre_input_hook=(p); end

  # source://reline//reline.rb#64
  def prompt_proc; end

  # @raise [ArgumentError]
  #
  # source://reline//reline.rb#147
  def prompt_proc=(p); end

  # source://reline//reline.rb#283
  def readline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil)); end

  # source://reline//reline.rb#267
  def readmultiline(prompt = T.unsafe(nil), add_hist = T.unsafe(nil), &confirm_multiline_termination); end

  # source://reline//reline.rb#64
  def special_prefixes; end

  # source://reline//reline.rb#121
  def special_prefixes=(v); end

  # source://reline//reline.rb#196
  def vi_editing_mode; end

  # @return [Boolean]
  #
  # source://reline//reline.rb#206
  def vi_editing_mode?; end

  private

  # source://reline//reline.rb#296
  def inner_readline(prompt, add_hist, multiline, &confirm_multiline_termination); end

  # source://reline//reline.rb#485
  def may_req_ambiguous_char_width; end

  # source://reline//reline.rb#427
  def read_2nd_character_of_key_sequence(keyseq_timeout, buffer, c, block); end

  # source://reline//reline.rb#459
  def read_escaped_key(keyseq_timeout, c, block); end

  # GNU Readline waits for "keyseq-timeout" milliseconds to see if the ESC
  # is followed by a character, and times out and treats it as a standalone
  # ESC if the second character does not arrive. If the second character
  # comes before timed out, it is treated as a modifier key with the
  # meta-property of meta-key, so that it can be distinguished from
  # multibyte characters with the 8th bit turned on.
  #
  # GNU Readline will wait for the 2nd character with "keyseq-timeout"
  # milli-seconds but wait forever after 3rd characters.
  #
  # source://reline//reline.rb#388
  def read_io(keyseq_timeout, &block); end
end

# source://reline//reline.rb#50
Reline::Core::ATTR_READER_NAMES = T.let(T.unsafe(nil), Array)

# source://reline//reline.rb#265
Reline::DEFAULT_DIALOG_CONTEXT = T.let(T.unsafe(nil), Array)

# source://reline//reline.rb#218
Reline::DEFAULT_DIALOG_PROC_AUTOCOMPLETE = T.let(T.unsafe(nil), Proc)

# source://reline//reline.rb#14
Reline::FILENAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

class Reline::GeneralIO
  class << self
    # source://reline//reline/general_io.rb#81
    def clear_screen; end

    # source://reline//reline/general_io.rb#56
    def cursor_pos; end

    # source://reline//reline/general_io.rb#107
    def deprep(otio); end

    # source://reline//reline/general_io.rb#10
    def encoding; end

    # source://reline//reline/general_io.rb#75
    def erase_after_cursor; end

    # source://reline//reline/general_io.rb#100
    def finish_pasting; end

    # source://reline//reline/general_io.rb#52
    def get_screen_size; end

    # source://reline//reline/general_io.rb#34
    def getc; end

    # source://reline//reline/general_io.rb#60
    def hide_cursor; end

    # @return [Boolean]
    #
    # source://reline//reline/general_io.rb#92
    def in_pasting?; end

    # source://reline//reline/general_io.rb#30
    def input=(val); end

    # source://reline//reline/general_io.rb#66
    def move_cursor_column(val); end

    # source://reline//reline/general_io.rb#72
    def move_cursor_down(val); end

    # source://reline//reline/general_io.rb#69
    def move_cursor_up(val); end

    # source://reline//reline/general_io.rb#104
    def prep; end

    # source://reline//reline/general_io.rb#5
    def reset(encoding: T.unsafe(nil)); end

    # source://reline//reline/general_io.rb#78
    def scroll_down(val); end

    # source://reline//reline/general_io.rb#24
    def set_default_key_bindings(_); end

    # source://reline//reline/general_io.rb#84
    def set_screen_size(rows, columns); end

    # source://reline//reline/general_io.rb#87
    def set_winch_handler(&handler); end

    # source://reline//reline/general_io.rb#63
    def show_cursor; end

    # source://reline//reline/general_io.rb#96
    def start_pasting; end

    # source://reline//reline/general_io.rb#48
    def ungetc(c); end

    # @return [Boolean]
    #
    # source://reline//reline/general_io.rb#20
    def win?; end
  end
end

# source://reline//reline.rb#600
Reline::HISTORY = T.let(T.unsafe(nil), Reline::History)

class Reline::History < ::Array
  # @return [History] a new instance of History
  #
  # source://reline//reline/history.rb#2
  def initialize(config); end

  # source://reline//reline/history.rb#52
  def <<(val); end

  # source://reline//reline/history.rb#15
  def [](index); end

  # source://reline//reline/history.rb#20
  def []=(index, val); end

  # source://reline//reline/history.rb#25
  def concat(*val); end

  # source://reline//reline/history.rb#10
  def delete_at(index); end

  # source://reline//reline/history.rb#31
  def push(*val); end

  # source://reline//reline/history.rb#6
  def to_s; end

  private

  # @raise [IndexError]
  #
  # source://reline//reline/history.rb#62
  def check_index(index); end
end

# source://reline//reline.rb#593
Reline::IOGate = Reline::ANSI

# source://reline//reline.rb#19
Reline::Key = Struct

class Reline::KeyActor::Base
  # @return [Base] a new instance of Base
  #
  # source://reline//reline/key_actor/base.rb#8
  def initialize; end

  # source://reline//reline/key_actor/base.rb#12
  def default_key_bindings; end

  # source://reline//reline/key_actor/base.rb#4
  def get_method(key); end

  # source://reline//reline/key_actor/base.rb#16
  def reset_default_key_bindings; end
end

# source://reline//reline/key_actor/base.rb#2
Reline::KeyActor::Base::MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//reline/key_actor/emacs.rb#2
Reline::KeyActor::Emacs::MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//reline/key_actor/vi_command.rb#2
Reline::KeyActor::ViCommand::MAPPING = T.let(T.unsafe(nil), Array)

# source://reline//reline/key_actor/vi_insert.rb#2
Reline::KeyActor::ViInsert::MAPPING = T.let(T.unsafe(nil), Array)

class Reline::KeyStroke
  # @return [KeyStroke] a new instance of KeyStroke
  #
  # source://reline//reline/key_stroke.rb#2
  def initialize(config); end

  # source://reline//reline/key_stroke.rb#6
  def compress_meta_key(ary); end

  # @return [Boolean]
  #
  # source://reline//reline/key_stroke.rb#42
  def equal?(me, other); end

  # source://reline//reline/key_stroke.rb#83
  def expand(input); end

  # source://reline//reline/key_stroke.rb#67
  def match_status(input); end

  # @return [Boolean]
  #
  # source://reline//reline/key_stroke.rb#18
  def start_with?(me, other); end

  private

  # source://reline//reline/key_stroke.rb#102
  def key_mapping; end
end

class Reline::KillRing
  include ::Enumerable

  # @return [KillRing] a new instance of KillRing
  #
  # source://reline//reline/kill_ring.rb#61
  def initialize(max = T.unsafe(nil)); end

  # source://reline//reline/kill_ring.rb#68
  def append(string, before_p = T.unsafe(nil)); end

  # source://reline//reline/kill_ring.rb#116
  def each; end

  # source://reline//reline/kill_ring.rb#83
  def process; end

  # source://reline//reline/kill_ring.rb#96
  def yank; end

  # source://reline//reline/kill_ring.rb#106
  def yank_pop; end
end

class Reline::KillRing::RingBuffer
  # @return [RingBuffer] a new instance of RingBuffer
  #
  # source://reline//reline/kill_ring.rb#25
  def initialize(max = T.unsafe(nil)); end

  # source://reline//reline/kill_ring.rb#31
  def <<(point); end

  # @return [Boolean]
  #
  # source://reline//reline/kill_ring.rb#56
  def empty?; end

  # Returns the value of attribute head.
  #
  # source://reline//reline/kill_ring.rb#23
  def head; end

  # Returns the value of attribute size.
  #
  # source://reline//reline/kill_ring.rb#22
  def size; end
end

class Reline::KillRing::RingPoint < ::Struct
  # @return [RingPoint] a new instance of RingPoint
  #
  # source://reline//reline/kill_ring.rb#12
  def initialize(str); end

  # source://reline//reline/kill_ring.rb#16
  def ==(other); end
end

# source://reline//reline/kill_ring.rb#6
Reline::KillRing::State::CONTINUED = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/kill_ring.rb#5
Reline::KillRing::State::FRESH = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/kill_ring.rb#7
Reline::KillRing::State::PROCESSED = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/kill_ring.rb#8
Reline::KillRing::State::YANK = T.let(T.unsafe(nil), Symbol)

class Reline::LineEditor
  # @return [LineEditor] a new instance of LineEditor
  #
  # source://reline//reline/line_editor.rb#56
  def initialize(config, encoding); end

  # source://reline//reline/line_editor.rb#641
  def add_dialog_proc(name, p, context = T.unsafe(nil)); end

  # Returns the value of attribute auto_indent_proc.
  #
  # source://reline//reline/line_editor.rb#16
  def auto_indent_proc; end

  # Sets the attribute auto_indent_proc
  #
  # @param value the value to set the attribute auto_indent_proc to.
  #
  # source://reline//reline/line_editor.rb#16
  def auto_indent_proc=(_arg0); end

  # Returns the value of attribute byte_pointer.
  #
  # source://reline//reline/line_editor.rb#10
  def byte_pointer; end

  # source://reline//reline/line_editor.rb#1903
  def byte_pointer=(val); end

  # source://reline//reline/line_editor.rb#1667
  def call_completion_proc; end

  # source://reline//reline/line_editor.rb#1675
  def call_completion_proc_with_checking_args(pre, target, post); end

  # Returns the value of attribute completion_append_character.
  #
  # source://reline//reline/line_editor.rb#13
  def completion_append_character; end

  # Sets the attribute completion_append_character
  #
  # @param value the value to set the attribute completion_append_character to.
  #
  # source://reline//reline/line_editor.rb#13
  def completion_append_character=(_arg0); end

  # Returns the value of attribute completion_proc.
  #
  # source://reline//reline/line_editor.rb#12
  def completion_proc; end

  # Sets the attribute completion_proc
  #
  # @param value the value to set the attribute completion_proc to.
  #
  # source://reline//reline/line_editor.rb#12
  def completion_proc=(_arg0); end

  # source://reline//reline/line_editor.rb#1821
  def confirm_multiline_termination; end

  # Returns the value of attribute confirm_multiline_termination_proc.
  #
  # source://reline//reline/line_editor.rb#11
  def confirm_multiline_termination_proc; end

  # Sets the attribute confirm_multiline_termination_proc
  #
  # @param value the value to set the attribute confirm_multiline_termination_proc to.
  #
  # source://reline//reline/line_editor.rb#11
  def confirm_multiline_termination_proc=(_arg0); end

  # source://reline//reline/line_editor.rb#1843
  def delete_text(start = T.unsafe(nil), length = T.unsafe(nil)); end

  # Returns the value of attribute dig_perfect_match_proc.
  #
  # source://reline//reline/line_editor.rb#18
  def dig_perfect_match_proc; end

  # Sets the attribute dig_perfect_match_proc
  #
  # @param value the value to set the attribute dig_perfect_match_proc to.
  #
  # source://reline//reline/line_editor.rb#18
  def dig_perfect_match_proc=(_arg0); end

  # source://reline//reline/line_editor.rb#1285
  def editing_mode; end

  # @return [Boolean]
  #
  # source://reline//reline/line_editor.rb#258
  def eof?; end

  # source://reline//reline/line_editor.rb#250
  def finalize; end

  # source://reline//reline/line_editor.rb#1932
  def finish; end

  # @return [Boolean]
  #
  # source://reline//reline/line_editor.rb#1928
  def finished?; end

  # source://reline//reline/line_editor.rb#1592
  def input_key(key); end

  # source://reline//reline/line_editor.rb#1831
  def insert_text(text); end

  # source://reline//reline/line_editor.rb#983
  def just_move_cursor; end

  # TODO: undo
  # TODO: Use "private alias_method" idiom after drop Ruby 2.5.
  #
  # source://reline//reline/line_editor.rb#9
  def line; end

  # source://reline//reline/line_editor.rb#323
  def multiline_off; end

  # source://reline//reline/line_editor.rb#319
  def multiline_on; end

  # Sets the attribute output
  #
  # @param value the value to set the attribute output to.
  #
  # source://reline//reline/line_editor.rb#19
  def output=(_arg0); end

  # Returns the value of attribute output_modifier_proc.
  #
  # source://reline//reline/line_editor.rb#14
  def output_modifier_proc; end

  # Sets the attribute output_modifier_proc
  #
  # @param value the value to set the attribute output_modifier_proc to.
  #
  # source://reline//reline/line_editor.rb#14
  def output_modifier_proc=(_arg0); end

  # Returns the value of attribute pre_input_hook.
  #
  # source://reline//reline/line_editor.rb#17
  def pre_input_hook; end

  # Sets the attribute pre_input_hook
  #
  # @param value the value to set the attribute pre_input_hook to.
  #
  # source://reline//reline/line_editor.rb#17
  def pre_input_hook=(_arg0); end

  # Returns the value of attribute prompt_proc.
  #
  # source://reline//reline/line_editor.rb#15
  def prompt_proc; end

  # Sets the attribute prompt_proc
  #
  # @param value the value to set the attribute prompt_proc to.
  #
  # source://reline//reline/line_editor.rb#15
  def prompt_proc=(_arg0); end

  # source://reline//reline/line_editor.rb#431
  def rerender; end

  # source://reline//reline/line_editor.rb#425
  def rerender_all; end

  # source://reline//reline/line_editor.rb#149
  def reset(prompt = T.unsafe(nil), encoding:); end

  # source://reline//reline/line_editor.rb#301
  def reset_line; end

  # source://reline//reline/line_editor.rb#262
  def reset_variables(prompt = T.unsafe(nil), encoding:); end

  # source://reline//reline/line_editor.rb#180
  def resize; end

  # source://reline//reline/line_editor.rb#1739
  def retrieve_completion_block(set_completion_quote_character = T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#62
  def set_pasting_state(in_pasting); end

  # source://reline//reline/line_editor.rb#220
  def set_signal_handlers; end

  # @return [Boolean]
  #
  # source://reline//reline/line_editor.rb#66
  def simplified_rendering?; end

  # source://reline//reline/line_editor.rb#1916
  def whole_buffer; end

  # source://reline//reline/line_editor.rb#1910
  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1477
  def wrap_method_call(method_symbol, method_obj, key, with_operator = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://reline//reline/line_editor.rb#1467
  def argumentable?(method_obj); end

  # source://reline//reline/line_editor.rb#2095
  def backward_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2585
  def backward_delete_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2744
  def backward_word(key); end

  # source://reline//reline/line_editor.rb#2119
  def beginning_of_line(key); end

  # source://reline//reline/line_editor.rb#1944
  def byteinsert(str, byte_pointer, other); end

  # source://reline//reline/line_editor.rb#1938
  def byteslice!(str, byte_pointer, size); end

  # source://reline//reline/line_editor.rb#327
  def calculate_height_by_lines(lines, prompt); end

  # source://reline//reline/line_editor.rb#345
  def calculate_height_by_width(width); end

  # source://reline//reline/line_editor.rb#383
  def calculate_nearest_cursor(line_to_calc = T.unsafe(nil), cursor = T.unsafe(nil), started_from = T.unsafe(nil), byte_pointer = T.unsafe(nil), update = T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#934
  def calculate_scroll_partial_screen(highest_in_all, cursor_y); end

  # source://reline//reline/line_editor.rb#1951
  def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2808
  def capitalize_word(key); end

  # source://reline//reline/line_editor.rb#76
  def check_mode_string; end

  # source://reline//reline/line_editor.rb#96
  def check_multiline_prompt(buffer); end

  # source://reline//reline/line_editor.rb#882
  def clear_dialog; end

  # source://reline//reline/line_editor.rb#888
  def clear_dialog_with_content; end

  # source://reline//reline/line_editor.rb#896
  def clear_each_dialog(dialog); end

  # source://reline//reline/line_editor.rb#2730
  def clear_screen(key); end

  # source://reline//reline/line_editor.rb#1264
  def clear_screen_buffer(prompt, prompt_list, prompt_width); end

  # source://reline//reline/line_editor.rb#1339
  def complete(list, just_show_list = T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1293
  def complete_internal_proc(list, is_menu); end

  # source://reline//reline/line_editor.rb#2864
  def copy_for_vi(text); end

  # source://reline//reline/line_editor.rb#2662
  def delete_char(key); end

  # source://reline//reline/line_editor.rb#2689
  def delete_char_or_list(key); end

  # source://reline//reline/line_editor.rb#2820
  def downcase_word(key); end

  # source://reline//reline/line_editor.rb#3163
  def ed_argument_digit(key); end

  # source://reline//reline/line_editor.rb#2730
  def ed_clear_screen(key); end

  # source://reline//reline/line_editor.rb#3075
  def ed_delete_next_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2993
  def ed_delete_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2762
  def ed_delete_prev_word(key); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//reline/line_editor.rb#2006
  def ed_digit(key); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//reline/line_editor.rb#2006
  def ed_insert(key); end

  # Editline:: +ed-kill-line+ (vi command: +D+, +Ctrl-K+; emacs: +Ctrl-K+,
  #            +Ctrl-U+) + Kill from the cursor to the end of the line.
  # GNU Readline:: +kill-line+ (+C-k+) Kill the text from point to the end of
  #                the line. With a negative numeric argument, kill backward
  #                from the cursor to the beginning of the current line.
  #
  # source://reline//reline/line_editor.rb#2613
  def ed_kill_line(key); end

  # source://reline//reline/line_editor.rb#2119
  def ed_move_to_beg(key); end

  # source://reline//reline/line_editor.rb#2124
  def ed_move_to_end(key); end

  # source://reline//reline/line_editor.rb#2552
  def ed_newline(key); end

  # source://reline//reline/line_editor.rb#2075
  def ed_next_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2504
  def ed_next_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2095
  def ed_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2453
  def ed_prev_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2744
  def ed_prev_word(key); end

  # source://reline//reline/line_editor.rb#2059
  def ed_quoted_insert(str, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2401
  def ed_search_next_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2354
  def ed_search_prev_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2773
  def ed_transpose_chars(key); end

  # source://reline//reline/line_editor.rb#2793
  def ed_transpose_words(key); end

  # do nothing
  #
  # source://reline//reline/line_editor.rb#1976
  def ed_unassigned(key); end

  # source://reline//reline/line_editor.rb#2808
  def em_capitol_case(key); end

  # source://reline//reline/line_editor.rb#2662
  def em_delete(key); end

  # source://reline//reline/line_editor.rb#2753
  def em_delete_next_word(key); end

  # source://reline//reline/line_editor.rb#2689
  def em_delete_or_list(key); end

  # source://reline//reline/line_editor.rb#2585
  def em_delete_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3347
  def em_exchange_mark(key); end

  # Editline:: +em-kill-line+ (not bound) Delete the entire contents of the
  #            edit buffer and save it to the cut buffer. +vi-kill-line-prev+
  # GNU Readline:: +kill-whole-line+ (not bound) Kill all characters on the
  #                current line, no matter where point is.
  #
  # source://reline//reline/line_editor.rb#2651
  def em_kill_line(key); end

  # source://reline//reline/line_editor.rb#2852
  def em_kill_region(key); end

  # source://reline//reline/line_editor.rb#2820
  def em_lower_case(key); end

  # source://reline//reline/line_editor.rb#2735
  def em_next_word(key); end

  # source://reline//reline/line_editor.rb#3342
  def em_set_mark(key); end

  # source://reline//reline/line_editor.rb#2836
  def em_upper_case(key); end

  # source://reline//reline/line_editor.rb#2701
  def em_yank(key); end

  # source://reline//reline/line_editor.rb#2713
  def em_yank_pop(key); end

  # source://reline//reline/line_editor.rb#2124
  def end_of_line(key); end

  # source://reline//reline/line_editor.rb#3347
  def exchange_point_and_mark(key); end

  # source://reline//reline/line_editor.rb#2075
  def forward_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2349
  def forward_search_history(key); end

  # source://reline//reline/line_editor.rb#2735
  def forward_word(key); end

  # source://reline//reline/line_editor.rb#2139
  def generate_searcher; end

  # source://reline//reline/line_editor.rb#2354
  def history_search_backward(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2401
  def history_search_forward(key, arg: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://reline//reline/line_editor.rb#1471
  def inclusive?(method_obj); end

  # source://reline//reline/line_editor.rb#2257
  def incremental_search_history(key); end

  # source://reline//reline/line_editor.rb#337
  def insert_new_line(cursor_line, next_line); end

  # source://reline//reline/line_editor.rb#1955
  def key_delete(key); end

  # source://reline//reline/line_editor.rb#1961
  def key_newline(key); end

  # Editline:: +ed-kill-line+ (vi command: +D+, +Ctrl-K+; emacs: +Ctrl-K+,
  #            +Ctrl-U+) + Kill from the cursor to the end of the line.
  # GNU Readline:: +kill-line+ (+C-k+) Kill the text from point to the end of
  #                the line. With a negative numeric argument, kill backward
  #                from the cursor to the beginning of the current line.
  #
  # source://reline//reline/line_editor.rb#2613
  def kill_line(key); end

  # Editline:: +em-kill-line+ (not bound) Delete the entire contents of the
  #            edit buffer and save it to the cut buffer. +vi-kill-line-prev+
  # GNU Readline:: +kill-whole-line+ (not bound) Kill all characters on the
  #                current line, no matter where point is.
  #
  # source://reline//reline/line_editor.rb#2651
  def kill_whole_line(key); end

  # source://reline//reline/line_editor.rb#1289
  def menu(target, list); end

  # source://reline//reline/line_editor.rb#1241
  def modify_lines(before); end

  # source://reline//reline/line_editor.rb#1383
  def move_completed_list(list, direction); end

  # source://reline//reline/line_editor.rb#373
  def move_cursor_down(val); end

  # source://reline//reline/line_editor.rb#364
  def move_cursor_up(val); end

  # source://reline//reline/line_editor.rb#2504
  def next_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1554
  def normal_char(key); end

  # source://reline//reline/line_editor.rb#657
  def padding_space_with_escape_sequences(str, width); end

  # source://reline//reline/line_editor.rb#2453
  def previous_history(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1697
  def process_auto_indent; end

  # source://reline//reline/line_editor.rb#1978
  def process_insert(force: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1497
  def process_key(key, method_symbol); end

  # source://reline//reline/line_editor.rb#2059
  def quoted_insert(str, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#651
  def render_dialog(cursor_column); end

  # source://reline//reline/line_editor.rb#664
  def render_each_dialog(dialog, cursor_column); end

  # source://reline//reline/line_editor.rb#1144
  def render_partial(prompt, prompt_width, line_to_render, this_started_from, with_control: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#1118
  def render_whole_lines(lines, prompt, prompt_width); end

  # source://reline//reline/line_editor.rb#967
  def rerender_added_newline(prompt, prompt_width); end

  # source://reline//reline/line_editor.rb#1063
  def rerender_all_lines; end

  # source://reline//reline/line_editor.rb#1015
  def rerender_changed_current_line; end

  # source://reline//reline/line_editor.rb#786
  def reset_dialog(dialog, old_dialog); end

  # source://reline//reline/line_editor.rb#2344
  def reverse_search_history(key); end

  # source://reline//reline/line_editor.rb#1429
  def run_for_operators(key, method_symbol, &block); end

  # source://reline//reline/line_editor.rb#353
  def scroll_down(val); end

  # source://reline//reline/line_editor.rb#3231
  def search_next_char(key, arg, need_prev_char: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3288
  def search_prev_char(key, arg, need_next_char = T.unsafe(nil)); end

  # Editline:: +ed-insert+ (vi input: almost all; emacs: printable characters)
  #            In insert mode, insert the input character left of the cursor
  #            position. In replace mode, overwrite the character at the
  #            cursor and move the cursor to the right by one character
  #            position. Accept an argument to do this repeatedly. It is an
  #            error if the input character is the NUL character (+Ctrl-@+).
  #            Failure to enlarge the edit buffer also results in an error.
  # Editline:: +ed-digit+ (emacs: 0 to 9) If in argument input mode, append
  #            the input digit to the argument being read. Otherwise, call
  #            +ed-insert+. It is an error if the input character is not a
  #            digit or if the existing argument is already greater than a
  #            million.
  # GNU Readline:: +self-insert+ (a, b, A, 1, !, …) Insert yourself.
  #
  # source://reline//reline/line_editor.rb#2006
  def self_insert(key); end

  # source://reline//reline/line_editor.rb#3342
  def set_mark(key); end

  # source://reline//reline/line_editor.rb#1251
  def show_menu; end

  # source://reline//reline/line_editor.rb#349
  def split_by_width(str, max_width); end

  # source://reline//reline/line_editor.rb#2773
  def transpose_chars(key); end

  # source://reline//reline/line_editor.rb#2793
  def transpose_words(key); end

  # Editline:: +vi-kill-line-prev+ (vi: +Ctrl-U+) Delete the string from the
  #            beginning  of the edit buffer to the cursor and save it to the
  #            cut buffer.
  # GNU Readline:: +unix-line-discard+ (+C-u+) Kill backward from the cursor
  #                to the beginning of the current line.
  #
  # source://reline//reline/line_editor.rb#2636
  def unix_line_discard(key); end

  # source://reline//reline/line_editor.rb#2852
  def unix_word_rubout(key); end

  # source://reline//reline/line_editor.rb#2836
  def upcase_word(key); end

  # source://reline//reline/line_editor.rb#2874
  def vi_add(key); end

  # source://reline//reline/line_editor.rb#2988
  def vi_add_at_eol(key); end

  # source://reline//reline/line_editor.rb#3014
  def vi_change_meta(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2879
  def vi_command_mode(key); end

  # source://reline//reline/line_editor.rb#3032
  def vi_delete_meta(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2963
  def vi_delete_prev_char(key); end

  # source://reline//reline/line_editor.rb#2944
  def vi_end_big_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3059
  def vi_end_of_transmission(key); end

  # source://reline//reline/line_editor.rb#2905
  def vi_end_word(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3059
  def vi_eof_maybe(key); end

  # source://reline//reline/line_editor.rb#2115
  def vi_first_print(key); end

  # source://reline//reline/line_editor.rb#3117
  def vi_histedit(key); end

  # source://reline//reline/line_editor.rb#2870
  def vi_insert(key); end

  # source://reline//reline/line_editor.rb#2983
  def vi_insert_at_bol(key); end

  # source://reline//reline/line_editor.rb#3328
  def vi_join_lines(key, arg: T.unsafe(nil)); end

  # Editline:: +vi-kill-line-prev+ (vi: +Ctrl-U+) Delete the string from the
  #            beginning  of the edit buffer to the cursor and save it to the
  #            cut buffer.
  # GNU Readline:: +unix-line-discard+ (+C-u+) Kill backward from the cursor
  #                to the beginning of the current line.
  #
  # source://reline//reline/line_editor.rb#2636
  def vi_kill_line_prev(key); end

  # source://reline//reline/line_editor.rb#3059
  def vi_list_or_eof(key); end

  # source://reline//reline/line_editor.rb#2879
  def vi_movement_mode(key); end

  # source://reline//reline/line_editor.rb#2924
  def vi_next_big_word(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3223
  def vi_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2885
  def vi_next_word(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3151
  def vi_paste_next(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3139
  def vi_paste_prev(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2934
  def vi_prev_big_word(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3280
  def vi_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2895
  def vi_prev_word(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3195
  def vi_replace_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#2349
  def vi_search_next(key); end

  # source://reline//reline/line_editor.rb#2344
  def vi_search_prev(key); end

  # source://reline//reline/line_editor.rb#3180
  def vi_to_column(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3094
  def vi_to_history_line(key); end

  # source://reline//reline/line_editor.rb#3227
  def vi_to_next_char(key, arg: T.unsafe(nil), inclusive: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3284
  def vi_to_prev_char(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3047
  def vi_yank(key, arg: T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#3009
  def vi_zero(key); end

  # source://reline//reline/line_editor.rb#2701
  def yank(key); end

  # source://reline//reline/line_editor.rb#2713
  def yank_pop(key); end
end

# source://reline//reline/line_editor.rb#51
Reline::LineEditor::CompletionJourneyData = Struct

# source://reline//reline/line_editor.rb#44
Reline::LineEditor::CompletionState::COMPLETION = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#46
Reline::LineEditor::CompletionState::JOURNEY = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#45
Reline::LineEditor::CompletionState::MENU = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#47
Reline::LineEditor::CompletionState::MENU_WITH_PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#43
Reline::LineEditor::CompletionState::NORMAL = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#48
Reline::LineEditor::CompletionState::PERFECT_MATCH = T.let(T.unsafe(nil), Symbol)

# source://reline//reline/line_editor.rb#650
Reline::LineEditor::DIALOG_DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

class Reline::LineEditor::Dialog
  # @return [Dialog] a new instance of Dialog
  #
  # source://reline//reline/line_editor.rb#598
  def initialize(name, config, proc_scope); end

  # source://reline//reline/line_editor.rb#622
  def call(key); end

  # Returns the value of attribute column.
  #
  # source://reline//reline/line_editor.rb#596
  def column; end

  # Sets the attribute column
  #
  # @param value the value to set the attribute column to.
  #
  # source://reline//reline/line_editor.rb#596
  def column=(_arg0); end

  # Returns the value of attribute contents.
  #
  # source://reline//reline/line_editor.rb#595
  def contents; end

  # source://reline//reline/line_editor.rb#615
  def contents=(contents); end

  # Returns the value of attribute lines_backup.
  #
  # source://reline//reline/line_editor.rb#596
  def lines_backup; end

  # Sets the attribute lines_backup
  #
  # @param value the value to set the attribute lines_backup to.
  #
  # source://reline//reline/line_editor.rb#596
  def lines_backup=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://reline//reline/line_editor.rb#595
  def name; end

  # Returns the value of attribute pointer.
  #
  # source://reline//reline/line_editor.rb#596
  def pointer; end

  # Sets the attribute pointer
  #
  # @param value the value to set the attribute pointer to.
  #
  # source://reline//reline/line_editor.rb#596
  def pointer=(_arg0); end

  # Returns the value of attribute scroll_top.
  #
  # source://reline//reline/line_editor.rb#596
  def scroll_top; end

  # Sets the attribute scroll_top
  #
  # @param value the value to set the attribute scroll_top to.
  #
  # source://reline//reline/line_editor.rb#596
  def scroll_top=(_arg0); end

  # Returns the value of attribute scrollbar_pos.
  #
  # source://reline//reline/line_editor.rb#596
  def scrollbar_pos; end

  # Sets the attribute scrollbar_pos
  #
  # @param value the value to set the attribute scrollbar_pos to.
  #
  # source://reline//reline/line_editor.rb#596
  def scrollbar_pos=(_arg0); end

  # source://reline//reline/line_editor.rb#607
  def set_cursor_pos(col, row); end

  # Returns the value of attribute trap_key.
  #
  # source://reline//reline/line_editor.rb#596
  def trap_key; end

  # Sets the attribute trap_key
  #
  # @param value the value to set the attribute trap_key to.
  #
  # source://reline//reline/line_editor.rb#596
  def trap_key=(_arg0); end

  # Returns the value of attribute vertical_offset.
  #
  # source://reline//reline/line_editor.rb#596
  def vertical_offset; end

  # Sets the attribute vertical_offset
  #
  # @param value the value to set the attribute vertical_offset to.
  #
  # source://reline//reline/line_editor.rb#596
  def vertical_offset=(_arg0); end

  # Returns the value of attribute width.
  #
  # source://reline//reline/line_editor.rb#595
  def width; end

  # source://reline//reline/line_editor.rb#611
  def width=(v); end
end

class Reline::LineEditor::DialogProcScope
  # @return [DialogProcScope] a new instance of DialogProcScope
  #
  # source://reline//reline/line_editor.rb#528
  def initialize(line_editor, config, proc_to_exec, context); end

  # source://reline//reline/line_editor.rb#589
  def call; end

  # source://reline//reline/line_editor.rb#544
  def call_completion_proc_with_checking_args(pre, target, post); end

  # source://reline//reline/line_editor.rb#581
  def completion_journey_data; end

  # source://reline//reline/line_editor.rb#585
  def config; end

  # source://reline//reline/line_editor.rb#536
  def context; end

  # source://reline//reline/line_editor.rb#569
  def cursor_pos; end

  # source://reline//reline/line_editor.rb#552
  def dialog; end

  # source://reline//reline/line_editor.rb#573
  def just_cursor_moving; end

  # source://reline//reline/line_editor.rb#565
  def key; end

  # source://reline//reline/line_editor.rb#540
  def retrieve_completion_block(set_completion_quote_character = T.unsafe(nil)); end

  # source://reline//reline/line_editor.rb#577
  def screen_width; end

  # source://reline//reline/line_editor.rb#556
  def set_cursor_pos(col, row); end

  # source://reline//reline/line_editor.rb#548
  def set_dialog(dialog); end

  # source://reline//reline/line_editor.rb#561
  def set_key(key); end
end

# source://reline//reline/line_editor.rb#52
Reline::LineEditor::MenuInfo = Struct

# source://reline//reline/line_editor.rb#54
Reline::LineEditor::PROMPT_LIST_CACHE_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://reline//reline/line_editor.rb#21
Reline::LineEditor::VI_MOTIONS = T.let(T.unsafe(nil), Array)

module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
  extend ::Fiddle::Importer

  class << self
    # source://reline//reline/terminfo.rb#32
    def curses_dl; end

    # source://reline//reline/terminfo.rb#17
    def curses_dl_files; end

    # @return [Boolean]
    #
    # source://reline//reline/terminfo.rb#165
    def enabled?; end

    # source://reline//reline/terminfo.rb#94
    def setupterm(term, fildes); end

    # @raise [TerminfoError]
    #
    # source://reline//reline/terminfo.rb#141
    def tigetflag(capname); end

    # @raise [TerminfoError]
    #
    # source://reline//reline/terminfo.rb#153
    def tigetnum(capname); end

    # @raise [TerminfoError]
    #
    # source://reline//reline/terminfo.rb#123
    def tigetstr(capname); end

    # source://reline//reline/terminfo.rb#133
    def tiparm(str, *args); end
  end
end

class Reline::Terminfo::StringWithTiparm < ::String
  # for method chain
  #
  # source://reline//reline/terminfo.rb#118
  def tiparm(*args); end
end

# source://reline//reline.rb#15
Reline::USERNAME_COMPLETION_PROC = T.let(T.unsafe(nil), T.untyped)

class Reline::Unicode
  class << self
    # source://reline//reline/unicode.rb#130
    def calculate_width(str, allow_escape_code = T.unsafe(nil)); end

    # source://reline//reline/unicode.rb#330
    def ed_transpose_words(line, byte_pointer); end

    # source://reline//reline/unicode.rb#290
    def em_backward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#310
    def em_big_backward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#241
    def em_forward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#261
    def em_forward_word_with_capitalization(line, byte_pointer); end

    # source://reline//reline/unicode.rb#69
    def escape_for_print(str); end

    # source://reline//reline/unicode.rb#49
    def get_mbchar_byte_size_by_first_char(c); end

    # source://reline//reline/unicode.rb#110
    def get_mbchar_width(mbchar); end

    # source://reline//reline/unicode.rb#227
    def get_next_mbchar_size(line, byte_pointer); end

    # source://reline//reline/unicode.rb#232
    def get_prev_mbchar_size(line, byte_pointer); end

    # source://reline//reline/unicode.rb#157
    def split_by_width(str, max_width, encoding = T.unsafe(nil)); end

    # Take a chunk of a String cut by width with escape sequences.
    #
    # source://reline//reline/unicode.rb#197
    def take_range(str, start_col, max_width, encoding = T.unsafe(nil)); end

    # source://reline//reline/unicode.rb#619
    def vi_backward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#481
    def vi_big_backward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#451
    def vi_big_forward_end_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#431
    def vi_big_forward_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#651
    def vi_first_print(line); end

    # source://reline//reline/unicode.rb#542
    def vi_forward_end_word(line, byte_pointer); end

    # source://reline//reline/unicode.rb#501
    def vi_forward_word(line, byte_pointer, drop_terminate_spaces = T.unsafe(nil)); end
  end
end

# source://reline//reline/unicode.rb#40
Reline::Unicode::CSI_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/unicode.rb#45
Reline::Unicode::CSI_REGEXP_INDEX = T.let(T.unsafe(nil), Integer)

# Ambiguous
#
# source://reline//reline/unicode/east_asian_width.rb#153
Reline::Unicode::EastAsianWidth::TYPE_A = T.let(T.unsafe(nil), Regexp)

# Fullwidth
#
# source://reline//reline/unicode/east_asian_width.rb#6
Reline::Unicode::EastAsianWidth::TYPE_F = T.let(T.unsafe(nil), Regexp)

# Halfwidth
#
# source://reline//reline/unicode/east_asian_width.rb#13
Reline::Unicode::EastAsianWidth::TYPE_H = T.let(T.unsafe(nil), Regexp)

# Neutral
#
# source://reline//reline/unicode/east_asian_width.rb#336
Reline::Unicode::EastAsianWidth::TYPE_N = T.let(T.unsafe(nil), Regexp)

# Narrow
#
# source://reline//reline/unicode/east_asian_width.rb#142
Reline::Unicode::EastAsianWidth::TYPE_NA = T.let(T.unsafe(nil), Regexp)

# Wide
#
# source://reline//reline/unicode/east_asian_width.rb#24
Reline::Unicode::EastAsianWidth::TYPE_W = T.let(T.unsafe(nil), Regexp)

# C-? C-8
#
# source://reline//reline/unicode.rb#36
Reline::Unicode::EscapedChars = T.let(T.unsafe(nil), Array)

# source://reline//reline/unicode.rb#2
Reline::Unicode::EscapedPairs = T.let(T.unsafe(nil), Hash)

# source://reline//reline/unicode.rb#47
Reline::Unicode::GRAPHEME_CLUSTER_INDEX = T.let(T.unsafe(nil), Integer)

# source://reline//reline/unicode.rb#82
Reline::Unicode::HalfwidthDakutenHandakuten = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/unicode.rb#84
Reline::Unicode::MBCharWidthRE = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/unicode.rb#39
Reline::Unicode::NON_PRINTING_END = T.let(T.unsafe(nil), String)

# source://reline//reline/unicode.rb#44
Reline::Unicode::NON_PRINTING_END_INDEX = T.let(T.unsafe(nil), Integer)

# source://reline//reline/unicode.rb#38
Reline::Unicode::NON_PRINTING_START = T.let(T.unsafe(nil), String)

# source://reline//reline/unicode.rb#43
Reline::Unicode::NON_PRINTING_START_INDEX = T.let(T.unsafe(nil), Integer)

# source://reline//reline/unicode.rb#41
Reline::Unicode::OSC_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/unicode.rb#46
Reline::Unicode::OSC_REGEXP_INDEX = T.let(T.unsafe(nil), Integer)

# source://reline//reline/unicode.rb#42
Reline::Unicode::WIDTH_SCANNER = T.let(T.unsafe(nil), Regexp)

# source://reline//reline/version.rb#2
Reline::VERSION = T.let(T.unsafe(nil), String)
