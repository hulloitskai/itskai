# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-graphql` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-graphql`.

# source://rubocop-graphql//lib/rubocop/graphql/ext/snake_case.rb#3
module RuboCop; end

# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_description.rb#4
module RuboCop::Cop; end

# This cop checks whether type definitions are class-based or legacy.
#
# @example
#   # good
#
#   class Example < BaseType
#   ....
#   end
#
#   # bad
#
#   Example = GraphQL::ObjectType.define do
#   ....
#   ....
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_description.rb#5
module RuboCop::Cop::GraphQL; end

# This cop checks if each field has a description.
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :uuid, ID, required: true, description: "UUID of the user to ban"
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :uuid, ID, required: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_description.rb#21
class RuboCop::Cop::GraphQL::ArgumentDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_description.rb#26
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_description.rb#24
RuboCop::Cop::GraphQL::ArgumentDescription::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether field names are snake_case.
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :userId, ID, required: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_name.rb#21
class RuboCop::Cop::GraphQL::ArgumentName < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_name.rb#28
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_name.rb#26
RuboCop::Cop::GraphQL::ArgumentName::MSG = T.let(T.unsafe(nil), String)

# This cop detects duplicate argument definitions
#
# @example
#   # good
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   end
#
#   # bad
#
#   class BanUser < BaseMutation
#   argument :user_id, ID, required: true
#   argument :user_id, ID, required: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#22
class RuboCop::Cop::GraphQL::ArgumentUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodeUniqueness

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#97
  def argument_declarations(param0); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#28
  def on_class(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#73
  def argument_name(node); end

  # Find parent field block, if available
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#78
  def field_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#60
  def register_offense(current); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/argument_uniqueness.rb#25
RuboCop::Cop::GraphQL::ArgumentUniqueness::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/extract_input_type.rb#6
class RuboCop::Cop::GraphQL::ExtractInputType < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_input_type.rb#29
  def on_class(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/extract_input_type.rb#27
RuboCop::Cop::GraphQL::ExtractInputType::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#6
class RuboCop::Cop::GraphQL::ExtractType < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#38
  def on_class(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#51
  def check_fields_prefixes(body); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#69
  def fractured(body); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#93
  def ignored_prefix?(word); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#89
  def message(prefix, field_names); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/extract_type.rb#48
RuboCop::Cop::GraphQL::ExtractType::MSG = T.let(T.unsafe(nil), String)

# Checks consistency of field definitions
#
# EnforcedStyle supports two modes:
#
# `group_definitions` : all field definitions should be grouped together.
#
# `define_resolver_after_definition` : if resolver method exists it should
# be defined right after the field definition.
#
# @example EnforcedStyle: group_definitions (default)
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#   field :last_name, String, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#
#   def last_name
#   object.contact_data.last_name
#   end
#   end
# @example EnforcedStyle: define_resolver_after_definition
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#
#   field :last_name, String, null: true
#
#   def last_name
#   object.contact_data.last_name
#   end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#47
class RuboCop::Cop::GraphQL::FieldDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::Sorbet
  include ::RuboCop::GraphQL::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#56
  def field_kwargs(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#73
  def on_class(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#83
  def on_module(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#65
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#97
  def check_grouped_field_declarations(body); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#126
  def check_resolver_is_defined_after_definition(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#148
  def field_has_no_resolver_method(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#156
  def field_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#184
  def fields_with_same_resolver(field, resolver); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#111
  def group_field_declarations(corrector, node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#245
  def indent(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#212
  def insert_new_resolver(corrector, field_definition, resolver_definition); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#152
  def multiple_definitions(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#160
  def offense_message(single_field_using_resolver); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#199
  def place_resolver_after_field_definition(corrector, node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#221
  def remove_old_resolver(corrector, resolver_definition); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#164
  def resolver_defined_after_definition?(field, method_definition); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#237
  def signature_to_insert(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#95
RuboCop::Cop::GraphQL::FieldDefinitions::GROUP_DEFS_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#122
RuboCop::Cop::GraphQL::FieldDefinitions::RESOLVER_AFTER_FIELD_MSG = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_definitions.rb#123
RuboCop::Cop::GraphQL::FieldDefinitions::RESOLVER_AFTER_LAST_FIELD_MSG = T.let(T.unsafe(nil), String)

# This cop checks if each field has a description.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, "Name of the user", null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :name, String, null: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_description.rb#21
class RuboCop::Cop::GraphQL::FieldDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_description.rb#26
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_description.rb#24
RuboCop::Cop::GraphQL::FieldDescription::MSG = T.let(T.unsafe(nil), String)

# This cop prevents defining unnecessary resolver methods in cases
#  when :hash_key option can be used
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true, hash_key: :home_phone
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true
#
#   def phone
#   object[:home_phone]
#   end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#26
class RuboCop::Cop::GraphQL::FieldHashKey < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#32
  def hash_key_to_use(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#45
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#71
  def autocorrect(corrector, node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#63
  def conflict?(suggested_hash_key_name); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#67
  def message(hash_key); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#87
  def resolver_method_definition_for(field); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_hash_key.rb#43
RuboCop::Cop::GraphQL::FieldHashKey::MSG = T.let(T.unsafe(nil), String)

# This cop prevents defining unnecessary resolver methods in cases
#  when :method option can be used
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true, method: :home_phone
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   field :phone, String, null: true
#
#   def phone
#   object.home_phone
#   end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#26
class RuboCop::Cop::GraphQL::FieldMethod < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#32
  def method_to_use(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#44
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#67
  def autocorrect(corrector, node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#63
  def message(method_name); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#85
  def method_kwarg_set?(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#80
  def suggest_method_name_for(field); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_method.rb#42
RuboCop::Cop::GraphQL::FieldMethod::MSG = T.let(T.unsafe(nil), String)

# This cop checks whether field names are snake_case.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :firstName, String, null: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_name.rb#25
class RuboCop::Cop::GraphQL::FieldName < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_name.rb#33
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_name.rb#46
  def rename_field_name(corrector, field, node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_name.rb#31
RuboCop::Cop::GraphQL::FieldName::MSG = T.let(T.unsafe(nil), String)

# Detects duplicate field definitions within
# the same type
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#29
class RuboCop::Cop::GraphQL::FieldUniqueness < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodeUniqueness

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#70
  def field_declarations(param0); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#35
  def on_class(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#65
  def field_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#56
  def register_offense(current); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/field_uniqueness.rb#32
RuboCop::Cop::GraphQL::FieldUniqueness::MSG = T.let(T.unsafe(nil), String)

# Checks consistency of graphql_name usage
#
# EnforcedStyle supports two modes:
#
# `only_override` : types and mutations should have graphql_name configured only if it's
#  different from the default name
#
# `required` : all types and mutations should have graphql_name configured
#
# @example EnforcedStyle: only_override (default)
#   # good
#
#   class UserType < BaseType
#   graphql_name 'Viewer'
#   end
#
#   # bad
#
#   class UserType < BaseType
#   graphql_name 'User'
#   end
# @example EnforcedStyle: required
#   # good
#
#   class UserType < BaseType
#   graphql_name 'User'
#   end
#
#   # bad
#
#   class UserType < BaseType
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#40
class RuboCop::Cop::GraphQL::GraphqlName < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableEnforcedStyle

  # source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#49
  def class_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#44
  def graphql_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#56
  def on_class(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#53
RuboCop::Cop::GraphQL::GraphqlName::MISSING_NAME = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/graphql_name.rb#54
RuboCop::Cop::GraphQL::GraphqlName::UNNEEDED_OVERRIDE = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/cop/graphql/legacy_dsl.rb#22
class RuboCop::Cop::GraphQL::LegacyDsl < ::RuboCop::Cop::Base
  # source://rubocop-graphql//lib/rubocop/cop/graphql/legacy_dsl.rb#24
  def legacy_dsl?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/legacy_dsl.rb#36
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/legacy_dsl.rb#33
RuboCop::Cop::GraphQL::LegacyDsl::MSG = T.let(T.unsafe(nil), String)

# Detects missing max_complexity configuration in schema files
#
# @example
#   # good
#
#   class AppSchema < BaseSchema
#   max_complexity 42
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/max_complexity_schema.rb#15
class RuboCop::Cop::GraphQL::MaxComplexitySchema < ::RuboCop::Cop::Base
  # source://rubocop-graphql//lib/rubocop/cop/graphql/max_complexity_schema.rb#17
  def max_complexity(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/max_complexity_schema.rb#23
  def on_class(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/max_complexity_schema.rb#21
RuboCop::Cop::GraphQL::MaxComplexitySchema::MSG = T.let(T.unsafe(nil), String)

# Detects missing max_depth configuration in schema files
#
# @example
#   # good
#
#   class AppSchema < BaseSchema
#   max_depth 42
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/max_depth_schema.rb#15
class RuboCop::Cop::GraphQL::MaxDepthSchema < ::RuboCop::Cop::Base
  # source://rubocop-graphql//lib/rubocop/cop/graphql/max_depth_schema.rb#17
  def max_depth(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/max_depth_schema.rb#23
  def on_class(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/max_depth_schema.rb#21
RuboCop::Cop::GraphQL::MaxDepthSchema::MSG = T.let(T.unsafe(nil), String)

# Checks whether fields with multiple definitions are grouped together.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#   field :first_name, Name, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :first_name, String, null: true
#
#   def first_name
#   object.contact_data.first_name
#   end
#   field :first_name, Name, null: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#29
class RuboCop::Cop::GraphQL::MultipleFieldDefinitions < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::Heredoc
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#35
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#61
  def field_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#95
  def field_sibling_index(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#65
  def group_multiple_definitions(corrector, multiple_definitions); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#87
  def has_ungrouped_definitions?(multiple_definitions); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#74
  def insert_new_field(corrector, first, second); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#57
  def multiple_definitions(field); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#80
  def remove_old_field(corrector, second); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/multiple_field_definitions.rb#55
RuboCop::Cop::GraphQL::MultipleFieldDefinitions::MULTIPLE_DEFINITIONS_MSG = T.let(T.unsafe(nil), String)

# Detects types that implement Node interface and not have `.authorized?` check.
# Such types can be fetched by ID and therefore should have type level check to
# avoid accidental information exposure.
#
# If `.authorized?` is defined in a parent class, you can add parent to the "SafeBaseClasses"
# to avoid offenses in children.
#
# @example
#   # good
#
#   class UserType < BaseType
#   implements GraphQL::Types::Relay::Node
#
#   field :uuid, ID, null: false
#
#   def self.authorized?(object, context)
#   super && object.owner == context[:viewer]
#   end
#   end
#
#   # good
#
#   class UserType < BaseType
#   implements GraphQL::Types::Relay::Node
#
#   field :uuid, ID, null: false
#
#   class << self
#   def authorized?(object, context)
#   super && object.owner == context[:viewer]
#   end
#   end
#   end
#
#   # bad
#
#   class UserType < BaseType
#   implements GraphQL::Types::Relay::Node
#
#   field :uuid, ID, null: false
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#48
class RuboCop::Cop::GraphQL::NotAuthorizedNodeType < ::RuboCop::Cop::Base
  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#52
  def class_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#66
  def has_authorized_method?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#57
  def implements_node_type?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#70
  def on_class(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#82
  def ignored_class?(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#78
  def parent_class(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/not_authorized_node_type.rb#49
RuboCop::Cop::GraphQL::NotAuthorizedNodeType::MSG = T.let(T.unsafe(nil), String)

# This cop checks if a type (object, input, interface, scalar, union,
#  mutation, subscription, and resolver) has a description.
#
# @example
#   # good
#
#   class Types::UserType < Types::BaseObject
#   description "Represents application user"
#   # ...
#   end
#
#   # bad
#
#   class Types::UserType < Types::BaseObject
#   # ...
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#23
class RuboCop::Cop::GraphQL::ObjectDescription < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  include ::RuboCop::GraphQL::DescriptionMethod

  # source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#30
  def interface?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#34
  def on_class(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#40
  def on_module(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#54
  def child_nodes(node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#50
  def has_description?(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/object_description.rb#27
RuboCop::Cop::GraphQL::ObjectDescription::MSG = T.let(T.unsafe(nil), String)

# Arguments should be alphabetically sorted within groups.
#
# @example
#   # good
#
#   class UpdateProfile < BaseMutation
#   argument :email, String, required: false
#   argument :name, String, required: false
#   end
#
#   # good
#
#   class UpdateProfile < BaseMutation
#   argument :uuid, ID, required: true
#
#   argument :email, String, required: false
#   argument :name, String, required: false
#   end
#
#   # good
#
#   class UserType < BaseType
#   field :posts, PostType do
#   argument :created_after, ISO8601DateTime, required: false
#   argument :created_before, ISO8601DateTime, required: false
#   end
#   end
#
#   # bad
#
#   class UpdateProfile < BaseMutation
#   argument :uuid, ID, required: true
#   argument :name, String, required: false
#   argument :email, String, required: false
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :posts, PostType do
#   argument :created_before, ISO8601DateTime, required: false
#   argument :created_after, ISO8601DateTime, required: false
#   end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#51
class RuboCop::Cop::GraphQL::OrderedArguments < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::SwapRange
  include ::RuboCop::GraphQL::CompareOrder
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#111
  def argument_declarations_with_blocks(param0); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#106
  def argument_declarations_without_blocks(param0); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#60
  def on_class(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#95
  def argument_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#101
  def consecutive_lines(previous, current); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#83
  def register_offense(previous, current); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_arguments.rb#57
RuboCop::Cop::GraphQL::OrderedArguments::MSG = T.let(T.unsafe(nil), String)

# Fields should be alphabetically sorted within groups.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, null: true
#   field :phone, String, null: true do
#   argument :something, String, required: false
#   end
#   end
#
#   # good
#
#   class UserType < BaseType
#   field :phone, String, null: true
#
#   field :name, String, null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :phone, String, null: true
#   field :name, String, null: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#33
class RuboCop::Cop::GraphQL::OrderedFields < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::GraphQL::SwapRange
  include ::RuboCop::GraphQL::CompareOrder
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#44
  def field_declarations(param0); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#52
  def on_class(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#63
  def consecutive_fields(previous, current); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#83
  def field_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#71
  def register_offense(previous, current); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/ordered_fields.rb#39
RuboCop::Cop::GraphQL::OrderedFields::MSG = T.let(T.unsafe(nil), String)

# Checks if the length of a resolver method exceeds some maximum value.
# Comment lines can optionally be ignored.
#
# The maximum allowed length is configurable using the Max option.
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#10
class RuboCop::Cop::GraphQL::ResolverMethodLength < ::RuboCop::Cop::Base
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::CodeLength

  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#17
  def field_definition(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#21
  def on_def(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#21
  def on_defs(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#37
  def code_length(node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#41
  def field_is_defined?(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#48
  def message(length); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/resolver_method_length.rb#14
RuboCop::Cop::GraphQL::ResolverMethodLength::MSG = T.let(T.unsafe(nil), String)

# This cop checks if each argument has an unnecessary camelize.
#
#  # bad
#
#   class UserType < BaseType
#     argument :filter, String, required: false, camelize: false
#   end
#
#  # bad
#
#   class UserType < BaseType
#     field :name, String, "Name of the user", null: true do
#       argument :filter, String, required: false, camelize: false
#     end
#   end
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, "Name of the user", null: true do
#   argument :filter, String, required: false
#   end
#   end
#
#   # good
#
#   class UserType < BaseType
#   argument :filter, String, required: false
#   end
#
#   # good
#
#   class UserType < BaseType
#   argument :email_filter, String, required: false, camelize: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_argument_camelize.rb#43
class RuboCop::Cop::GraphQL::UnnecessaryArgumentCamelize < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_argument_camelize.rb#48
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_argument_camelize.rb#46
RuboCop::Cop::GraphQL::UnnecessaryArgumentCamelize::MSG = T.let(T.unsafe(nil), String)

# This cop prevents defining an unnecessary alias, method, or resolver_method.
#
# @example
#   # good
#
#   field :name, String, "Name of the user", null: true, alias: :real_name
#   field :name, String, "Name of the user", null: true, method: :real_name
#   field :name, String, "Name of the user", null: true, resolver_method: :real_name
#   field :name, String, "Name of the user", null: true, hash_key: :real_name
#
#   # bad
#
#   field :name, "Name of the user" String, null: true, alias: :name
#   field :name, String, "Name of the user", null: true, method: :name
#   field :name, String, "Name of the user", null: true, resolver_method: :name
#   field :name, String, "Name of the user", null: true, hash_key: :name
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_alias.rb#23
class RuboCop::Cop::GraphQL::UnnecessaryFieldAlias < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_alias.rb#29
  def on_send(node); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_alias.rb#48
  def validate_kwargs(field); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_alias.rb#27
RuboCop::Cop::GraphQL::UnnecessaryFieldAlias::MSG = T.let(T.unsafe(nil), String)

# This cop checks if each field has an unnecessary camelize.
#
# @example
#   # good
#
#   class UserType < BaseType
#   field :name, String, "Name of the user", null: true
#   end
#
#   # bad
#
#   class UserType < BaseType
#   field :name, "Name of the user", String, null: true, camelize: true
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_camelize.rb#21
class RuboCop::Cop::GraphQL::UnnecessaryFieldCamelize < ::RuboCop::Cop::Base
  include ::RuboCop::GraphQL::NodePattern

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_camelize.rb#26
  def on_send(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/unnecessary_field_camelize.rb#24
RuboCop::Cop::GraphQL::UnnecessaryFieldCamelize::MSG = T.let(T.unsafe(nil), String)

# Arguments should either be listed explicitly or **rest should be in the resolve signature
# (and similar methods, such as #authorized?).
#
# @example
#   # good
#
#   class SomeResolver < Resolvers::Base
#   argument :arg1, String, required: true
#   argument :user_id, String, required: true, loads: Types::UserType
#   argument :post_id, String, loads: Types::PostType, as: :article
#   argument :comment_ids, String, loads: Types::CommentType
#
#   def authorized?(arg1:, user:, article:, comments:); end
#   def resolve(arg1:, user:, article:, comments:); end
#   end
#
#   # good
#
#   class SomeResolver < Resolvers::Base
#   argument :arg1, String, required: true
#   argument :user_id, String, required: true, loads: Types::UserType
#   argument :comment_ids, String, loads: Types::CommentType
#
#   def resolve(arg1:, **rest); end
#   end
#
#   # good
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def resolve(args); end
#   end
#
#   # bad
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def authorized?; end
#   def resolve(arg1:); end
#   end
#
#   # bad
#
#   class SomeResolver < Resolvers::Base
#   type SomeType, null: false
#
#   argument :arg1, String, required: true
#   argument :arg2, String, required: true
#
#   def resolve; end
#   end
#
# source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#66
class RuboCop::Cop::GraphQL::UnusedArgument < ::RuboCop::Cop::Base
  extend ::RuboCop::Cop::AutoCorrector

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#183
  def argument_declaration?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#71
  def on_class(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#188
  def resolve_method_definition(param0); end

  private

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#146
  def arg_end(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#163
  def arg_name(declared_arg); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#178
  def block_or_lambda?(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#84
  def find_declared_arg_nodes(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#96
  def find_resolve_method_node(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#104
  def find_unresolved_args(method_node, declared_arg_nodes); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#117
  def ignore_arguments_type?(resolve_method_node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#150
  def inferred_arg_name(name_as_string); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#142
  def method_name(node); end

  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#123
  def register_offense(node, unresolved_args); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#174
  def scope_changing_syntax?(node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#170
  def scoped_node?(node); end
end

# source://rubocop-graphql//lib/rubocop/cop/graphql/unused_argument.rb#69
RuboCop::Cop::GraphQL::UnusedArgument::MSG = T.let(T.unsafe(nil), String)

# RuboCop GraphQL project namespace
#
# source://rubocop-graphql//lib/rubocop/graphql/ext/snake_case.rb#4
module RuboCop::GraphQL; end

# source://rubocop-graphql//lib/rubocop/graphql/argument.rb#5
class RuboCop::GraphQL::Argument
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Argument] a new instance of Argument
  #
  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#25
  def initialize(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#19
  def argument_as(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#9
  def argument_description(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#14
  def argument_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#33
  def as; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#45
  def block; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#37
  def description; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#41
  def kwargs; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#29
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop-graphql//lib/rubocop/graphql/argument.rb#23
  def node; end
end

# source://rubocop-graphql//lib/rubocop/graphql/argument/block.rb#6
class RuboCop::GraphQL::Argument::Block
  include ::RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Block] a new instance of Block
  #
  # source://rubocop-graphql//lib/rubocop/graphql/argument/block.rb#19
  def initialize(argument_node); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/block.rb#11
  def argument_block(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/block.rb#23
  def description; end
end

# source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#6
class RuboCop::GraphQL::Argument::Kwargs
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Kwargs] a new instance of Kwargs
  #
  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#39
  def initialize(argument_node); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#10
  def argument_kwargs(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#55
  def as; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#30
  def as_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#47
  def camelize; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#35
  def camelize_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#43
  def description; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#20
  def description_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#51
  def loads; end

  # source://rubocop-graphql//lib/rubocop/graphql/argument/kwargs.rb#25
  def loads_kwarg?(param0 = T.unsafe(nil)); end
end

# source://rubocop-graphql//lib/rubocop/graphql.rb#8
RuboCop::GraphQL::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-graphql//lib/rubocop/graphql.rb#7
RuboCop::GraphQL::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# source://rubocop-graphql//lib/rubocop/graphql/class.rb#5
class RuboCop::GraphQL::Class
  # @return [Class] a new instance of Class
  #
  # source://rubocop-graphql//lib/rubocop/graphql/class.rb#8
  def initialize(node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/class.rb#12
  def nested?; end

  # Returns the value of attribute node.
  #
  # source://rubocop-graphql//lib/rubocop/graphql/class.rb#6
  def node; end
end

# source://rubocop-graphql//lib/rubocop/graphql/compare_order.rb#5
module RuboCop::GraphQL::CompareOrder
  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/compare_order.rb#6
  def correct_order?(previous, current); end

  # source://rubocop-graphql//lib/rubocop/graphql/compare_order.rb#34
  def order_index(field, order); end
end

# Matches a variety of description formats commonly seen in Rails applications
#
#   description 'blah'
#
#   description "blah"
#
#   description <<~EOT
#      blah
#      bloop
#   EOT
#
#   description <<-EOT.squish
#      blah
#      bloop
#   EOT
#
# source://rubocop-graphql//lib/rubocop/graphql/description_method.rb#20
module RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-graphql//lib/rubocop/graphql/description_method.rb#26
  def description_method_call?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/description_method.rb#31
  def description_with_block_arg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/description_method.rb#35
  def find_description_method(nodes); end
end

# source://rubocop-graphql//lib/rubocop/graphql/description_method.rb#23
RuboCop::GraphQL::DescriptionMethod::DESCRIPTION_STRING = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/rubocop/graphql/ext/snake_case.rb#5
module RuboCop::GraphQL::Ext; end

# source://rubocop-graphql//lib/rubocop/graphql/ext/snake_case.rb#6
module RuboCop::GraphQL::Ext::SnakeCase; end

# source://rubocop-graphql//lib/rubocop/graphql/ext/snake_case.rb#7
RuboCop::GraphQL::Ext::SnakeCase::SNAKE_CASE = T.let(T.unsafe(nil), Regexp)

# source://rubocop-graphql//lib/rubocop/graphql/field.rb#5
class RuboCop::GraphQL::Field
  extend ::Forwardable
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Field] a new instance of Field
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#41
  def initialize(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#72
  def block; end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#60
  def description; end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#35
  def field_description(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#24
  def field_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#29
  def field_with_body_name(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#68
  def kwargs; end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#45
  def name; end

  # Returns the value of attribute node.
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#39
  def node; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def parent(*args, **_arg1, &block); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#64
  def resolver_method_name; end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#76
  def schema_member; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def sibling_index(*args, **_arg1, &block); end

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#49
  def underscore_name; end

  private

  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#82
  def root_node; end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#86
  def root_node?(node); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field.rb#93
  def root_with_siblings?(node); end
end

# source://rubocop-graphql//lib/rubocop/graphql/field/block.rb#6
class RuboCop::GraphQL::Field::Block
  include ::RuboCop::GraphQL::DescriptionMethod
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Block] a new instance of Block
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field/block.rb#19
  def initialize(field_node); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/block.rb#23
  def description; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/block.rb#11
  def field_block(param0 = T.unsafe(nil)); end
end

# source://rubocop-graphql//lib/rubocop/graphql/field.rb#17
RuboCop::GraphQL::Field::CONFLICT_FIELD_NAMES = T.let(T.unsafe(nil), Set)

# source://rubocop-graphql//lib/rubocop/graphql/field.rb#15
RuboCop::GraphQL::Field::GRAPHQL_RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#6
class RuboCop::GraphQL::Field::Kwargs
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Kwargs] a new instance of Kwargs
  #
  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#54
  def initialize(field_node); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#66
  def alias; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#30
  def alias_kwarg(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#70
  def camelize; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#50
  def camelize_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#78
  def description; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#40
  def description_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#10
  def field_kwargs(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#74
  def hash_key; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#35
  def hash_key_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#62
  def method; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#25
  def method_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#58
  def resolver; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#20
  def resolver_kwarg?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#82
  def resolver_method_name; end

  # source://rubocop-graphql//lib/rubocop/graphql/field/kwargs.rb#45
  def resolver_method_option(param0 = T.unsafe(nil)); end
end

# These constants were extracted from graphql-ruby in lib/graphql/schema/member/has_fields.rb
#
# source://rubocop-graphql//lib/rubocop/graphql/field.rb#10
RuboCop::GraphQL::Field::RUBY_KEYWORDS = T.let(T.unsafe(nil), Array)

# source://rubocop-graphql//lib/rubocop/graphql/heredoc.rb#5
module RuboCop::GraphQL::Heredoc
  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/heredoc.rb#6
  def heredoc?(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/heredoc.rb#10
  def range_including_heredoc(node); end
end

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-graphql//lib/rubocop/graphql/inject.rb#7
module RuboCop::GraphQL::Inject
  class << self
    # source://rubocop-graphql//lib/rubocop/graphql/inject.rb#8
    def defaults!; end
  end
end

# source://rubocop-graphql//lib/rubocop/graphql/node_pattern.rb#5
module RuboCop::GraphQL::NodePattern
  extend ::RuboCop::AST::NodePattern::Macros

  # source://rubocop-graphql//lib/rubocop/graphql/node_pattern.rb#22
  def argument?(param0 = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/node_pattern.rb#26
  def field?(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/node_pattern.rb#9
  def field_definition?(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/node_pattern.rb#14
  def field_definition_with_body?(param0 = T.unsafe(nil)); end
end

# Shared methods to check duplicated definitions
#
# source://rubocop-graphql//lib/rubocop/graphql/node_uniqueness.rb#6
module RuboCop::GraphQL::NodeUniqueness
  # source://rubocop-graphql//lib/rubocop/graphql/node_uniqueness.rb#7
  def current_class_full_name(node); end
end

# source://rubocop-graphql//lib/rubocop/graphql.rb#6
RuboCop::GraphQL::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#5
class RuboCop::GraphQL::SchemaMember
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [SchemaMember] a new instance of SchemaMember
  #
  # source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#15
  def initialize(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#23
  def body; end

  # source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#9
  def class_contents(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#19
  def find_method_definition(method_name); end

  # Returns the value of attribute node.
  #
  # source://rubocop-graphql//lib/rubocop/graphql/schema_member.rb#13
  def node; end
end

# source://rubocop-graphql//lib/rubocop/graphql/sorbet.rb#5
module RuboCop::GraphQL::Sorbet
  extend ::RuboCop::AST::NodePattern::Macros

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/sorbet.rb#13
  def has_sorbet_signature?(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/sorbet.rb#9
  def sorbet_signature(param0 = T.unsafe(nil)); end

  # source://rubocop-graphql//lib/rubocop/graphql/sorbet.rb#17
  def sorbet_signature_for(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-graphql//lib/rubocop/graphql/sorbet.rb#26
  def siblings_in_sequence?(first_node, second_node); end
end

# source://rubocop-graphql//lib/rubocop/graphql/swap_range.rb#5
module RuboCop::GraphQL::SwapRange
  include ::RuboCop::Cop::RangeHelp

  # source://rubocop-graphql//lib/rubocop/graphql/swap_range.rb#16
  def declaration(node); end

  # source://rubocop-graphql//lib/rubocop/graphql/swap_range.rb#25
  def final_end_location(start_node); end

  # source://rubocop-graphql//lib/rubocop/graphql/swap_range.rb#8
  def swap_range(corrector, current, previous); end
end

# source://rubocop-graphql//lib/rubocop/graphql/version.rb#3
RuboCop::GraphQL::VERSION = T.let(T.unsafe(nil), String)

# source://rubocop-graphql//lib/refinements/underscore_string.rb#3
module UnderscoreString; end
