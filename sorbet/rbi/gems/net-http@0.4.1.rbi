# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-http` gem.
# Please instead update this file by running `bin/tapioca gem net-http`.


# \Class \Net::HTTP provides a rich library that implements the client
# in a client-server model that uses the \HTTP request-response protocol.
# For information about \HTTP, see:
#
# - {Hypertext Transfer Protocol}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol].
# - {Technical overview}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Technical_overview].
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Strategies
#
# - If you will make only a few GET requests,
#   consider using {OpenURI}[https://docs.ruby-lang.org/en/master/OpenURI.html].
# - If you will make only a few requests of all kinds,
#   consider using the various singleton convenience methods in this class.
#   Each of the following methods automatically starts and finishes
#   a {session}[rdoc-ref:Net::HTTP@Sessions] that sends a single request:
#
#     # Return string response body.
#     Net::HTTP.get(hostname, path)
#     Net::HTTP.get(uri)
#
#     # Write string response body to $stdout.
#     Net::HTTP.get_print(hostname, path)
#     Net::HTTP.get_print(uri)
#
#     # Return response as Net::HTTPResponse object.
#     Net::HTTP.get_response(hostname, path)
#     Net::HTTP.get_response(uri)
#     data = '{"title": "foo", "body": "bar", "userId": 1}'
#     Net::HTTP.post(uri, data)
#     params = {title: 'foo', body: 'bar', userId: 1}
#     Net::HTTP.post_form(uri, params)
#
# - If performance is important, consider using sessions, which lower request overhead.
#   This {session}[rdoc-ref:Net::HTTP@Sessions] has multiple requests for
#   {HTTP methods}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods]
#   and {WebDAV methods}[https://en.wikipedia.org/wiki/WebDAV#Implementation]:
#
#     Net::HTTP.start(hostname) do |http|
#       # Session started automatically before block execution.
#       http.get(path)
#       http.head(path)
#       body = 'Some text'
#       http.post(path, body)  # Can also have a block.
#       http.put(path, body)
#       http.delete(path)
#       http.options(path)
#       http.trace(path)
#       http.patch(path, body) # Can also have a block.
#       http.copy(path)
#       http.lock(path, body)
#       http.mkcol(path, body)
#       http.move(path)
#       http.propfind(path, body)
#       http.proppatch(path, body)
#       http.unlock(path, body)
#       # Session finished automatically at block exit.
#     end
#
# The methods cited above are convenience methods that, via their few arguments,
# allow minimal control over the requests.
# For greater control, consider using {request objects}[rdoc-ref:Net::HTTPRequest].
#
# == URIs
#
# On the internet, a URI
# ({Universal Resource Identifier}[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier])
# is a string that identifies a particular resource.
# It consists of some or all of: scheme, hostname, path, query, and fragment;
# see {URI syntax}[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Syntax].
#
# A Ruby {URI::Generic}[https://docs.ruby-lang.org/en/master/URI/Generic.html] object
# represents an internet URI.
# It provides, among others, methods
# +scheme+, +hostname+, +path+, +query+, and +fragment+.
#
# === Schemes
#
# An internet \URI has
# a {scheme}[https://en.wikipedia.org/wiki/List_of_URI_schemes].
#
# The two schemes supported in \Net::HTTP are <tt>'https'</tt> and <tt>'http'</tt>:
#
#   uri.scheme                       # => "https"
#   URI('http://example.com').scheme # => "http"
#
# === Hostnames
#
# A hostname identifies a server (host) to which requests may be sent:
#
#   hostname = uri.hostname # => "jsonplaceholder.typicode.com"
#   Net::HTTP.start(hostname) do |http|
#     # Some HTTP stuff.
#   end
#
# === Paths
#
# A host-specific path identifies a resource on the host:
#
#   _uri = uri.dup
#   _uri.path = '/todos/1'
#   hostname = _uri.hostname
#   path = _uri.path
#   Net::HTTP.get(hostname, path)
#
# === Queries
#
# A host-specific query adds name/value pairs to the URI:
#
#   _uri = uri.dup
#   params = {userId: 1, completed: false}
#   _uri.query = URI.encode_www_form(params)
#   _uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com?userId=1&completed=false>
#   Net::HTTP.get(_uri)
#
# === Fragments
#
# A {URI fragment}[https://en.wikipedia.org/wiki/URI_fragment] has no effect
# in \Net::HTTP;
# the same data is returned, regardless of whether a fragment is included.
#
# == Request Headers
#
# Request headers may be used to pass additional information to the host,
# similar to arguments passed in a method call;
# each header is a name/value pair.
#
# Each of the \Net::HTTP methods that sends a request to the host
# has optional argument +headers+,
# where the headers are expressed as a hash of field-name/value pairs:
#
#   headers = {Accept: 'application/json', Connection: 'Keep-Alive'}
#   Net::HTTP.get(uri, headers)
#
# See lists of both standard request fields and common request fields at
# {Request Fields}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields].
# A host may also accept other custom fields.
#
# == \HTTP Sessions
#
# A _session_ is a connection between a server (host) and a client that:
#
# - Is begun by instance method Net::HTTP#start.
# - May contain any number of requests.
# - Is ended by instance method Net::HTTP#finish.
#
# See example sessions at {Strategies}[rdoc-ref:Net::HTTP@Strategies].
#
# === Session Using \Net::HTTP.start
#
# If you have many requests to make to a single host (and port),
# consider using singleton method Net::HTTP.start with a block;
# the method handles the session automatically by:
#
# - Calling #start before block execution.
# - Executing the block.
# - Calling #finish after block execution.
#
# In the block, you can use these instance methods,
# each of which that sends a single request:
#
# - {HTTP methods}[https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods]:
#
#   - #get, #request_get: GET.
#   - #head, #request_head: HEAD.
#   - #post, #request_post: POST.
#   - #delete: DELETE.
#   - #options: OPTIONS.
#   - #trace: TRACE.
#   - #patch: PATCH.
#
# - {WebDAV methods}[https://en.wikipedia.org/wiki/WebDAV#Implementation]:
#
#   - #copy: COPY.
#   - #lock: LOCK.
#   - #mkcol: MKCOL.
#   - #move: MOVE.
#   - #propfind: PROPFIND.
#   - #proppatch: PROPPATCH.
#   - #unlock: UNLOCK.
#
# === Session Using \Net::HTTP.start and \Net::HTTP.finish
#
# You can manage a session manually using methods #start and #finish:
#
#   http = Net::HTTP.new(hostname)
#   http.start
#   http.get('/todos/1')
#   http.get('/todos/2')
#   http.delete('/posts/1')
#   http.finish # Needed to free resources.
#
# === Single-Request Session
#
# Certain convenience methods automatically handle a session by:
#
# - Creating an \HTTP object
# - Starting a session.
# - Sending a single request.
# - Finishing the session.
# - Destroying the object.
#
# Such methods that send GET requests:
#
# - ::get: Returns the string response body.
# - ::get_print: Writes the string response body to $stdout.
# - ::get_response: Returns a Net::HTTPResponse object.
#
# Such methods that send POST requests:
#
# - ::post: Posts data to the host.
# - ::post_form: Posts form data to the host.
#
# == \HTTP Requests and Responses
#
# Many of the methods above are convenience methods,
# each of which sends a request and returns a string
# without directly using \Net::HTTPRequest and \Net::HTTPResponse objects.
#
# You can, however, directly create a request object, send the request,
# and retrieve the response object; see:
#
# - Net::HTTPRequest.
# - Net::HTTPResponse.
#
# == Following Redirection
#
# Each returned response is an instance of a subclass of Net::HTTPResponse.
# See the {response class hierarchy}[rdoc-ref:Net::HTTPResponse@Response+Subclasses].
#
# In particular, class Net::HTTPRedirection is the parent
# of all redirection classes.
# This allows you to craft a case statement to handle redirections properly:
#
#   def fetch(uri, limit = 10)
#     # You should choose a better exception.
#     raise ArgumentError, 'Too many HTTP redirects' if limit == 0
#
#     res = Net::HTTP.get_response(URI(uri))
#     case res
#     when Net::HTTPSuccess     # Any success class.
#       res
#     when Net::HTTPRedirection # Any redirection class.
#       location = res['Location']
#       warn "Redirected to #{location}"
#       fetch(location, limit - 1)
#     else                      # Any other class.
#       res.value
#     end
#   end
#
#   fetch(uri)
#
# == Basic Authentication
#
# Basic authentication is performed according to
# {RFC2617}[http://www.ietf.org/rfc/rfc2617.txt]:
#
#   req = Net::HTTP::Get.new(uri)
#   req.basic_auth('user', 'pass')
#   res = Net::HTTP.start(hostname) do |http|
#     http.request(req)
#   end
#
# == Streaming Response Bodies
#
# By default \Net::HTTP reads an entire response into memory.  If you are
# handling large files or wish to implement a progress bar you can instead
# stream the body directly to an IO.
#
#   Net::HTTP.start(hostname) do |http|
#     req = Net::HTTP::Get.new(uri)
#     http.request(req) do |res|
#       open('t.tmp', 'w') do |f|
#         res.read_body do |chunk|
#           f.write chunk
#         end
#       end
#     end
#   end
#
# == HTTPS
#
# HTTPS is enabled for an \HTTP connection by Net::HTTP#use_ssl=:
#
#   Net::HTTP.start(hostname, :use_ssl => true) do |http|
#     req = Net::HTTP::Get.new(uri)
#     res = http.request(req)
#   end
#
# Or if you simply want to make a GET request, you may pass in a URI
# object that has an \HTTPS URL. \Net::HTTP automatically turns on TLS
# verification if the URI object has a 'https' URI scheme:
#
#   uri # => #<URI::HTTPS https://jsonplaceholder.typicode.com/>
#   Net::HTTP.get(uri)
#
# == Proxy Server
#
# An \HTTP object can have
# a {proxy server}[https://en.wikipedia.org/wiki/Proxy_server].
#
# You can create an \HTTP object with a proxy server
# using method Net::HTTP.new or method Net::HTTP.start.
#
# The proxy may be defined either by argument +p_addr+
# or by environment variable <tt>'http_proxy'</tt>.
#
# === Proxy Using Argument +p_addr+ as a \String
#
# When argument +p_addr+ is a string hostname,
# the returned +http+ has the given host as its proxy:
#
#   http = Net::HTTP.new(hostname, nil, 'proxy.example')
#   http.proxy?          # => true
#   http.proxy_from_env? # => false
#   http.proxy_address   # => "proxy.example"
#   # These use default values.
#   http.proxy_port      # => 80
#   http.proxy_user      # => nil
#   http.proxy_pass      # => nil
#
# The port, username, and password for the proxy may also be given:
#
#   http = Net::HTTP.new(hostname, nil, 'proxy.example', 8000, 'pname', 'ppass')
#   # => #<Net::HTTP jsonplaceholder.typicode.com:80 open=false>
#   http.proxy?          # => true
#   http.proxy_from_env? # => false
#   http.proxy_address   # => "proxy.example"
#   http.proxy_port      # => 8000
#   http.proxy_user      # => "pname"
#   http.proxy_pass      # => "ppass"
#
# === Proxy Using '<tt>ENV['http_proxy']</tt>'
#
# When environment variable <tt>'http_proxy'</tt>
# is set to a \URI string,
# the returned +http+ will have the server at that URI as its proxy;
# note that the \URI string must have a protocol
# such as <tt>'http'</tt> or <tt>'https'</tt>:
#
#   ENV['http_proxy'] = 'http://example.com'
#   http = Net::HTTP.new(hostname)
#   http.proxy?          # => true
#   http.proxy_from_env? # => true
#   http.proxy_address   # => "example.com"
#   # These use default values.
#   http.proxy_port      # => 80
#   http.proxy_user      # => nil
#   http.proxy_pass      # => nil
#
# The \URI string may include proxy username, password, and port number:
#
#   ENV['http_proxy'] = 'http://pname:ppass@example.com:8000'
#   http = Net::HTTP.new(hostname)
#   http.proxy?          # => true
#   http.proxy_from_env? # => true
#   http.proxy_address   # => "example.com"
#   http.proxy_port      # => 8000
#   http.proxy_user      # => "pname"
#   http.proxy_pass      # => "ppass"
#
# === Filtering Proxies
#
# With method Net::HTTP.new (but not Net::HTTP.start),
# you can use argument +p_no_proxy+ to filter proxies:
#
# - Reject a certain address:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
#     http.proxy_address # => nil
#
# - Reject certain domains or subdomains:
#
#     http = Net::HTTP.new('example.com', nil, 'my.proxy.example', 8000, 'pname', 'ppass', 'proxy.example')
#     http.proxy_address # => nil
#
# - Reject certain addresses and port combinations:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:1234')
#     http.proxy_address # => "proxy.example"
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'proxy.example:8000')
#     http.proxy_address # => nil
#
# - Reject a list of the types above delimited using a comma:
#
#     http = Net::HTTP.new('example.com', nil, 'proxy.example', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
#     http.proxy_address # => nil
#
#     http = Net::HTTP.new('example.com', nil, 'my.proxy', 8000, 'pname', 'ppass', 'my.proxy,proxy.example:8000')
#     http.proxy_address # => nil
#
# == Compression and Decompression
#
# \Net::HTTP does not compress the body of a request before sending.
#
# By default, \Net::HTTP adds header <tt>'Accept-Encoding'</tt>
# to a new {request object}[rdoc-ref:Net::HTTPRequest]:
#
#   Net::HTTP::Get.new(uri)['Accept-Encoding']
#   # => "gzip;q=1.0,deflate;q=0.6,identity;q=0.3"
#
# This requests the server to zip-encode the response body if there is one;
# the server is not required to do so.
#
# \Net::HTTP does not automatically decompress a response body
# if the response has header <tt>'Content-Range'</tt>.
#
# Otherwise decompression (or not) depends on the value of header
# {Content-Encoding}[https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#content-encoding-response-header]:
#
# - <tt>'deflate'</tt>, <tt>'gzip'</tt>, or <tt>'x-gzip'</tt>:
#   decompresses the body and deletes the header.
# - <tt>'none'</tt> or <tt>'identity'</tt>:
#   does not decompress the body, but deletes the header.
# - Any other value:
#   leaves the body and header unchanged.
#
# == What's Here
#
# This is a categorized summary of methods and attributes.
#
# === \Net::HTTP Objects
#
# - {::new}[rdoc-ref:Net::HTTP.new]:
#   Creates a new instance.
# - {#inspect}[rdoc-ref:Net::HTTP#inspect]:
#   Returns a string representation of +self+.
#
# === Sessions
#
# - {::start}[rdoc-ref:Net::HTTP.start]:
#   Begins a new session in a new \Net::HTTP object.
# - {#started?}[rdoc-ref:Net::HTTP#started?]
#   (aliased as {#active?}[rdoc-ref:Net::HTTP#active?]):
#   Returns whether in a session.
# - {#finish}[rdoc-ref:Net::HTTP#finish]:
#   Ends an active session.
# - {#start}[rdoc-ref:Net::HTTP#start]:
#   Begins a new session in an existing \Net::HTTP object (+self+).
#
# === Connections
#
# - {:continue_timeout}[rdoc-ref:Net::HTTP#continue_timeout]:
#   Returns the continue timeout.
# - {#continue_timeout=}[rdoc-ref:Net::HTTP#continue_timeout=]:
#   Sets the continue timeout seconds.
# - {:keep_alive_timeout}[rdoc-ref:Net::HTTP#keep_alive_timeout]:
#   Returns the keep-alive timeout.
# - {:keep_alive_timeout=}[rdoc-ref:Net::HTTP#keep_alive_timeout=]:
#   Sets the keep-alive timeout.
# - {:max_retries}[rdoc-ref:Net::HTTP#max_retries]:
#   Returns the maximum retries.
# - {#max_retries=}[rdoc-ref:Net::HTTP#max_retries=]:
#   Sets the maximum retries.
# - {:open_timeout}[rdoc-ref:Net::HTTP#open_timeout]:
#   Returns the open timeout.
# - {:open_timeout=}[rdoc-ref:Net::HTTP#open_timeout=]:
#   Sets the open timeout.
# - {:read_timeout}[rdoc-ref:Net::HTTP#read_timeout]:
#   Returns the open timeout.
# - {:read_timeout=}[rdoc-ref:Net::HTTP#read_timeout=]:
#   Sets the read timeout.
# - {:ssl_timeout}[rdoc-ref:Net::HTTP#ssl_timeout]:
#   Returns the ssl timeout.
# - {:ssl_timeout=}[rdoc-ref:Net::HTTP#ssl_timeout=]:
#   Sets the ssl timeout.
# - {:write_timeout}[rdoc-ref:Net::HTTP#write_timeout]:
#   Returns the write timeout.
# - {write_timeout=}[rdoc-ref:Net::HTTP#write_timeout=]:
#   Sets the write timeout.
#
# === Requests
#
# - {::get}[rdoc-ref:Net::HTTP.get]:
#   Sends a GET request and returns the string response body.
# - {::get_print}[rdoc-ref:Net::HTTP.get_print]:
#   Sends a GET request and write the string response body to $stdout.
# - {::get_response}[rdoc-ref:Net::HTTP.get_response]:
#   Sends a GET request and returns a response object.
# - {::post_form}[rdoc-ref:Net::HTTP.post_form]:
#   Sends a POST request with form data and returns a response object.
# - {::post}[rdoc-ref:Net::HTTP.post]:
#   Sends a POST request with data and returns a response object.
# - {#copy}[rdoc-ref:Net::HTTP#copy]:
#   Sends a COPY request and returns a response object.
# - {#delete}[rdoc-ref:Net::HTTP#delete]:
#   Sends a DELETE request and returns a response object.
# - {#get}[rdoc-ref:Net::HTTP#get]:
#   Sends a GET request and returns a response object.
# - {#head}[rdoc-ref:Net::HTTP#head]:
#   Sends a HEAD request and returns a response object.
# - {#lock}[rdoc-ref:Net::HTTP#lock]:
#   Sends a LOCK request and returns a response object.
# - {#mkcol}[rdoc-ref:Net::HTTP#mkcol]:
#   Sends a MKCOL request and returns a response object.
# - {#move}[rdoc-ref:Net::HTTP#move]:
#   Sends a MOVE request and returns a response object.
# - {#options}[rdoc-ref:Net::HTTP#options]:
#   Sends a OPTIONS request and returns a response object.
# - {#patch}[rdoc-ref:Net::HTTP#patch]:
#   Sends a PATCH request and returns a response object.
# - {#post}[rdoc-ref:Net::HTTP#post]:
#   Sends a POST request and returns a response object.
# - {#propfind}[rdoc-ref:Net::HTTP#propfind]:
#   Sends a PROPFIND request and returns a response object.
# - {#proppatch}[rdoc-ref:Net::HTTP#proppatch]:
#   Sends a PROPPATCH request and returns a response object.
# - {#put}[rdoc-ref:Net::HTTP#put]:
#   Sends a PUT request and returns a response object.
# - {#request}[rdoc-ref:Net::HTTP#request]:
#   Sends a request and returns a response object.
# - {#request_get}[rdoc-ref:Net::HTTP#request_get]
#   (aliased as {#get2}[rdoc-ref:Net::HTTP#get2]):
#   Sends a GET request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#request_head}[rdoc-ref:Net::HTTP#request_head]
#   (aliased as {#head2}[rdoc-ref:Net::HTTP#head2]):
#   Sends a HEAD request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#request_post}[rdoc-ref:Net::HTTP#request_post]
#   (aliased as {#post2}[rdoc-ref:Net::HTTP#post2]):
#   Sends a POST request and forms a response object;
#   if a block given, calls the block with the object,
#   otherwise returns the object.
# - {#send_request}[rdoc-ref:Net::HTTP#send_request]:
#   Sends a request and returns a response object.
# - {#trace}[rdoc-ref:Net::HTTP#trace]:
#   Sends a TRACE request and returns a response object.
# - {#unlock}[rdoc-ref:Net::HTTP#unlock]:
#   Sends an UNLOCK request and returns a response object.
#
# === Responses
#
# - {:close_on_empty_response}[rdoc-ref:Net::HTTP#close_on_empty_response]:
#   Returns whether to close connection on empty response.
# - {:close_on_empty_response=}[rdoc-ref:Net::HTTP#close_on_empty_response=]:
#   Sets whether to close connection on empty response.
# - {:ignore_eof}[rdoc-ref:Net::HTTP#ignore_eof]:
#   Returns whether to ignore end-of-file when reading a response body
#   with <tt>Content-Length</tt> headers.
# - {:ignore_eof=}[rdoc-ref:Net::HTTP#ignore_eof=]:
#   Sets whether to ignore end-of-file when reading a response body
#   with <tt>Content-Length</tt> headers.
# - {:response_body_encoding}[rdoc-ref:Net::HTTP#response_body_encoding]:
#   Returns the encoding to use for the response body.
# - {#response_body_encoding=}[rdoc-ref:Net::HTTP#response_body_encoding=]:
#   Sets the response body encoding.
#
# === Proxies
#
# - {:proxy_address}[rdoc-ref:Net::HTTP#proxy_address]:
#   Returns the proxy address.
# - {:proxy_address=}[rdoc-ref:Net::HTTP#proxy_address=]:
#   Sets the proxy address.
# - {::proxy_class?}[rdoc-ref:Net::HTTP.proxy_class?]:
#   Returns whether +self+ is a proxy class.
# - {#proxy?}[rdoc-ref:Net::HTTP#proxy?]:
#   Returns whether +self+ has a proxy.
# - {#proxy_address}[rdoc-ref:Net::HTTP#proxy_address]
#   (aliased as {#proxyaddr}[rdoc-ref:Net::HTTP#proxyaddr]):
#   Returns the proxy address.
# - {#proxy_from_env?}[rdoc-ref:Net::HTTP#proxy_from_env?]:
#   Returns whether the proxy is taken from an environment variable.
# - {:proxy_from_env=}[rdoc-ref:Net::HTTP#proxy_from_env=]:
#   Sets whether the proxy is to be taken from an environment variable.
# - {:proxy_pass}[rdoc-ref:Net::HTTP#proxy_pass]:
#   Returns the proxy password.
# - {:proxy_pass=}[rdoc-ref:Net::HTTP#proxy_pass=]:
#   Sets the proxy password.
# - {:proxy_port}[rdoc-ref:Net::HTTP#proxy_port]:
#   Returns the proxy port.
# - {:proxy_port=}[rdoc-ref:Net::HTTP#proxy_port=]:
#   Sets the proxy port.
# - {#proxy_user}[rdoc-ref:Net::HTTP#proxy_user]:
#   Returns the proxy user name.
# - {:proxy_user=}[rdoc-ref:Net::HTTP#proxy_user=]:
#   Sets the proxy user.
#
# === Security
#
# - {:ca_file}[rdoc-ref:Net::HTTP#ca_file]:
#   Returns the path to a CA certification file.
# - {:ca_file=}[rdoc-ref:Net::HTTP#ca_file=]:
#   Sets the path to a CA certification file.
# - {:ca_path}[rdoc-ref:Net::HTTP#ca_path]:
#   Returns the path of to CA directory containing certification files.
# - {:ca_path=}[rdoc-ref:Net::HTTP#ca_path=]:
#   Sets the path of to CA directory containing certification files.
# - {:cert}[rdoc-ref:Net::HTTP#cert]:
#   Returns the OpenSSL::X509::Certificate object to be used for client certification.
# - {:cert=}[rdoc-ref:Net::HTTP#cert=]:
#   Sets the OpenSSL::X509::Certificate object to be used for client certification.
# - {:cert_store}[rdoc-ref:Net::HTTP#cert_store]:
#   Returns the X509::Store to be used for verifying peer certificate.
# - {:cert_store=}[rdoc-ref:Net::HTTP#cert_store=]:
#   Sets the X509::Store to be used for verifying peer certificate.
# - {:ciphers}[rdoc-ref:Net::HTTP#ciphers]:
#   Returns the available SSL ciphers.
# - {:ciphers=}[rdoc-ref:Net::HTTP#ciphers=]:
#   Sets the available SSL ciphers.
# - {:extra_chain_cert}[rdoc-ref:Net::HTTP#extra_chain_cert]:
#   Returns the extra X509 certificates to be added to the certificate chain.
# - {:extra_chain_cert=}[rdoc-ref:Net::HTTP#extra_chain_cert=]:
#   Sets the extra X509 certificates to be added to the certificate chain.
# - {:key}[rdoc-ref:Net::HTTP#key]:
#   Returns the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
# - {:key=}[rdoc-ref:Net::HTTP#key=]:
#   Sets the OpenSSL::PKey::RSA or OpenSSL::PKey::DSA object.
# - {:max_version}[rdoc-ref:Net::HTTP#max_version]:
#   Returns the maximum SSL version.
# - {:max_version=}[rdoc-ref:Net::HTTP#max_version=]:
#   Sets the maximum SSL version.
# - {:min_version}[rdoc-ref:Net::HTTP#min_version]:
#   Returns the minimum SSL version.
# - {:min_version=}[rdoc-ref:Net::HTTP#min_version=]:
#   Sets the minimum SSL version.
# - {#peer_cert}[rdoc-ref:Net::HTTP#peer_cert]:
#   Returns the X509 certificate chain for the session's socket peer.
# - {:ssl_version}[rdoc-ref:Net::HTTP#ssl_version]:
#   Returns the SSL version.
# - {:ssl_version=}[rdoc-ref:Net::HTTP#ssl_version=]:
#   Sets the SSL version.
# - {#use_ssl=}[rdoc-ref:Net::HTTP#use_ssl=]:
#   Sets whether a new session is to use Transport Layer Security.
# - {#use_ssl?}[rdoc-ref:Net::HTTP#use_ssl?]:
#   Returns whether +self+ uses SSL.
# - {:verify_callback}[rdoc-ref:Net::HTTP#verify_callback]:
#   Returns the callback for the server certification verification.
# - {:verify_callback=}[rdoc-ref:Net::HTTP#verify_callback=]:
#   Sets the callback for the server certification verification.
# - {:verify_depth}[rdoc-ref:Net::HTTP#verify_depth]:
#   Returns the maximum depth for the certificate chain verification.
# - {:verify_depth=}[rdoc-ref:Net::HTTP#verify_depth=]:
#   Sets the maximum depth for the certificate chain verification.
# - {:verify_hostname}[rdoc-ref:Net::HTTP#verify_hostname]:
#   Returns the flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_hostname=}[rdoc-ref:Net::HTTP#verify_hostname=]:
#   Sets he flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_mode}[rdoc-ref:Net::HTTP#verify_mode]:
#   Returns the flags for server the certification verification at the beginning of the SSL/TLS session.
# - {:verify_mode=}[rdoc-ref:Net::HTTP#verify_mode=]:
#   Sets the flags for server the certification verification at the beginning of the SSL/TLS session.
#
# === Addresses and Ports
#
# - {:address}[rdoc-ref:Net::HTTP#address]:
#   Returns the string host name or host IP.
# - {::default_port}[rdoc-ref:Net::HTTP.default_port]:
#   Returns integer 80, the default port to use for HTTP requests.
# - {::http_default_port}[rdoc-ref:Net::HTTP.http_default_port]:
#   Returns integer 80, the default port to use for HTTP requests.
# - {::https_default_port}[rdoc-ref:Net::HTTP.https_default_port]:
#   Returns integer 443, the default port to use for HTTPS requests.
# - {#ipaddr}[rdoc-ref:Net::HTTP#ipaddr]:
#   Returns the IP address for the connection.
# - {#ipaddr=}[rdoc-ref:Net::HTTP#ipaddr=]:
#   Sets the IP address for the connection.
# - {:local_host}[rdoc-ref:Net::HTTP#local_host]:
#   Returns the string local host used to establish the connection.
# - {:local_host=}[rdoc-ref:Net::HTTP#local_host=]:
#   Sets the string local host used to establish the connection.
# - {:local_port}[rdoc-ref:Net::HTTP#local_port]:
#   Returns the integer local port used to establish the connection.
# - {:local_port=}[rdoc-ref:Net::HTTP#local_port=]:
#   Sets the integer local port used to establish the connection.
# - {:port}[rdoc-ref:Net::HTTP#port]:
#   Returns the integer port number.
#
# === \HTTP Version
#
# - {::version_1_2?}[rdoc-ref:Net::HTTP.version_1_2?]
#   (aliased as {::is_version_1_2?}[rdoc-ref:Net::HTTP.is_version_1_2?]
#   and {::version_1_2}[rdoc-ref:Net::HTTP.version_1_2]):
#   Returns true; retained for compatibility.
#
# === Debugging
#
# - {#set_debug_output}[rdoc-ref:Net::HTTP#set_debug_output]:
#   Sets the output stream for debugging.
#
# source://net-http//lib/net/http.rb#722
class Net::HTTP < ::Net::Protocol
  class << self
    # source://net-http//lib/net/http.rb#1065
    # def newobj(address, port = T.unsafe(nil), p_addr = T.unsafe(nil), p_port = T.unsafe(nil), p_user = T.unsafe(nil), p_pass = T.unsafe(nil), p_no_proxy = T.unsafe(nil)); end
  end
end

# Response class for <tt>Already Reported (WebDAV)</tt> responses (status code 208).
#
# The <tt>Already Reported (WebDAV)</tt> response indicates that the server
# has received the request,
# and that the members of a DAV binding have already been enumerated
# in a preceding part of the (multi-status) response,
# and are not being included again.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 5842}[https://www.rfc-editor.org/rfc/rfc5842.html#section-7.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#208].
#
# source://net-http//lib/net/http/responses.rb#306
class Net::HTTPAlreadyReported < ::Net::HTTPSuccess; end

# Response class for <tt>Early Hints</tt> responses (status code 103).
#
# The <tt>Early Hints</tt> indicates that the server has received
# and is processing the request, and contains certain headers;
# the final response is not available yet.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103].
# - {RFC 8297}[https://www.rfc-editor.org/rfc/rfc8297.html#section-2].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#103].
#
# source://net-http//lib/net/http/responses.rb#147
class Net::HTTPEarlyHints < ::Net::HTTPInformation; end

# Response class for <tt>Loop Detected (WebDAV)</tt> responses (status code 508).
#
# The server detected an infinite loop while processing the request.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508].
# - {RFC 5942}[https://www.rfc-editor.org/rfc/rfc5842.html#section-7.2].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#508].
#
# source://net-http//lib/net/http/responses.rb#1061
class Net::HTTPLoopDetected < ::Net::HTTPServerError; end

# Response class for <tt>Misdirected Request</tt> responses (status code 421).
#
# The request was directed at a server that is not able to produce a response.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-421-misdirected-request].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#421].
#
# source://net-http//lib/net/http/responses.rb#776
class Net::HTTPMisdirectedRequest < ::Net::HTTPClientError; end

# Response class for <tt>Not Extended</tt> responses (status code 510).
#
# Further extensions to the request are required for the server to fulfill it.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510].
# - {RFC 2774}[https://www.rfc-editor.org/rfc/rfc2774.html#section-7].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#510].
#
# source://net-http//lib/net/http/responses.rb#1078
class Net::HTTPNotExtended < ::Net::HTTPServerError; end

# Response class for <tt>Payload Too Large</tt> responses (status code 413).
#
# The request is larger than the server is willing or able to process.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-large].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#413].
#
# source://net-http//lib/net/http/responses.rb#688
class Net::HTTPPayloadTooLarge < ::Net::HTTPClientError; end

# Response class for +Processing+ responses (status code 102).
#
# The +Processing+ response indicates that the server has received
# and is processing the request, but no response is available yet.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {RFC 2518}[https://www.rfc-editor.org/rfc/rfc2518#section-10.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#102].
#
# source://net-http//lib/net/http/responses.rb#129
class Net::HTTPProcessing < ::Net::HTTPInformation; end

# Response class for <tt>Range Not Satisfiable</tt> responses (status code 416).
#
# The request entity has a media type which the server or resource does not support.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-416-range-not-satisfiable].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#416].
#
# source://net-http//lib/net/http/responses.rb#739
class Net::HTTPRangeNotSatisfiable < ::Net::HTTPClientError; end

# This class is the base class for \Net::HTTP response classes.
#
# == About the Examples
#
# :include: doc/net-http/examples.rdoc
#
# == Returned Responses
#
# \Method Net::HTTP.get_response returns
# an instance of one of the subclasses of \Net::HTTPResponse:
#
#   Net::HTTP.get_response(uri)
#   # => #<Net::HTTPOK 200 OK readbody=true>
#   Net::HTTP.get_response(hostname, '/nosuch')
#   # => #<Net::HTTPNotFound 404 Not Found readbody=true>
#
# As does method Net::HTTP#request:
#
#   req = Net::HTTP::Get.new(uri)
#   Net::HTTP.start(hostname) do |http|
#     http.request(req)
#   end # => #<Net::HTTPOK 200 OK readbody=true>
#
# \Class \Net::HTTPResponse includes module Net::HTTPHeader,
# which provides access to response header values via (among others):
#
# - \Hash-like method <tt>[]</tt>.
# - Specific reader methods, such as +content_type+.
#
# Examples:
#
#   res = Net::HTTP.get_response(uri) # => #<Net::HTTPOK 200 OK readbody=true>
#   res['Content-Type']               # => "text/html; charset=UTF-8"
#   res.content_type                  # => "text/html"
#
# == Response Subclasses
#
# \Class \Net::HTTPResponse has a subclass for each
# {HTTP status code}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes].
# You can look up the response class for a given code:
#
#   Net::HTTPResponse::CODE_TO_OBJ['200'] # => Net::HTTPOK
#   Net::HTTPResponse::CODE_TO_OBJ['400'] # => Net::HTTPBadRequest
#   Net::HTTPResponse::CODE_TO_OBJ['404'] # => Net::HTTPNotFound
#
# And you can retrieve the status code for a response object:
#
#   Net::HTTP.get_response(uri).code                 # => "200"
#   Net::HTTP.get_response(hostname, '/nosuch').code # => "404"
#
# The response subclasses (indentation shows class hierarchy):
#
# - Net::HTTPUnknownResponse (for unhandled \HTTP extensions).
#
# - Net::HTTPInformation:
#
#   - Net::HTTPContinue (100)
#   - Net::HTTPSwitchProtocol (101)
#   - Net::HTTPProcessing (102)
#   - Net::HTTPEarlyHints (103)
#
# - Net::HTTPSuccess:
#
#   - Net::HTTPOK (200)
#   - Net::HTTPCreated (201)
#   - Net::HTTPAccepted (202)
#   - Net::HTTPNonAuthoritativeInformation (203)
#   - Net::HTTPNoContent (204)
#   - Net::HTTPResetContent (205)
#   - Net::HTTPPartialContent (206)
#   - Net::HTTPMultiStatus (207)
#   - Net::HTTPAlreadyReported (208)
#   - Net::HTTPIMUsed (226)
#
# - Net::HTTPRedirection:
#
#   - Net::HTTPMultipleChoices (300)
#   - Net::HTTPMovedPermanently (301)
#   - Net::HTTPFound (302)
#   - Net::HTTPSeeOther (303)
#   - Net::HTTPNotModified (304)
#   - Net::HTTPUseProxy (305)
#   - Net::HTTPTemporaryRedirect (307)
#   - Net::HTTPPermanentRedirect (308)
#
# - Net::HTTPClientError:
#
#   - Net::HTTPBadRequest (400)
#   - Net::HTTPUnauthorized (401)
#   - Net::HTTPPaymentRequired (402)
#   - Net::HTTPForbidden (403)
#   - Net::HTTPNotFound (404)
#   - Net::HTTPMethodNotAllowed (405)
#   - Net::HTTPNotAcceptable (406)
#   - Net::HTTPProxyAuthenticationRequired (407)
#   - Net::HTTPRequestTimeOut (408)
#   - Net::HTTPConflict (409)
#   - Net::HTTPGone (410)
#   - Net::HTTPLengthRequired (411)
#   - Net::HTTPPreconditionFailed (412)
#   - Net::HTTPRequestEntityTooLarge (413)
#   - Net::HTTPRequestURITooLong (414)
#   - Net::HTTPUnsupportedMediaType (415)
#   - Net::HTTPRequestedRangeNotSatisfiable (416)
#   - Net::HTTPExpectationFailed (417)
#   - Net::HTTPMisdirectedRequest (421)
#   - Net::HTTPUnprocessableEntity (422)
#   - Net::HTTPLocked (423)
#   - Net::HTTPFailedDependency (424)
#   - Net::HTTPUpgradeRequired (426)
#   - Net::HTTPPreconditionRequired (428)
#   - Net::HTTPTooManyRequests (429)
#   - Net::HTTPRequestHeaderFieldsTooLarge (431)
#   - Net::HTTPUnavailableForLegalReasons (451)
#
# - Net::HTTPServerError:
#
#   - Net::HTTPInternalServerError (500)
#   - Net::HTTPNotImplemented (501)
#   - Net::HTTPBadGateway (502)
#   - Net::HTTPServiceUnavailable (503)
#   - Net::HTTPGatewayTimeOut (504)
#   - Net::HTTPVersionNotSupported (505)
#   - Net::HTTPVariantAlsoNegotiates (506)
#   - Net::HTTPInsufficientStorage (507)
#   - Net::HTTPLoopDetected (508)
#   - Net::HTTPNotExtended (510)
#   - Net::HTTPNetworkAuthenticationRequired (511)
#
# There is also the Net::HTTPBadResponse exception which is raised when
# there is a protocol error.
#
# source://net-http//lib/net/http/response.rb#135
class Net::HTTPResponse
  # The HTTP result message sent by the server. For example, 'Not Found'.
  #
  # source://net-http//lib/net/http/response.rb#216
  def msg; end
end

# Response class for <tt>URI Too Long</tt> responses (status code 414).
#
# The URI provided was too long for the server to process.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414].
# - {RFC 9110}[https://www.rfc-editor.org/rfc/rfc9110.html#name-414-uri-too-long].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#414].
#
# source://net-http//lib/net/http/responses.rb#705
class Net::HTTPURITooLong < ::Net::HTTPClientError; end

# Response class for <tt>Variant Also Negotiates</tt> responses (status code 506).
#
# Transparent content negotiation for the request results in a circular reference.
#
# :include: doc/net-http/included_getters.rdoc
#
# References:
#
# - {Mozilla}[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506].
# - {RFC 2295}[https://www.rfc-editor.org/rfc/rfc2295#section-8.1].
# - {Wikipedia}[https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#506].
#
# source://net-http//lib/net/http/responses.rb#1029
class Net::HTTPVariantAlsoNegotiates < ::Net::HTTPServerError; end
