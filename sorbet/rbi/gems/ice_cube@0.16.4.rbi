# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ice_cube` gem.
# Please instead update this file by running `bin/tapioca gem ice_cube`.

# source://ice_cube//lib/ice_cube/deprecated.rb#1
module IceCube
  class << self
    # Retain backwards compatibility for schedules exported from older versions
    # This represents the version number, 11 = 0.11, 1.0 will be 100
    #
    # source://ice_cube//lib/ice_cube.rb#83
    def compatibility; end

    # source://ice_cube//lib/ice_cube.rb#87
    def compatibility=(version); end

    # Defines the format used by IceCube when printing out Schedule#to_s.
    # Defaults to '%B %e, %Y'
    #
    # source://ice_cube//lib/ice_cube.rb#72
    def to_s_time_format; end

    # Sets the format used by IceCube when printing out Schedule#to_s.
    #
    # source://ice_cube//lib/ice_cube.rb#77
    def to_s_time_format=(format); end
  end
end

# An exception for when a count on a Rule is passed
#
# source://ice_cube//lib/ice_cube/errors/count_exceeded.rb#4
class IceCube::CountExceeded < ::StopIteration; end

# source://ice_cube//lib/ice_cube/rules/daily_rule.rb#3
class IceCube::DailyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::DailyInterval

  # @return [DailyRule] a new instance of DailyRule
  #
  # source://ice_cube//lib/ice_cube/rules/daily_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/deprecated.rb#2
module IceCube::Deprecated
  # Deprecate a defined method
  #
  # @param name [Symbol] - name of deprecated method
  # @param replacement [Symbol] - name of the desired replacement
  #
  # source://ice_cube//lib/ice_cube/deprecated.rb#18
  def deprecated(name, replacement); end

  # Define a deprecated alias for a method
  #
  # @param name [Symbol] - name of method to define
  # @param replacement [Symbol] - name of method to replace (alias)
  #
  # source://ice_cube//lib/ice_cube/deprecated.rb#7
  def deprecated_alias(name, replacement); end

  class << self
    # source://ice_cube//lib/ice_cube/deprecated.rb#29
    def schedule_options(schedule, options); end
  end
end

# Find keys by symbol or string without symbolizing user input
# Due to the serialization format of ice_cube, this limited implementation
# is entirely sufficient
#
# source://ice_cube//lib/ice_cube/flexible_hash.rb#9
class IceCube::FlexibleHash < ::SimpleDelegator
  # source://ice_cube//lib/ice_cube/flexible_hash.rb#11
  def [](key); end

  # source://ice_cube//lib/ice_cube/flexible_hash.rb#21
  def delete(key); end

  # source://ice_cube//lib/ice_cube/flexible_hash.rb#16
  def fetch(key); end

  private

  # source://ice_cube//lib/ice_cube/flexible_hash.rb#28
  def _match_key(key); end
end

# source://ice_cube//lib/ice_cube/builders/hash_builder.rb#3
class IceCube::HashBuilder
  # @return [HashBuilder] a new instance of HashBuilder
  #
  # source://ice_cube//lib/ice_cube/builders/hash_builder.rb#5
  def initialize(rule = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/builders/hash_builder.rb#13
  def []=(key, value); end

  # source://ice_cube//lib/ice_cube/builders/hash_builder.rb#21
  def to_hash; end

  # source://ice_cube//lib/ice_cube/builders/hash_builder.rb#9
  def validations; end

  # source://ice_cube//lib/ice_cube/builders/hash_builder.rb#17
  def validations_array(type); end
end

# source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#2
class IceCube::HashParser
  # @return [HashParser] a new instance of HashParser
  #
  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#6
  def initialize(original_hash); end

  # Returns the value of attribute hash.
  #
  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#4
  def hash; end

  # @yield [schedule]
  #
  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#10
  def to_schedule; end

  private

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#43
  def apply_duration(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#48
  def apply_end_time(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#62
  def apply_exrules(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#79
  def apply_extimes(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#53
  def apply_rrules(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#72
  def apply_rtimes(schedule, data); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#25
  def normalize_keys(hash); end

  # source://ice_cube//lib/ice_cube/parsers/hash_parser.rb#86
  def parse_time(time); end
end

# source://ice_cube//lib/ice_cube/rules/hourly_rule.rb#3
class IceCube::HourlyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::DayOfYear
  include ::IceCube::Validations::HourlyInterval

  # @return [HourlyRule] a new instance of HourlyRule
  #
  # source://ice_cube//lib/ice_cube/rules/hourly_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/i18n.rb#4
module IceCube::I18n
  class << self
    # source://ice_cube//lib/ice_cube/i18n.rb#12
    def backend; end

    # source://ice_cube//lib/ice_cube/i18n.rb#16
    def detect_backend!; end

    # source://ice_cube//lib/ice_cube/i18n.rb#9
    def l(*_arg0, **_arg1, &_arg2); end

    # source://ice_cube//lib/ice_cube/i18n.rb#9
    def t(*_arg0, **_arg1, &_arg2); end
  end
end

# source://ice_cube//lib/ice_cube/i18n.rb#6
IceCube::I18n::LOCALES_PATH = T.let(T.unsafe(nil), String)

# source://ice_cube//lib/ice_cube/builders/ical_builder.rb#3
class IceCube::IcalBuilder
  # @return [IcalBuilder] a new instance of IcalBuilder
  #
  # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#7
  def initialize; end

  # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#15
  def [](key); end

  # Build for a single rule entry
  #
  # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#20
  def to_s; end

  class << self
    # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#11
    def fixnum_to_ical_day(num); end

    # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#47
    def ical_duration(duration); end

    # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#38
    def ical_format(time, force_utc); end

    # source://ice_cube//lib/ice_cube/builders/ical_builder.rb#33
    def ical_utc_format(time); end
  end
end

# source://ice_cube//lib/ice_cube/builders/ical_builder.rb#5
IceCube::IcalBuilder::ICAL_DAYS = T.let(T.unsafe(nil), Array)

# source://ice_cube//lib/ice_cube/parsers/ical_parser.rb#2
class IceCube::IcalParser
  class << self
    # @raise [ArgumentError]
    #
    # source://ice_cube//lib/ice_cube/parsers/ical_parser.rb#29
    def rule_from_ical(ical); end

    # source://ice_cube//lib/ice_cube/parsers/ical_parser.rb#3
    def schedule_from_ical(ical_string, options = T.unsafe(nil)); end
  end
end

# source://ice_cube//lib/ice_cube/input_alignment.rb#2
class IceCube::InputAlignment
  # @return [InputAlignment] a new instance of InputAlignment
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#4
  def initialize(rule, value, rule_part); end

  # Returns the value of attribute rule.
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#10
  def rule; end

  # Returns the value of attribute rule_part.
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#10
  def rule_part; end

  # Returns the value of attribute value.
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#10
  def value; end

  # source://ice_cube//lib/ice_cube/input_alignment.rb#12
  def verify(freq, options = T.unsafe(nil), &block); end

  private

  # source://ice_cube//lib/ice_cube/input_alignment.rb#35
  def fixed_validations; end

  # source://ice_cube//lib/ice_cube/input_alignment.rb#27
  def interval_validation; end

  # source://ice_cube//lib/ice_cube/input_alignment.rb#31
  def interval_value; end

  # @yield [ArgumentError.new(message)]
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#43
  def verify_freq_alignment(freq); end

  # @yield [ArgumentError.new(message)]
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#64
  def verify_month_alignment(_freq); end

  # @yield [ArgumentError.new(message)]
  #
  # source://ice_cube//lib/ice_cube/input_alignment.rb#73
  def verify_wday_alignment(freq); end
end

# source://ice_cube//lib/ice_cube/rules/minutely_rule.rb#3
class IceCube::MinutelyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::DayOfYear
  include ::IceCube::Validations::MinutelyInterval

  # @return [MinutelyRule] a new instance of MinutelyRule
  #
  # source://ice_cube//lib/ice_cube/rules/minutely_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/rules/monthly_rule.rb#3
class IceCube::MonthlyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::MonthlyInterval

  # @return [MonthlyRule] a new instance of MonthlyRule
  #
  # source://ice_cube//lib/ice_cube/rules/monthly_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/null_i18n.rb#4
module IceCube::NullI18n
  class << self
    # source://ice_cube//lib/ice_cube/null_i18n.rb#30
    def config; end

    # source://ice_cube//lib/ice_cube/null_i18n.rb#25
    def l(date_or_time, options = T.unsafe(nil)); end

    # source://ice_cube//lib/ice_cube/null_i18n.rb#5
    def t(key, options = T.unsafe(nil)); end
  end
end

# source://ice_cube//lib/ice_cube.rb#67
IceCube::ONE_DAY = T.let(T.unsafe(nil), Integer)

# source://ice_cube//lib/ice_cube.rb#66
IceCube::ONE_HOUR = T.let(T.unsafe(nil), Integer)

# source://ice_cube//lib/ice_cube.rb#65
IceCube::ONE_MINUTE = T.let(T.unsafe(nil), Integer)

# Define some useful constants
#
# source://ice_cube//lib/ice_cube.rb#64
IceCube::ONE_SECOND = T.let(T.unsafe(nil), Integer)

# source://ice_cube//lib/ice_cube.rb#68
IceCube::ONE_WEEK = T.let(T.unsafe(nil), Integer)

# Wraps start_time and end_time in a single concept concerning the duration.
# This delegates to the enclosed start_time so it behaves like a normal Time
# in almost all situations, however:
#
# Without ActiveSupport, it's necessary to cast the occurrence using
# +#to_time+ before doing arithmetic, else Time will try to subtract it
# using +#to_i+ and return a new time instead.
#
#     Time.now - Occurrence.new(start_time) # => 1970-01-01 01:00:00
#     Time.now - Occurrence.new(start_time).to_time # => 3600
#
# When ActiveSupport::Time core extensions are loaded, it's possible to
# subtract an Occurrence object directly from a Time to get the difference:
#
#     Time.now - Occurrence.new(start_time) # => 3600
#
# source://ice_cube//lib/ice_cube/occurrence.rb#21
class IceCube::Occurrence < ::SimpleDelegator
  include ::Comparable

  # @return [Occurrence] a new instance of Occurrence
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#33
  def initialize(start_time, end_time = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/occurrence.rb#43
  def <=>(other); end

  # source://ice_cube//lib/ice_cube/occurrence.rb#68
  def comparable_time; end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#63
  def cover?(other); end

  # source://ice_cube//lib/ice_cube/occurrence.rb#72
  def duration; end

  # Returns the value of attribute end_time.
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#29
  def end_time; end

  # Returns the value of attribute start_time.
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#29
  def first; end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#63
  def include?(other); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#52
  def intersects?(other); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#47
  def is_a?(klass); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#47
  def kind_of?(klass); end

  # Returns the value of attribute end_time.
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#29
  def last; end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#97
  def overnight?; end

  # Returns the value of attribute start_time.
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#29
  def start_time; end

  # source://ice_cube//lib/ice_cube/occurrence.rb#39
  def to_i; end

  # source://ice_cube//lib/ice_cube/occurrence.rb#76
  def to_range; end

  # Shows both the start and end time if there is a duration.
  # Optional format argument (e.g. :long, :short) supports Rails
  # time formats and is only used when ActiveSupport is available.
  #
  # source://ice_cube//lib/ice_cube/occurrence.rb#88
  def to_s(format = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/occurrence.rb#80
  def to_time; end

  class << self
    # Report class name as 'Time' to thwart type checking.
    #
    # source://ice_cube//lib/ice_cube/occurrence.rb#25
    def name; end
  end
end

# source://ice_cube//lib/ice_cube/rule.rb#5
class IceCube::Rule
  # source://ice_cube//lib/ice_cube/rule.rb#22
  def ==(other); end

  # source://ice_cube//lib/ice_cube/rule.rb#27
  def hash; end

  # source://ice_cube//lib/ice_cube/rule.rb#54
  def next_time(time, schedule, closing_time); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/rule.rb#57
  def on?(time, schedule); end

  # source://ice_cube//lib/ice_cube/rule.rb#14
  def reset; end

  # Is this a terminating schedule?
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/rule.rb#18
  def terminating?; end

  # @raise [MethodNotImplemented]
  #
  # source://ice_cube//lib/ice_cube/rule.rb#50
  def to_hash; end

  # @raise [MethodNotImplemented]
  #
  # source://ice_cube//lib/ice_cube/rule.rb#31
  def to_ical; end

  # Yaml implementation
  #
  # source://ice_cube//lib/ice_cube/rule.rb#41
  def to_yaml(*args); end

  # Returns the value of attribute uses.
  #
  # source://ice_cube//lib/ice_cube/rule.rb#12
  def uses; end

  class << self
    # Daily Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#126
    def daily(interval = T.unsafe(nil)); end

    # Convert from a hash and create a rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#64
    def from_hash(original_hash); end

    # Convert from ical string and create a rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#36
    def from_ical(ical); end

    # From yaml
    #
    # source://ice_cube//lib/ice_cube/rule.rb#46
    def from_yaml(yaml); end

    # Hourly Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#121
    def hourly(interval = T.unsafe(nil)); end

    # Minutely Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#116
    def minutely(interval = T.unsafe(nil)); end

    # Monthly Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#136
    def monthly(interval = T.unsafe(nil)); end

    # Secondly Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#111
    def secondly(interval = T.unsafe(nil)); end

    # Weekly Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#131
    def weekly(interval = T.unsafe(nil), week_start = T.unsafe(nil)); end

    # Yearly Rule
    #
    # source://ice_cube//lib/ice_cube/rule.rb#141
    def yearly(interval = T.unsafe(nil)); end

    private

    # source://ice_cube//lib/ice_cube/rule.rb#95
    def apply_validation(rule, name, args); end
  end
end

# source://ice_cube//lib/ice_cube/rule.rb#7
IceCube::Rule::INTERVAL_TYPES = T.let(T.unsafe(nil), Array)

# source://ice_cube//lib/ice_cube/schedule.rb#5
class IceCube::Schedule
  extend ::IceCube::Deprecated

  # Create a new schedule
  #
  # @return [Schedule] a new instance of Schedule
  # @yield [_self]
  # @yieldparam _self [IceCube::Schedule] the object that the method was called on
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#18
  def initialize(start_time = T.unsafe(nil), options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#398
  def ==(other); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def add_exception_date(*args, &block); end

  # Add an exception rule to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#83
  def add_exception_rule(rule); end

  # Add an exception time to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#59
  def add_exception_time(time); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def add_recurrence_date(*args, &block); end

  # Add a recurrence rule to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#70
  def add_recurrence_rule(rule); end

  # Add a recurrence time to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#48
  def add_recurrence_time(time); end

  # All of the occurrences
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#154
  def all_occurrences; end

  # Emit an enumerator based on the start time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#160
  def all_occurrences_enumerator; end

  # Determine if this schedule conflicts with another schedule
  #
  # @param other_schedule [IceCube::Schedule] - The schedule to compare to
  # @param closing_time [Time] - the last time to consider
  # @return [Boolean] whether or not the schedules conflict at all
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#257
  def conflicts_with?(other_schedule, closing_time = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/schedule.rb#39
  def duration; end

  # source://ice_cube//lib/ice_cube/schedule.rb#43
  def duration=(seconds); end

  # Iterate forever
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#165
  def each_occurrence(&block); end

  # Hook for YAML.dump, enables to_yaml
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#344
  def encode_with(coder); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def end_date(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def end_date=(*args, &block); end

  # Get the end time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#14
  def end_time; end

  # Set end_time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#34
  def end_time=(end_time); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#398
  def eql?(other); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def exception_dates(*args, &block); end

  # Get the exception rules
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#102
  def exception_rules; end

  # Get the exception times that are on the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#128
  def exception_times; end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def exdate(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def exdates(*args, &block); end

  # Add an exception rule to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#83
  def exrule(rule); end

  # Get the exception rules
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#102
  def exrules; end

  # Add an exception time to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#59
  def extime(time); end

  # Get the exception times that are on the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#128
  def extimes; end

  # Get the first n occurrences, or the first occurrence if n is skipped
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#299
  def first(n = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/schedule.rb#390
  def hash; end

  # Get the final n occurrences of a terminating schedule
  # or the final one if no n is given
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#306
  def last(n = T.unsafe(nil)); end

  # The next occurrence after now (overridable)
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#177
  def next_occurrence(from = T.unsafe(nil), options = T.unsafe(nil)); end

  # The next n occurrences after now
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#171
  def next_occurrences(num, from = T.unsafe(nil), options = T.unsafe(nil)); end

  # Get all of the occurrences from the start_time up until a
  # given Time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#149
  def occurrences(closing_time); end

  # Occurrences between two times
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#213
  def occurrences_between(begin_time, closing_time, options = T.unsafe(nil)); end

  # Determine if the schedule is occurring at a given time
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#243
  def occurring_at?(time); end

  # Return a boolean indicating if an occurrence is occurring between two
  # times, inclusive of its duration. This counts zero-length occurrences
  # that intersect the start of the range and within the range, but not
  # occurrences at the end of the range since none of their duration
  # intersects the range.
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#230
  def occurring_between?(opening_time, closing_time); end

  # Determine if the schedule occurs at a specific time
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#294
  def occurs_at?(time); end

  # Return a boolean indicating if an occurrence falls between two times
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#218
  def occurs_between?(begin_time, closing_time, options = T.unsafe(nil)); end

  # Return a boolean indicating if an occurrence falls on a certain date
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#235
  def occurs_on?(date); end

  # The previous occurrence from a given time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#185
  def previous_occurrence(from); end

  # The previous n occurrences before a given time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#192
  def previous_occurrences(num, from); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def rdate(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def rdates(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def recurrence_dates(*args, &block); end

  # Get the recurrence rules
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#96
  def recurrence_rules; end

  # Get the recurrence times that are on the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#108
  def recurrence_times; end

  # The remaining occurrences (same requirements as all_occurrences)
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#200
  def remaining_occurrences(from = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns an enumerator for all remaining occurrences
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#207
  def remaining_occurrences_enumerator(from = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def remove_exception_date(*args, &block); end

  # Remove an exception rule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#90
  def remove_exception_rule(rule); end

  # Remove an exception time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#136
  def remove_exception_time(time); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def remove_exdate(*args, &block); end

  # Remove an exception time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#136
  def remove_extime(time); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def remove_rdate(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def remove_recurrence_date(*args, &block); end

  # Remove a recurrence rule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#77
  def remove_recurrence_rule(rule); end

  # Remove a recurrence time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#116
  def remove_recurrence_time(time); end

  # Remove a recurrence time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#116
  def remove_rtime(time); end

  # Add a recurrence rule to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#70
  def rrule(rule); end

  # Get the recurrence rules
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#96
  def rrules; end

  # Add a recurrence time to the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#48
  def rtime(time); end

  # Get the recurrence times that are on the schedule
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#108
  def rtimes; end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def start_date(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def start_date=(*args, &block); end

  # Get the start time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#10
  def start_time; end

  # Set start_time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#28
  def start_time=(start_time); end

  # Determine if the schedule will end
  #
  # @return [Boolean] true if ending, false if repeating forever
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#386
  def terminating?; end

  # Convert the schedule to a hash
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#357
  def to_h; end

  # Convert the schedule to a hash
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#357
  def to_hash; end

  # Serialize this schedule to_ical
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#327
  def to_ical(force_utc = T.unsafe(nil)); end

  # String serialization
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#313
  def to_s; end

  private

  # Find all of the occurrences for the schedule between opening_time
  # and closing_time
  # Iteration is unrolled in pairs to skip duplicate times in end of DST
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#424
  def enumerate_occurrences(opening_time, closing_time = T.unsafe(nil), options = T.unsafe(nil)); end

  # Return a boolean indicating whether or not a specific time
  # is excluded from the schedule
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#472
  def exception_time?(time); end

  # Indicate if any rule needs to be run from the start of time
  # If we have rules with counts, we need to walk from the beginning of time
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#465
  def full_required?; end

  # source://ice_cube//lib/ice_cube/schedule.rb#484
  def implicit_start_occurrence_rule; end

  # Get the next time after (or including) a specific time
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#447
  def next_time(time, closing_time); end

  # source://ice_cube//lib/ice_cube/schedule.rb#500
  def recurrence_rules_with_implicit_start_occurrence; end

  # source://ice_cube//lib/ice_cube/schedule.rb#492
  def recurrence_times_with_start_time; end

  # source://ice_cube//lib/ice_cube/schedule.rb#488
  def recurrence_times_without_start_time; end

  # @raise [ArgumentError]
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#478
  def require_terminating_rules; end

  # Reset all rules for another run
  #
  # source://ice_cube//lib/ice_cube/schedule.rb#416
  def reset; end

  class << self
    # source://ice_cube//lib/ice_cube/schedule.rb#403
    def dump(schedule); end

    # Load the schedule from a hash
    #
    # source://ice_cube//lib/ice_cube/schedule.rb#377
    def from_hash(original_hash, options = T.unsafe(nil)); end

    # Load the schedule from ical
    #
    # source://ice_cube//lib/ice_cube/schedule.rb#339
    def from_ical(ical, options = T.unsafe(nil)); end

    # Load the schedule from yaml
    #
    # source://ice_cube//lib/ice_cube/schedule.rb#349
    def from_yaml(yaml, options = T.unsafe(nil)); end

    # source://ice_cube//lib/ice_cube/schedule.rb#408
    def load(yaml); end
  end
end

# source://ice_cube//lib/ice_cube/rules/secondly_rule.rb#3
class IceCube::SecondlyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::DayOfYear
  include ::IceCube::Validations::SecondlyInterval

  # @return [SecondlyRule] a new instance of SecondlyRule
  #
  # source://ice_cube//lib/ice_cube/rules/secondly_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#3
class IceCube::SingleOccurrenceRule < ::IceCube::Rule
  # @return [SingleOccurrenceRule] a new instance of SingleOccurrenceRule
  #
  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#7
  def initialize(time); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#26
  def full_required?; end

  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#16
  def next_time(t, _, closing_time); end

  # Always terminating
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#12
  def terminating?; end

  # Returns the value of attribute time.
  #
  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#5
  def time; end

  # source://ice_cube//lib/ice_cube/single_occurrence_rule.rb#22
  def to_hash; end
end

# source://ice_cube//lib/ice_cube/builders/string_builder.rb#3
class IceCube::StringBuilder
  extend ::IceCube::StringBuilder::Helpers

  # @return [StringBuilder] a new instance of StringBuilder
  #
  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#7
  def initialize; end

  # Sets the attribute base
  #
  # @param value the value to set the attribute base to.
  #
  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#5
  def base=(_arg0); end

  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#11
  def piece(type, prefix = T.unsafe(nil), suffix = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#15
  def to_s; end

  class << self
    # source://ice_cube//lib/ice_cube/builders/string_builder.rb#30
    def formatter(type); end

    # source://ice_cube//lib/ice_cube/builders/string_builder.rb#34
    def register_formatter(type, &formatter); end
  end
end

# source://ice_cube//lib/ice_cube/builders/string_builder.rb#39
module IceCube::StringBuilder::Helpers
  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#59
  def literal_ordinal(number); end

  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#51
  def nice_number(number); end

  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#63
  def ordinal(number); end

  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#55
  def ordinalize(number); end

  # influenced by ActiveSupport's to_sentence
  #
  # source://ice_cube//lib/ice_cube/builders/string_builder.rb#42
  def sentence(array); end
end

# source://ice_cube//lib/ice_cube/time_util.rb#5
module IceCube::TimeUtil
  extend ::IceCube::Deprecated

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def normalize_weekday(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def symbol_to_day(*args, &block); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def symbol_to_month(*args, &block); end

  class << self
    # Get the beginning of a date
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#142
    def beginning_of_date(date, reference = T.unsafe(nil)); end

    # source://ice_cube//lib/ice_cube/time_util.rb#32
    def build_in_zone(args, reference); end

    # Get a day of the month in the month of a given time without overflowing
    # into the next month. Accepts days from positive (start of month forward) or
    # negative (from end of month)
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#223
    def day_of_month(value, date); end

    # Get the days in the month for +time
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#202
    def days_in_month(time); end

    # The number of days in n months
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#244
    def days_in_n_months(time, month_distance); end

    # Number of days to n years
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#238
    def days_in_n_years(time, year_distance); end

    # Get the days in the following month for +time
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#208
    def days_in_next_month(time); end

    # Number of days in a year
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#232
    def days_in_year(time); end

    # Count the number of days to the same day of the next month without
    # overflowing shorter months
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#215
    def days_to_next_month(time); end

    # Deserialize a time serialized with serialize_time or in ISO8601 string format
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#107
    def deserialize_time(time_or_hash); end

    # source://ice_cube//lib/ice_cube/time_util.rb#249
    def dst_change(time); end

    # Get the end of a date
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#147
    def end_of_date(date, reference = T.unsafe(nil)); end

    # Ensure that this is either nil, or a date
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#82
    def ensure_date(date); end

    # Ensure that this is either nil, or a time
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#61
    def ensure_time(time, reference = T.unsafe(nil), date_eod = T.unsafe(nil)); end

    # Get a more precise equality for time objects
    # Ruby provides a Time#hash method, but it fails to account for UTC
    # offset (so the current date may be different) or DST rules (so the
    # hour may be wrong for different schedule occurrences)
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#125
    def hash(time); end

    # @raise [ArgumentError]
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#186
    def ical_day_to_symbol(str); end

    # source://ice_cube//lib/ice_cube/time_util.rb#44
    def match_zone(input_time, reference); end

    # Convert weekday from base sunday to the schedule's week start.
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#181
    def normalize_wday(wday, week_start); end

    # Provides a Time.now without the usec, in the reference zone or utc offset
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#28
    def now(reference = T.unsafe(nil)); end

    # Check the deserialized time offset string against actual local time
    # offset to try and preserve the original offset for plain Ruby Time. If
    # the offset is the same as local we can assume the same original zone and
    # keep it.  If it was serialized with a different offset than local TZ it
    # will lose the zone and not support DST.
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#134
    def restore_deserialized_offset(time, orig_offset_str); end

    # Serialize a time appropriate for storing
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#91
    def serialize_time(time); end

    # Handle discrepancies between various time types
    # - Time has subsec
    # - DateTime does not
    # - ActiveSupport::TimeWithZone can wrap either type, depending on version
    #   or if `parse` or `now`/`local` was used to build it.
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#261
    def subsec(time); end

    # Convert a symbol to a numeric month
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#152
    def sym_to_month(sym); end

    # Convert a symbol to a wday number
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#162
    def sym_to_wday(sym); end

    # Convert wday number to day symbol
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#172
    def wday_to_sym(wday); end

    # Return the count of the number of times wday appears in the month,
    # and which of those time falls on
    #
    # source://ice_cube//lib/ice_cube/time_util.rb#194
    def which_occurrence_in_month(time, wday); end
  end
end

# source://ice_cube//lib/ice_cube/time_util.rb#25
IceCube::TimeUtil::CLOCK_VALUES = T.let(T.unsafe(nil), Array)

# source://ice_cube//lib/ice_cube/time_util.rb#9
IceCube::TimeUtil::DAYS = T.let(T.unsafe(nil), Hash)

# source://ice_cube//lib/ice_cube/time_util.rb#14
IceCube::TimeUtil::ICAL_DAYS = T.let(T.unsafe(nil), Hash)

# source://ice_cube//lib/ice_cube/time_util.rb#19
IceCube::TimeUtil::MONTHS = T.let(T.unsafe(nil), Hash)

# A utility class for safely moving time around
#
# source://ice_cube//lib/ice_cube/time_util.rb#272
class IceCube::TimeUtil::TimeWrapper
  # @return [TimeWrapper] a new instance of TimeWrapper
  #
  # source://ice_cube//lib/ice_cube/time_util.rb#274
  def initialize(time, dst_adjust = T.unsafe(nil)); end

  # DST-safely add an interval of time to the wrapped time
  #
  # source://ice_cube//lib/ice_cube/time_util.rb#292
  def add(type, val); end

  # source://ice_cube//lib/ice_cube/time_util.rb#306
  def clear_below(type); end

  # Move to the first of the month, 0 hours
  #
  # source://ice_cube//lib/ice_cube/time_util.rb#339
  def clear_day; end

  # source://ice_cube//lib/ice_cube/time_util.rb#334
  def clear_hour; end

  # source://ice_cube//lib/ice_cube/time_util.rb#330
  def clear_min; end

  # Clear to january 1st
  #
  # source://ice_cube//lib/ice_cube/time_util.rb#344
  def clear_month; end

  # source://ice_cube//lib/ice_cube/time_util.rb#326
  def clear_sec; end

  # source://ice_cube//lib/ice_cube/time_util.rb#314
  def hour=(value); end

  # source://ice_cube//lib/ice_cube/time_util.rb#318
  def min=(value); end

  # source://ice_cube//lib/ice_cube/time_util.rb#322
  def sec=(value); end

  # Get the wrapped time back in its original zone & format
  #
  # source://ice_cube//lib/ice_cube/time_util.rb#285
  def to_time; end
end

# Clear everything below a certain type
#
# source://ice_cube//lib/ice_cube/time_util.rb#305
IceCube::TimeUtil::TimeWrapper::CLEAR_ORDER = T.let(T.unsafe(nil), Array)

# An exception for when an until date on a Rule is passed
#
# source://ice_cube//lib/ice_cube/errors/until_exceeded.rb#4
class IceCube::UntilExceeded < ::StopIteration; end

# source://ice_cube//lib/ice_cube/version.rb#3
IceCube::VERSION = T.let(T.unsafe(nil), String)

# source://ice_cube//lib/ice_cube/validated_rule.rb#5
class IceCube::ValidatedRule < ::IceCube::Rule
  include ::IceCube::Validations::ScheduleLock
  include ::IceCube::Validations::Count
  include ::IceCube::Validations::Until

  # @return [ValidatedRule] a new instance of ValidatedRule
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#28
  def initialize(interval = T.unsafe(nil)); end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#39
  def base_interval_validation; end

  # Remove the specified base validations
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#115
  def clobber_base_validations(*types); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#66
  def full_required?; end

  # Compute the next time after (or including) the specified time in respect
  # to the given start time
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#49
  def next_time(time, start_time, closing_time); end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#43
  def other_interval_validations; end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#62
  def realign(opening_time, start_time); end

  # Fully replace validations
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#106
  def replace_validations_for(key, arr); end

  # Reset the uses on the rule to 0
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#33
  def reset; end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#80
  def to_hash; end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#90
  def to_ical; end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#70
  def to_s; end

  # Returns the value of attribute validations.
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#26
  def validations; end

  # Get the collection that contains validations of a certain type
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#101
  def validations_for(key); end

  private

  # source://ice_cube//lib/ice_cube/validated_rule.rb#135
  def find_acceptable_time_before(boundary); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#129
  def finds_acceptable_time?; end

  # @raise [ArgumentError]
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#123
  def normalized_interval(interval); end

  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#173
  def past_closing_time?(closing_time); end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#155
  def shift_time_by_validation(res, validation); end

  # Returns true if all validations for the current rule match
  # otherwise false and shifts to the first (largest) unmatched offset
  #
  # @return [Boolean]
  #
  # source://ice_cube//lib/ice_cube/validated_rule.rb#145
  def validation_accepts_or_updates_time?(validations_for_type); end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#177
  def validation_names; end

  # source://ice_cube//lib/ice_cube/validated_rule.rb#181
  def verify_alignment(value, freq, rule_part); end
end

# Validations ordered for efficiency in sequence of:
# * descending intervals
# * boundary limits
# * base values by cardinality (n = 60, 60, 31, 24, 12, 7)
# * locks by cardinality (n = 365, 60, 60, 31, 24, 12, 7)
# * interval multiplier
#
# source://ice_cube//lib/ice_cube/validated_rule.rb#18
IceCube::ValidatedRule::VALIDATION_ORDER = T.let(T.unsafe(nil), Array)

# source://ice_cube//lib/ice_cube.rb#38
module IceCube::Validations; end

# source://ice_cube//lib/ice_cube/validations/count.rb#3
module IceCube::Validations::Count
  # source://ice_cube//lib/ice_cube/validations/count.rb#10
  def count(max); end

  # source://ice_cube//lib/ice_cube/validations/count.rb#6
  def occurrence_count; end
end

# source://ice_cube//lib/ice_cube/validations/count.rb#18
class IceCube::Validations::Count::Validation
  # source://ice_cube//lib/ice_cube/validations/count.rb#22
  def initialize(count, rule); end

  # source://ice_cube//lib/ice_cube/validations/count.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/count.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/count.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/count.rb#20
  def count; end

  # source://ice_cube//lib/ice_cube/validations/count.rb#31
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/count.rb#20
  def rule; end

  # source://ice_cube//lib/ice_cube/validations/count.rb#27
  def type; end

  # source://ice_cube//lib/ice_cube/validations/count.rb#35
  def validate(time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/daily_interval.rb#3
module IceCube::Validations::DailyInterval
  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#6
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/daily_interval.rb#17
class IceCube::Validations::DailyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#21
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#45
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#49
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#41
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#29
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#19
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#25
  def type; end

  # source://ice_cube//lib/ice_cube/validations/daily_interval.rb#33
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/day.rb#3
module IceCube::Validations::Day
  # source://ice_cube//lib/ice_cube/validations/day.rb#5
  def day(*days); end
end

# source://ice_cube//lib/ice_cube/validations/day.rb#21
class IceCube::Validations::Day::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/day.rb#26
  def initialize(day); end

  # source://ice_cube//lib/ice_cube/validations/day.rb#46
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/day.rb#50
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/day.rb#42
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/day.rb#23
  def day; end

  # source://ice_cube//lib/ice_cube/validations/day.rb#38
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/day.rb#30
  def key; end

  # source://ice_cube//lib/ice_cube/validations/day.rb#34
  def type; end

  # source://ice_cube//lib/ice_cube/validations/day.rb#23
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/day_of_month.rb#3
module IceCube::Validations::DayOfMonth
  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#5
  def day_of_month(*days); end
end

# source://ice_cube//lib/ice_cube/validations/day_of_month.rb#17
class IceCube::Validations::DayOfMonth::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#22
  def initialize(day); end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#42
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#46
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#38
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#19
  def day; end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#34
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#26
  def key; end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#30
  def type; end

  # source://ice_cube//lib/ice_cube/validations/day_of_month.rb#19
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/day_of_week.rb#3
module IceCube::Validations::DayOfWeek
  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#5
  def day_of_week(dows); end
end

# source://ice_cube//lib/ice_cube/validations/day_of_week.rb#16
class IceCube::Validations::DayOfWeek::Validation
  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#20
  def initialize(day, occ); end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#55
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#61
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#47
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#18
  def day; end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#29
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#18
  def occ; end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#25
  def type; end

  # source://ice_cube//lib/ice_cube/validations/day_of_week.rb#33
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/day_of_year.rb#3
module IceCube::Validations::DayOfYear
  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#5
  def day_of_year(*days); end
end

# source://ice_cube//lib/ice_cube/validations/day_of_year.rb#16
class IceCube::Validations::DayOfYear::Validation
  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#20
  def initialize(day); end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#18
  def day; end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#28
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#24
  def type; end

  # source://ice_cube//lib/ice_cube/validations/day_of_year.rb#32
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/fixed_value.rb#11
class IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/fixed_value.rb#15
  def validate(time, start_time); end

  private

  # source://ice_cube//lib/ice_cube/validations/fixed_value.rb#87
  def starting_unit(start_time); end

  # source://ice_cube//lib/ice_cube/validations/fixed_value.rb#60
  def validate_day_lock(time, start_time); end

  # source://ice_cube//lib/ice_cube/validations/fixed_value.rb#37
  def validate_hour_lock(time, start_time); end

  # source://ice_cube//lib/ice_cube/validations/fixed_value.rb#28
  def validate_interval_lock(time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/fixed_value.rb#13
IceCube::Validations::FixedValue::INTERVALS = T.let(T.unsafe(nil), Hash)

# source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#3
module IceCube::Validations::HourOfDay
  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#6
  def hour_of_day(*hours); end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#20
  def realign(opening_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#36
class IceCube::Validations::HourOfDay::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#41
  def initialize(hour); end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#61
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#65
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#57
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#53
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#38
  def hour; end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#45
  def key; end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#49
  def type; end

  # source://ice_cube//lib/ice_cube/validations/hour_of_day.rb#38
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#3
module IceCube::Validations::HourlyInterval
  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#5
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#14
class IceCube::Validations::HourlyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#18
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#26
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#16
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#22
  def type; end

  # source://ice_cube//lib/ice_cube/validations/hourly_interval.rb#30
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#3
module IceCube::Validations::MinuteOfHour
  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#5
  def minute_of_hour(*minutes); end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#19
  def realign(opening_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#28
class IceCube::Validations::MinuteOfHour::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#33
  def initialize(minute); end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#53
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#57
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#49
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#45
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#37
  def key; end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#30
  def minute; end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#41
  def type; end

  # source://ice_cube//lib/ice_cube/validations/minute_of_hour.rb#30
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#3
module IceCube::Validations::MinutelyInterval
  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#5
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#14
class IceCube::Validations::MinutelyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#18
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#26
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#16
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#22
  def type; end

  # source://ice_cube//lib/ice_cube/validations/minutely_interval.rb#30
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/month_of_year.rb#3
module IceCube::Validations::MonthOfYear
  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#5
  def month_of_year(*months); end
end

# source://ice_cube//lib/ice_cube/validations/month_of_year.rb#18
class IceCube::Validations::MonthOfYear::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#23
  def initialize(month); end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#35
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#27
  def key; end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#20
  def month; end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#31
  def type; end

  # source://ice_cube//lib/ice_cube/validations/month_of_year.rb#20
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#3
module IceCube::Validations::MonthlyInterval
  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#5
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#15
class IceCube::Validations::MonthlyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#19
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#43
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#47
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#27
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#17
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#23
  def type; end

  # source://ice_cube//lib/ice_cube/validations/monthly_interval.rb#31
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#3
module IceCube::Validations::ScheduleLock
  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#9
  def schedule_lock(*types); end
end

# source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#15
class IceCube::Validations::ScheduleLock::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#19
  def initialize(type); end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#39
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#43
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#35
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#27
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#23
  def key; end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#17
  def type; end

  # source://ice_cube//lib/ice_cube/validations/schedule_lock.rb#17
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#3
module IceCube::Validations::SecondOfMinute
  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#19
  def realign(opening_time, start_time); end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#5
  def second_of_minute(*seconds); end
end

# source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#28
class IceCube::Validations::SecondOfMinute::Validation < ::IceCube::Validations::FixedValue
  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#33
  def initialize(second); end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#53
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#57
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#49
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#45
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#37
  def key; end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#30
  def second; end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#41
  def type; end

  # source://ice_cube//lib/ice_cube/validations/second_of_minute.rb#30
  def value; end
end

# source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#3
module IceCube::Validations::SecondlyInterval
  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#5
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#14
class IceCube::Validations::SecondlyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#18
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#40
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#44
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#36
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#26
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#16
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#22
  def type; end

  # source://ice_cube//lib/ice_cube/validations/secondly_interval.rb#30
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/until.rb#3
module IceCube::Validations::Until
  extend ::IceCube::Deprecated

  # source://ice_cube//lib/ice_cube/validations/until.rb#13
  def until(time); end

  # source://ice_cube//lib/ice_cube/deprecated.rb#9
  def until_date(*args, &block); end

  # source://ice_cube//lib/ice_cube/validations/until.rb#8
  def until_time; end
end

# source://ice_cube//lib/ice_cube/validations/until.rb#18
class IceCube::Validations::Until::Validation
  # source://ice_cube//lib/ice_cube/validations/until.rb#22
  def initialize(time); end

  # source://ice_cube//lib/ice_cube/validations/until.rb#44
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/until.rb#48
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/until.rb#39
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/until.rb#30
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/until.rb#20
  def time; end

  # source://ice_cube//lib/ice_cube/validations/until.rb#26
  def type; end

  # source://ice_cube//lib/ice_cube/validations/until.rb#34
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#3
module IceCube::Validations::WeeklyInterval
  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#5
  def interval(interval, week_start = T.unsafe(nil)); end
end

# source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#13
class IceCube::Validations::WeeklyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#17
  def initialize(interval, week_start); end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#45
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#50
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#41
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#26
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#15
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#22
  def type; end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#30
  def validate(step_time, start_time); end

  # source://ice_cube//lib/ice_cube/validations/weekly_interval.rb#15
  def week_start; end
end

# source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#3
module IceCube::Validations::YearlyInterval
  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#5
  def interval(interval); end
end

# source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#12
class IceCube::Validations::YearlyInterval::Validation
  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#16
  def initialize(interval); end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#38
  def build_hash(builder); end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#42
  def build_ical(builder); end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#34
  def build_s(builder); end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#24
  def dst_adjust?; end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#14
  def interval; end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#20
  def type; end

  # source://ice_cube//lib/ice_cube/validations/yearly_interval.rb#28
  def validate(step_time, start_time); end
end

# source://ice_cube//lib/ice_cube/rules/weekly_rule.rb#3
class IceCube::WeeklyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::WeeklyInterval

  # @return [WeeklyRule] a new instance of WeeklyRule
  #
  # source://ice_cube//lib/ice_cube/rules/weekly_rule.rb#18
  def initialize(interval = T.unsafe(nil), week_start = T.unsafe(nil)); end

  # Move the effective start time to correct for when the schedule has
  # validations earlier in the week than the selected start time, e.g.
  #
  #     Schedule.new(wednesday).weekly(2).day(:monday)
  #
  # The effective start time gets realigned to the second next Monday, jumping
  # over the gap week for the interval (2). Without realignment, the correct
  # Monday occurrence would be missed when the schedule performs a 7-day jump
  # into the next interval week, arriving on the Wednesday. This corrects any
  # selections from dates that are misaligned to the schedule interval.
  #
  # source://ice_cube//lib/ice_cube/rules/weekly_rule.rb#36
  def realign(step_time, start_time); end

  # Calculate how many days to the first wday validation in the correct
  # interval week. This may move backwards within the week if starting in an
  # interval week with earlier validations.
  #
  # source://ice_cube//lib/ice_cube/rules/weekly_rule.rb#47
  def wday_offset(step_time, start_time); end

  # Returns the value of attribute week_start.
  #
  # source://ice_cube//lib/ice_cube/rules/weekly_rule.rb#16
  def week_start; end
end

# source://ice_cube//lib/ice_cube/parsers/yaml_parser.rb#4
class IceCube::YamlParser < ::IceCube::HashParser
  # @return [YamlParser] a new instance of YamlParser
  #
  # source://ice_cube//lib/ice_cube/parsers/yaml_parser.rb#10
  def initialize(yaml); end

  # Returns the value of attribute hash.
  #
  # source://ice_cube//lib/ice_cube/parsers/yaml_parser.rb#8
  def hash; end
end

# source://ice_cube//lib/ice_cube/parsers/yaml_parser.rb#6
IceCube::YamlParser::SERIALIZED_START = T.let(T.unsafe(nil), Regexp)

# source://ice_cube//lib/ice_cube/rules/yearly_rule.rb#3
class IceCube::YearlyRule < ::IceCube::ValidatedRule
  include ::IceCube::Validations::HourOfDay
  include ::IceCube::Validations::MinuteOfHour
  include ::IceCube::Validations::SecondOfMinute
  include ::IceCube::Validations::DayOfMonth
  include ::IceCube::Validations::DayOfWeek
  include ::IceCube::Validations::Day
  include ::IceCube::Validations::MonthOfYear
  include ::IceCube::Validations::DayOfYear
  include ::IceCube::Validations::YearlyInterval

  # @return [YearlyRule] a new instance of YearlyRule
  #
  # source://ice_cube//lib/ice_cube/rules/yearly_rule.rb#16
  def initialize(interval = T.unsafe(nil)); end
end
