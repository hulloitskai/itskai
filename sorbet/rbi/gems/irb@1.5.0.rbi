# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `irb` gem.
# Please instead update this file by running `bin/tapioca gem irb`.

# IRB stands for "interactive Ruby" and is a tool to interactively execute Ruby
# expressions read from the standard input.
#
# The +irb+ command from your shell will start the interpreter.
#
# == Usage
#
# Use of irb is easy if you know Ruby.
#
# When executing irb, prompts are displayed as follows. Then, enter the Ruby
# expression. An input is executed when it is syntactically complete.
#
#     $ irb
#     irb(main):001:0> 1+2
#     #=> 3
#     irb(main):002:0> class Foo
#     irb(main):003:1>  def foo
#     irb(main):004:2>    print 1
#     irb(main):005:2>  end
#     irb(main):006:1> end
#     #=> nil
#
# The singleline editor module or multiline editor module can be used with irb.
# Use of multiline editor is default if it's installed.
#
# == Command line options
#
#   :include: ./irb/lc/help-message
#
# == Commands
#
# The following commands are available on IRB.
#
# * cwws
#   * Show the current workspace.
# * cb, cws, chws
#   * Change the current workspace to an object.
# * bindings, workspaces
#   * Show workspaces.
# * pushb, pushws
#   * Push an object to the workspace stack.
# * popb, popws
#   * Pop a workspace from the workspace stack.
# * load
#   * Load a Ruby file.
# * require
#   * Require a Ruby file.
# * source
#   * Loads a given file in the current session.
# * irb
#   * Start a child IRB.
# * jobs
#   * List of current sessions.
# * fg
#   * Switches to the session of the given number.
# * kill
#   * Kills the session with the given number.
# * help
#   * Enter the mode to look up RI documents.
# * irb_info
#   * Show information about IRB.
# * ls
#   * Show methods, constants, and variables.
#     -g [query] or -G [query] allows you to filter out the output.
# * measure
#   * measure enables the mode to measure processing time. measure :off disables it.
# * $, show_source
#   * Show the source code of a given method or constant.
# * @, whereami
#   * Show the source code around binding.irb again.
# * debug
#   * Start the debugger of debug.gem.
#
# == Configuration
#
# IRB reads a personal initialization file when it's invoked.
# IRB searches a file in the following order and loads the first one found.
#
# * <tt>$IRBRC</tt> (if <tt>$IRBRC</tt> is set)
# * <tt>$XDG_CONFIG_HOME/irb/irbrc</tt> (if <tt>$XDG_CONFIG_HOME</tt> is set)
# * <tt>~/.irbrc</tt>
# * +.config/irb/irbrc+
# * +.irbrc+
# * +irb.rc+
# * +_irbrc+
# * <code>$irbrc</code>
#
# The following are alternatives to the command line options. To use them type
# as follows in an +irb+ session:
#
#     IRB.conf[:IRB_NAME]="irb"
#     IRB.conf[:INSPECT_MODE]=nil
#     IRB.conf[:IRB_RC] = nil
#     IRB.conf[:BACK_TRACE_LIMIT]=16
#     IRB.conf[:USE_LOADER] = false
#     IRB.conf[:USE_MULTILINE] = nil
#     IRB.conf[:USE_SINGLELINE] = nil
#     IRB.conf[:USE_COLORIZE] = true
#     IRB.conf[:USE_TRACER] = false
#     IRB.conf[:USE_AUTOCOMPLETE] = true
#     IRB.conf[:IGNORE_SIGINT] = true
#     IRB.conf[:IGNORE_EOF] = false
#     IRB.conf[:PROMPT_MODE] = :DEFAULT
#     IRB.conf[:PROMPT] = {...}
#
# === Auto indentation
#
# To disable auto-indent mode in irb, add the following to your +.irbrc+:
#
#     IRB.conf[:AUTO_INDENT] = false
#
# === Autocompletion
#
# To disable autocompletion for irb, add the following to your +.irbrc+:
#
#     IRB.conf[:USE_AUTOCOMPLETE] = false
#
# === History
#
# By default, irb will store the last 1000 commands you used in
# <code>IRB.conf[:HISTORY_FILE]</code> (<code>~/.irb_history</code> by default).
#
# If you want to disable history, add the following to your +.irbrc+:
#
#     IRB.conf[:SAVE_HISTORY] = nil
#
# See IRB::Context#save_history= for more information.
#
# The history of _results_ of commands evaluated is not stored by default,
# but can be turned on to be stored with this +.irbrc+ setting:
#
#     IRB.conf[:EVAL_HISTORY] = <number>
#
# See IRB::Context#eval_history= and History class. The history of command
# results is not permanently saved in any file.
#
# == Customizing the IRB Prompt
#
# In order to customize the prompt, you can change the following Hash:
#
#     IRB.conf[:PROMPT]
#
# This example can be used in your +.irbrc+
#
#     IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode
#       :AUTO_INDENT => false,          # disables auto-indent mode
#       :PROMPT_I =>  ">> ",		# simple prompt
#       :PROMPT_S => nil,		# prompt for continuated strings
#       :PROMPT_C => nil,		# prompt for continuated statement
#       :RETURN => "    ==>%s\n"	# format to return value
#     }
#
#     IRB.conf[:PROMPT_MODE] = :MY_PROMPT
#
# Or, invoke irb with the above prompt mode by:
#
#     irb --prompt my-prompt
#
# Constants +PROMPT_I+, +PROMPT_S+ and +PROMPT_C+ specify the format. In the
# prompt specification, some special strings are available:
#
#     %N    # command name which is running
#     %m    # to_s of main object (self)
#     %M    # inspect of main object (self)
#     %l    # type of string(", ', /, ]), `]' is inner %w[...]
#     %NNi  # indent level. NN is digits and means as same as printf("%NNd").
#           # It can be omitted
#     %NNn  # line number.
#     %%    # %
#
# For instance, the default prompt mode is defined as follows:
#
#     IRB.conf[:PROMPT_MODE][:DEFAULT] = {
#       :PROMPT_I => "%N(%m):%03n:%i> ",
#       :PROMPT_N => "%N(%m):%03n:%i> ",
#       :PROMPT_S => "%N(%m):%03n:%i%l ",
#       :PROMPT_C => "%N(%m):%03n:%i* ",
#       :RETURN => "%s\n" # used to printf
#     }
#
# irb comes with a number of available modes:
#
#   # :NULL:
#   #   :PROMPT_I:
#   #   :PROMPT_N:
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |
#   #     %s
#   # :DEFAULT:
#   #   :PROMPT_I: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_N: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_S: ! '%N(%m):%03n:%i%l '
#   #   :PROMPT_C: ! '%N(%m):%03n:%i* '
#   #   :RETURN: |
#   #     => %s
#   # :CLASSIC:
#   #   :PROMPT_I: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_N: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_S: ! '%N(%m):%03n:%i%l '
#   #   :PROMPT_C: ! '%N(%m):%03n:%i* '
#   #   :RETURN: |
#   #     %s
#   # :SIMPLE:
#   #   :PROMPT_I: ! '>> '
#   #   :PROMPT_N: ! '>> '
#   #   :PROMPT_S:
#   #   :PROMPT_C: ! '?> '
#   #   :RETURN: |
#   #     => %s
#   # :INF_RUBY:
#   #   :PROMPT_I: ! '%N(%m):%03n:%i> '
#   #   :PROMPT_N:
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |
#   #     %s
#   #   :AUTO_INDENT: true
#   # :XMP:
#   #   :PROMPT_I:
#   #   :PROMPT_N:
#   #   :PROMPT_S:
#   #   :PROMPT_C:
#   #   :RETURN: |2
#   #         ==>%s
#
# == Restrictions
#
# Because irb evaluates input immediately after it is syntactically complete,
# the results may be slightly different than directly using Ruby.
#
# == IRB Sessions
#
# IRB has a special feature, that allows you to manage many sessions at once.
#
# You can create new sessions with Irb.irb, and get a list of current sessions
# with the +jobs+ command in the prompt.
#
# === Commands
#
# JobManager provides commands to handle the current sessions:
#
#   jobs    # List of current sessions
#   fg      # Switches to the session of the given number
#   kill    # Kills the session with the given number
#
# The +exit+ command, or ::irb_exit, will quit the current session and call any
# exit hooks with IRB.irb_at_exit.
#
# A few commands for loading files within the session are also available:
#
# +source+::
#   Loads a given file in the current session and displays the source lines,
#   see IrbLoader#source_file
# +irb_load+::
#   Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
# +irb_require+::
#   Loads the given file similarly to Kernel#require
#
# === Configuration
#
# The command line options, or IRB.conf, specify the default behavior of
# Irb.irb.
#
# On the other hand, each conf in IRB@Command+line+options is used to
# individually configure IRB.irb.
#
# If a proc is set for <code>IRB.conf[:IRB_RC]</code>, its will be invoked after execution
# of that proc with the context of the current session as its argument. Each
# session can be configured using this mechanism.
#
# === Session variables
#
# There are a few variables in every Irb session that can come in handy:
#
# <code>_</code>::
#   The value command executed, as a local variable
# <code>__</code>::
#   The history of evaluated commands. Available only if
#   <code>IRB.conf[:EVAL_HISTORY]</code> is not +nil+ (which is the default).
#   See also IRB::Context#eval_history= and IRB::History.
# <code>__[line_no]</code>::
#   Returns the evaluation value at the given line number, +line_no+.
#   If +line_no+ is a negative, the return value +line_no+ many lines before
#   the most recent return value.
#
# === Example using IRB Sessions
#
#   # invoke a new session
#   irb(main):001:0> irb
#   # list open sessions
#   irb.1(main):001:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : stop)
#     #1->irb#1 on main (#<Thread:0x40125d64> : running)
#
#   # change the active session
#   irb.1(main):002:0> fg 0
#   # define class Foo in top-level session
#   irb(main):002:0> class Foo;end
#   # invoke a new session with the context of Foo
#   irb(main):003:0> irb Foo
#   # define Foo#foo
#   irb.2(Foo):001:0> def foo
#   irb.2(Foo):002:1>   print 1
#   irb.2(Foo):003:1> end
#
#   # change the active session
#   irb.2(Foo):004:0> fg 0
#   # list open sessions
#   irb(main):004:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : running)
#     #1->irb#1 on main (#<Thread:0x40125d64> : stop)
#     #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
#   # check if Foo#foo is available
#   irb(main):005:0> Foo.instance_methods #=> [:foo, ...]
#
#   # change the active session
#   irb(main):006:0> fg 2
#   # define Foo#bar in the context of Foo
#   irb.2(Foo):005:0> def bar
#   irb.2(Foo):006:1>  print "bar"
#   irb.2(Foo):007:1> end
#   irb.2(Foo):010:0>  Foo.instance_methods #=> [:bar, :foo, ...]
#
#   # change the active session
#   irb.2(Foo):011:0> fg 0
#   irb(main):007:0> f = Foo.new  #=> #<Foo:0x4010af3c>
#   # invoke a new session with the context of f (instance of Foo)
#   irb(main):008:0> irb f
#   # list open sessions
#   irb.3(<Foo:0x4010af3c>):001:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : stop)
#     #1->irb#1 on main (#<Thread:0x40125d64> : stop)
#     #2->irb#2 on Foo (#<Thread:0x4011d54c> : stop)
#     #3->irb#3 on #<Foo:0x4010af3c> (#<Thread:0x4010a1e0> : running)
#   # evaluate f.foo
#   irb.3(<Foo:0x4010af3c>):002:0> foo #=> 1 => nil
#   # evaluate f.bar
#   irb.3(<Foo:0x4010af3c>):003:0> bar #=> bar => nil
#   # kill jobs 1, 2, and 3
#   irb.3(<Foo:0x4010af3c>):004:0> kill 1, 2, 3
#   # list open sessions, should only include main session
#   irb(main):009:0> jobs
#     #0->irb on main (#<Thread:0x400fb7e4> : running)
#   # quit irb
#   irb(main):010:0> exit
#
# source://irb//lib/irb/init.rb#13
module IRB
  class << self
    # The current IRB::Context of the session, see IRB.conf
    #
    #   irb
    #   irb(main):001:0> IRB.CurrentContext.irb_name = "foo"
    #   foo(main):002:0> IRB.conf[:MAIN_CONTEXT].irb_name #=> "foo"
    #
    # source://irb//lib/irb.rb#403
    def CurrentContext; end

    # Convenience method to create a new Inspector, using the given +inspect+
    # proc, and optional +init+ proc and passes them to Inspector.new
    #
    #     irb(main):001:0> ins = IRB::Inspector(proc{ |v| "omg! #{v}" })
    #     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
    #     irb(main):001:0> "what?" #=> omg! what?
    #
    # source://irb//lib/irb/inspector.rb#24
    def Inspector(inspect, init = T.unsafe(nil)); end

    # Displays current configuration.
    #
    # Modifying the configuration is achieved by sending a message to IRB.conf.
    #
    # See IRB@Configuration for more information.
    #
    # source://irb//lib/irb.rb#386
    def conf; end

    # source://irb//lib/irb/src_encoding.rb#4
    def default_src_encoding; end

    # source://irb//lib/irb/workspace.rb#177
    def delete_caller; end

    # source://irb//lib/irb/init.rb#29
    def init_config(ap_path); end

    # source://irb//lib/irb/init.rb#213
    def init_error; end

    # Aborts then interrupts irb.
    #
    # Will raise an Abort exception, or the given +exception+.
    #
    # source://irb//lib/irb.rb#435
    def irb_abort(irb, exception = T.unsafe(nil)); end

    # Calls each event hook of <code>IRB.conf[:AT_EXIT]</code> when the current session quits.
    #
    # source://irb//lib/irb.rb#423
    def irb_at_exit; end

    # Quits irb
    #
    # source://irb//lib/irb.rb#428
    def irb_exit(irb, ret); end

    # loading modules
    #
    # source://irb//lib/irb/init.rb#415
    def load_modules; end

    # option analyzing
    #
    # source://irb//lib/irb/init.rb#218
    def parse_opts(argv: T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#374
    def rc_file(ext = T.unsafe(nil)); end

    # enumerate possible rc-file base name generators
    #
    # @yield [proc{|rc| current_dir+"/.config/irb/irb#{rc}"}]
    #
    # source://irb//lib/irb/init.rb#393
    def rc_file_generators; end

    # running config
    #
    # source://irb//lib/irb/init.rb#358
    def run_config; end

    # source://irb//lib/irb/init.rb#168
    def set_measure_callback(type = T.unsafe(nil), arg = T.unsafe(nil), &block); end

    # initialize config
    #
    # source://irb//lib/irb/init.rb#16
    def setup(ap_path, argv: T.unsafe(nil)); end

    # Initializes IRB and creates a new Irb.irb object at the +TOPLEVEL_BINDING+
    #
    # source://irb//lib/irb.rb#408
    def start(ap_path = T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#204
    def unset_measure_callback(type = T.unsafe(nil)); end

    # Returns the current version of IRB, including release version and last
    # updated date.
    #
    # source://irb//lib/irb.rb#392
    def version; end

    private

    # source://irb//lib/irb/easter-egg.rb#101
    def easter_egg(type = T.unsafe(nil)); end

    # source://irb//lib/irb/init.rb#429
    def set_encoding(extern, intern = T.unsafe(nil), override: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/color.rb#7
module IRB::Color
  class << self
    # source://irb//lib/irb/color.rb#112
    def clear(colorable: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#79
    def colorable?; end

    # source://irb//lib/irb/color.rb#117
    def colorize(text, seq, colorable: T.unsafe(nil)); end

    # If `complete` is false (code is incomplete), this does not warn compile_error.
    # This option is needed to avoid warning a user when the compile_error is happening
    # because the input is not wrong but just incomplete.
    #
    # source://irb//lib/irb/color.rb#126
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://irb//lib/irb/color.rb#91
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    # source://irb//lib/irb/color.rb#217
    def dispatch_seq(token, expr, str, in_symbol:); end

    # source://irb//lib/irb/color.rb#175
    def scan(code, allow_last_error:); end

    # source://irb//lib/irb/color.rb#167
    def without_circular_ref(obj, seen:, &block); end
  end
end

# A constant of all-bit 1 to match any Ripper's state in #dispatch_seq
#
# source://irb//lib/irb/color.rb#26
IRB::Color::ALL = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#15
IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#9
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#8
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#17
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#75
IRB::Color::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/color.rb#13
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#16
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#12
IRB::Color::RED = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#11
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)

# A class to manage a state to know whether the current token is for Symbol or not.
#
# source://irb//lib/irb/color.rb#233
class IRB::Color::SymbolState
  # @return [SymbolState] a new instance of SymbolState
  #
  # source://irb//lib/irb/color.rb#234
  def initialize; end

  # Return true if the token is a part of Symbol.
  #
  # source://irb//lib/irb/color.rb#240
  def scan_token(token); end
end

# source://irb//lib/irb/color.rb#19
IRB::Color::TOKEN_KEYWORDS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#32
IRB::Color::TOKEN_SEQ_EXPRS = T.let(T.unsafe(nil), Hash)

# source://irb//lib/irb/color.rb#10
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/color.rb#14
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

# source://irb//lib/irb/context.rb#20
class IRB::Context
  # Creates a new IRB context.
  #
  # The optional +input_method+ argument:
  #
  # +nil+::     uses stdin or Reline or Readline
  # +String+::  uses a File
  # +other+::   uses this as InputMethod
  #
  # @return [Context] a new instance of Context
  #
  # source://irb//lib/irb/context.rb#28
  def initialize(irb, workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#180
  def ap_name; end

  # A copy of the default <code>IRB.conf[:AP_NAME]</code>
  #
  # source://irb//lib/irb/context.rb#180
  def ap_name=(_arg0); end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#239
  def auto_indent_mode; end

  # Can be either the default <code>IRB.conf[:AUTO_INDENT]</code>, or the
  # mode set by #prompt_mode=
  #
  # To disable auto-indentation in irb:
  #
  #     IRB.conf[:AUTO_INDENT] = false
  #
  # or
  #
  #     irb_context.auto_indent_mode = false
  #
  # or
  #
  #     IRB.CurrentContext.auto_indent_mode = false
  #
  # See IRB@Configuration for more information.
  #
  # source://irb//lib/irb/context.rb#239
  def auto_indent_mode=(_arg0); end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#332
  def back_trace_limit; end

  # The limit of backtrace lines displayed as top +n+ and tail +n+.
  #
  # The default value is 16.
  #
  # Can also be set using the +--back-trace-limit+ command line option.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#332
  def back_trace_limit=(_arg0); end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#335
  def command_aliases; end

  # User-defined IRB command aliases
  #
  # source://irb//lib/irb/context.rb#335
  def command_aliases=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#270
  def echo; end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#270
  def echo=(_arg0); end

  # Whether to echo the return value to output or not.
  #
  # Uses <code>IRB.conf[:ECHO]</code> if available, or defaults to +true+.
  #
  #     puts "hello"
  #     # hello
  #     #=> nil
  #     IRB.CurrentContext.echo = false
  #     puts "omg"
  #     # omg
  #
  # source://irb//lib/irb/context.rb#270
  def echo?; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#305
  def echo_on_assignment; end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#305
  def echo_on_assignment=(_arg0); end

  # Whether to echo for assignment expressions.
  #
  # If set to +false+, the value of assignment will not be shown.
  #
  # If set to +true+, the value of assignment will be shown.
  #
  # If set to +:truncate+, the value of assignment will be shown and truncated.
  #
  # It defaults to +:truncate+.
  #
  #     a = "omg"
  #     #=> omg
  #
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomg...
  #
  #     IRB.CurrentContext.echo_on_assignment = false
  #     a = "omg"
  #
  #     IRB.CurrentContext.echo_on_assignment = true
  #     a = "omg" * 10
  #     #=> omgomgomgomgomgomgomgomgomgomg
  #
  # To set the behaviour of showing on assignment in irb:
  #
  #     IRB.conf[:ECHO_ON_ASSIGNMENT] = :truncate or true or false
  #
  # or
  #
  #     irb_context.echo_on_assignment = :truncate or true or false
  #
  # or
  #
  #     IRB.CurrentContext.echo_on_assignment = :truncate or true or false
  #
  # source://irb//lib/irb/context.rb#305
  def echo_on_assignment?; end

  # Sets command result history limit. Default value is set from
  # <code>IRB.conf[:EVAL_HISTORY]</code>.
  #
  # +no+ is an Integer or +nil+.
  #
  # Returns +no+ of history items if greater than 0.
  #
  # If +no+ is 0, the number of history items is unlimited.
  #
  # If +no+ is +nil+, execution result history isn't used (default).
  #
  # History values are available via <code>__</code> variable, see
  # IRB::History.
  #
  # source://irb//lib/irb/extend-command.rb#297
  def eval_history=(*opts, &b); end

  # source://irb//lib/irb/context.rb#481
  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  # Exits the current session, see IRB.irb_exit
  #
  # source://irb//lib/irb/context.rb#511
  def exit(ret = T.unsafe(nil)); end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#259
  def extra_doc_dirs; end

  # Specify the installation locations of the ri file to be displayed in the
  # document dialog.
  #
  # source://irb//lib/irb/context.rb#259
  def extra_doc_dirs=(_arg0); end

  # Whether #io uses a File for the +input_method+ passed when creating the
  # current context, see ::new
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#421
  def file_input?; end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#256
  def ignore_eof; end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#256
  def ignore_eof=(_arg0); end

  # Whether <code>^D</code> (+control-d+) will be ignored or not.
  #
  # If set to +false+, <code>^D</code> will quit irb.
  #
  # source://irb//lib/irb/context.rb#256
  def ignore_eof?; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#252
  def ignore_sigint; end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#252
  def ignore_sigint=(_arg0); end

  # Whether <code>^C</code> (+control-c+) will be ignored or not.
  #
  # If set to +false+, <code>^C</code> will quit irb.
  #
  # If set to +true+,
  #
  # * during input:   cancel input then return to top level.
  # * during execute: abandon current execution.
  #
  # source://irb//lib/irb/context.rb#252
  def ignore_sigint?; end

  # source://irb//lib/irb/context.rb#522
  def inspect; end

  # Whether #inspect_mode is set or not, see #inspect_mode= for more detail.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#415
  def inspect?; end

  # source://irb//lib/irb/context.rb#505
  def inspect_last_value; end

  # A copy of the default <code>IRB.conf[:INSPECT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#205
  def inspect_mode; end

  # Specifies the inspect mode with +opt+:
  #
  # +true+::  display +inspect+
  # +false+:: display +to_s+
  # +nil+::   inspect mode in non-math mode,
  #           non-inspect mode in math mode
  #
  # See IRB::Inspector for more information.
  #
  # Can also be set using the +--inspect+ and +--noinspect+ command line
  # options.
  #
  # See IRB@Command+line+options for more command line options.
  #
  # source://irb//lib/irb/context.rb#438
  def inspect_mode=(opt); end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#175
  def io; end

  # The current input method.
  #
  # Can be either StdioInputMethod, ReadlineInputMethod,
  # RelineInputMethod, FileInputMethod or other specified when the
  # context is created. See ::new for more # information on +input_method+.
  #
  # source://irb//lib/irb/context.rb#175
  def io=(_arg0); end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#178
  def irb; end

  # Current irb session.
  #
  # source://irb//lib/irb/context.rb#178
  def irb=(_arg0); end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#187
  def irb_name; end

  # Can be either name from <code>IRB.conf[:IRB_NAME]</code>, or the number of
  # the current job set by JobManager, such as <code>irb#2</code>
  #
  # source://irb//lib/irb/context.rb#187
  def irb_name=(_arg0); end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#190
  def irb_path; end

  # Can be either the #irb_name surrounded by parenthesis, or the
  # +input_method+ passed to Context.new
  #
  # source://irb//lib/irb/context.rb#190
  def irb_path=(_arg0); end

  # The return value of the last statement evaluated.
  #
  # source://irb//lib/irb/context.rb#386
  def last_value; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#184
  def load_modules; end

  # A copy of the default <code>IRB.conf[:LOAD_MODULES]</code>
  #
  # source://irb//lib/irb/context.rb#184
  def load_modules=(_arg0); end

  # source://irb//lib/irb/context.rb#544
  def local_variables; end

  # The top-level workspace, see WorkSpace#main
  #
  # source://irb//lib/irb/context.rb#160
  def main; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#319
  def newline_before_multiline_output; end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#319
  def newline_before_multiline_output=(_arg0); end

  # Whether a newline is put before multiline output.
  #
  # Uses <code>IRB.conf[:NEWLINE_BEFORE_MULTILINE_OUTPUT]</code> if available,
  # or defaults to +true+.
  #
  #     "abc\ndef"
  #     #=>
  #     abc
  #     def
  #     IRB.CurrentContext.newline_before_multiline_output = false
  #     "abc\ndef"
  #     #=> abc
  #     def
  #
  # source://irb//lib/irb/context.rb#319
  def newline_before_multiline_output?; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#220
  def prompt_c; end

  # IRB prompt for continuated statement. (e.g. immediately after an +if+)
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#220
  def prompt_c=(_arg0); end

  # Standard IRB prompt.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#212
  def prompt_i; end

  # Standard IRB prompt.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#212
  def prompt_i=(_arg0); end

  # A copy of the default <code>IRB.conf[:PROMPT_MODE]</code>
  #
  # source://irb//lib/irb/context.rb#208
  def prompt_mode; end

  # Sets the +mode+ of the prompt in this context.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#398
  def prompt_mode=(mode); end

  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#222
  def prompt_n; end

  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#222
  def prompt_n=(_arg0); end

  # IRB prompt for continuated strings.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#216
  def prompt_s; end

  # IRB prompt for continuated strings.
  #
  # See IRB@Customizing+the+IRB+Prompt for more information.
  #
  # source://irb//lib/irb/context.rb#216
  def prompt_s=(_arg0); end

  # Whether #verbose? is +true+, and +input_method+ is either
  # StdioInputMethod or RelineInputMethod or ReadlineInputMethod, see #io
  # for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#379
  def prompting?; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#182
  def rc; end

  # A copy of the default <code>IRB.conf[:RC]</code>
  #
  # source://irb//lib/irb/context.rb#182
  def rc=(_arg0); end

  # A copy of the default <code>IRB.conf[:RC]</code>
  # Alias for #rc
  #
  # source://irb//lib/irb/context.rb#182
  def rc?; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#242
  def return_format; end

  # The format of the return statement, set by #prompt_mode= using the
  # +:RETURN+ of the +mode+ passed to set the current #prompt_mode.
  #
  # source://irb//lib/irb/context.rb#242
  def return_format=(_arg0); end

  # Sets <code>IRB.conf[:SAVE_HISTORY]</code> to the given +val+ and calls
  # #init_save_history with this context.
  #
  # Will store the number of +val+ entries of history in the #history_file
  #
  # Add the following to your +.irbrc+ to change the number of history
  # entries stored to 1000:
  #
  #     IRB.conf[:SAVE_HISTORY] = 1000
  #
  # source://irb//lib/irb/extend-command.rb#297
  def save_history=(*opts, &b); end

  # Sets the return value from the last statement evaluated in this context
  # to #last_value.
  #
  # source://irb//lib/irb/context.rb#390
  def set_last_value(value); end

  # Return a command name if it's aliased from the argument and it's not an identifier.
  #
  # source://irb//lib/irb/context.rb#549
  def symbol_alias(command); end

  # The current thread in this context.
  #
  # source://irb//lib/irb/context.rb#169
  def thread; end

  # source://irb//lib/irb/context.rb#522
  def to_s; end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  #
  # source://irb//lib/irb/context.rb#203
  def use_autocomplete; end

  # Whether colorization is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_AUTOCOMPLETE]</code>
  # Alias for #use_autocomplete
  #
  # source://irb//lib/irb/context.rb#203
  def use_autocomplete?; end

  # Sets <code>IRB.conf[:USE_LOADER]</code>
  #
  # See #use_loader for more information.
  #
  # source://irb//lib/irb/extend-command.rb#297
  def use_loader=(*opts, &b); end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  #
  # source://irb//lib/irb/context.rb#195
  def use_multiline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # Alias for #use_multiline
  #
  # source://irb//lib/irb/context.rb#195
  def use_multiline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#199
  def use_readline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#199
  def use_readline?; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#195
  def use_reline; end

  # Whether multiline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_MULTILINE]</code>
  # backward compatibility
  #
  # source://irb//lib/irb/context.rb#195
  def use_reline?; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  #
  # source://irb//lib/irb/context.rb#199
  def use_singleline; end

  # Whether singleline editor mode is enabled or not.
  #
  # A copy of the default <code>IRB.conf[:USE_SINGLELINE]</code>
  # Alias for #use_singleline
  #
  # source://irb//lib/irb/context.rb#199
  def use_singleline?; end

  # Sets whether or not to use the Tracer library when evaluating statements
  # in this context.
  #
  # See +lib/tracer.rb+ for more information.
  #
  # source://irb//lib/irb/extend-command.rb#297
  def use_tracer=(*opts, &b); end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#323
  def verbose; end

  # Whether verbose messages are displayed or not.
  #
  # A copy of the default <code>IRB.conf[:VERBOSE]</code>
  #
  # source://irb//lib/irb/context.rb#323
  def verbose=(_arg0); end

  # Returns whether messages are displayed or not.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/context.rb#360
  def verbose?; end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#167
  def workspace; end

  # WorkSpace in the current context.
  #
  # source://irb//lib/irb/context.rb#167
  def workspace=(_arg0); end

  # The toplevel workspace, see #home_workspace
  #
  # source://irb//lib/irb/context.rb#165
  def workspace_home; end
end

# source://irb//lib/irb/context.rb#519
IRB::Context::IDNAME_IVARS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/context.rb#517
IRB::Context::NOPRINTING_IVARS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/context.rb#518
IRB::Context::NO_INSPECTING_IVARS = T.let(T.unsafe(nil), Array)

# Extends methods for the Context module
#
# source://irb//lib/irb/extend-command.rb#269
module IRB::ContextExtender
  class << self
    # Evaluate the given +command+ from the given +load_file+ on the Context
    # module.
    #
    # Will also define any given +aliases+ for the method.
    #
    # source://irb//lib/irb/extend-command.rb#295
    def def_extend_command(cmd_name, load_file, *aliases); end

    # Installs the default context extensions as irb commands:
    #
    # Context#eval_history=::   +irb/ext/history.rb+
    # Context#use_tracer=::     +irb/ext/tracer.rb+
    # Context#use_loader=::     +irb/ext/use-loader.rb+
    # Context#save_history=::   +irb/ext/save-history.rb+
    #
    # source://irb//lib/irb/extend-command.rb#285
    def install_extend_commands; end
  end
end

# source://irb//lib/irb/init.rb#426
class IRB::DefaultEncodings < ::Struct
  # Returns the value of attribute external
  #
  # @return [Object] the current value of external
  def external; end

  # Sets the attribute external
  #
  # @param value [Object] the value to set the attribute external to.
  # @return [Object] the newly set value
  def external=(_); end

  # Returns the value of attribute internal
  #
  # @return [Object] the current value of internal
  def internal; end

  # Sets the attribute internal
  #
  # @param value [Object] the value to set the attribute internal to.
  # @return [Object] the newly set value
  def internal=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Installs the default irb extensions command bundle.
#
# source://irb//lib/irb/extend-command.rb#14
module IRB::ExtendCommandBundle
  # Installs alias methods for the default irb commands, see
  # ::install_extend_commands.
  #
  # source://irb//lib/irb/extend-command.rb#230
  def install_alias_method(to, from, override = T.unsafe(nil)); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_change_workspace(*opts, **kwargs, &b); end

  # Displays current configuration.
  #
  # Modifying the configuration is achieved by sending a message to IRB.conf.
  #
  # source://irb//lib/irb/extend-command.rb#36
  def irb_context; end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_current_working_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_debug(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_edit(*opts, **kwargs, &b); end

  # Quits the current irb context
  #
  # +ret+ is the optional signal or message to send to Context#exit
  #
  # Same as <code>IRB.CurrentContext.exit</code>.
  #
  # source://irb//lib/irb/extend-command.rb#29
  def irb_exit(ret = T.unsafe(nil)); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_fg(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_help(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_info(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_jobs(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_kill(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#load, see IrbLoader#irb_load
  #
  # source://irb//lib/irb/extend-command.rb#197
  # def irb_load(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_ls(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_measure(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_pop_workspace(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_push_workspace(*opts, **kwargs, &b); end

  # Loads the given file similarly to Kernel#require
  #
  # source://irb//lib/irb/extend-command.rb#197
  # def irb_require(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_show_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_source(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_whereami(*opts, **kwargs, &b); end

  # source://irb//lib/irb/extend-command.rb#197
  def irb_workspaces(*opts, **kwargs, &b); end

  class << self
    # Evaluate the given +cmd_name+ on the given +cmd_class+ Class.
    #
    # Will also define any given +aliases+ for the method.
    #
    # The optional +load_file+ parameter will be required within the method
    # definition.
    #
    # source://irb//lib/irb/extend-command.rb#185
    def def_extend_command(cmd_name, cmd_class, load_file = T.unsafe(nil), *aliases); end

    # Installs alias methods for the default irb commands on the given object
    # using #install_alias_method.
    #
    # source://irb//lib/irb/extend-command.rb#256
    def extend_object(obj); end

    # Installs the default irb commands.
    #
    # source://irb//lib/irb/extend-command.rb#173
    def install_extend_commands; end

    # source://irb//lib/irb/extend-command.rb#250
    def irb_original_method_name(method_name); end

    # Convert a command name to its implementation class if such command exists
    #
    # source://irb//lib/irb/extend-command.rb#159
    def load_command(command); end
  end
end

# source://irb//lib/irb/extend-command.rb#15
IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

# Use a File for IO with irb, see InputMethod
#
# source://irb//lib/irb/input-method.rb#125
class IRB::FileInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [FileInputMethod] a new instance of FileInputMethod
  #
  # source://irb//lib/irb/input-method.rb#138
  def initialize(file); end

  # source://irb//lib/irb/input-method.rb#172
  def close; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#163
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#150
  def eof?; end

  # The file name of this input method, usually given during initialization.
  #
  # source://irb//lib/irb/input-method.rb#144
  def file_name; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#157
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#168
  def inspect; end

  class << self
    # source://irb//lib/irb/input-method.rb#127
    def open(file, &block); end
  end
end

# source://irb//lib/irb/init.rb#373
IRB::IRBRC_EXT = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/completion.rb#13
module IRB::InputCompletor
  class << self
    # TODO Remove this method after 2.6 EOL.
    #
    # @return [Boolean]
    #
    # source://irb//lib/irb/completion.rb#63
    def absolute_path?(p); end

    # source://irb//lib/irb/completion.rb#460
    def ignored_modules; end

    # source://irb//lib/irb/completion.rb#169
    def retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

    # source://irb//lib/irb/completion.rb#97
    def retrieve_files_to_require_from_load_path; end

    # source://irb//lib/irb/completion.rb#116
    def retrieve_files_to_require_relative_from_current_dir; end

    # source://irb//lib/irb/completion.rb#86
    def retrieve_gem_and_system_load_path; end

    # source://irb//lib/irb/completion.rb#448
    def select_message(receiver, message, candidates, sep = T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/completion.rb#61
IRB::InputCompletor::BASIC_WORD_BREAK_CHARACTERS = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/completion.rb#157
IRB::InputCompletor::CompletionProc = T.let(T.unsafe(nil), Proc)

# source://irb//lib/irb/completion.rb#122
IRB::InputCompletor::CompletionRequireProc = T.let(T.unsafe(nil), Proc)

# source://irb//lib/irb/completion.rb#71
IRB::InputCompletor::GEM_PATHS = T.let(T.unsafe(nil), Array)

# Set of available operators in Ruby
#
# source://irb//lib/irb/completion.rb#446
IRB::InputCompletor::Operators = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/completion.rb#411
IRB::InputCompletor::PerfectMatchedProc = T.let(T.unsafe(nil), Proc)

# Set of reserved words used by Ruby, you should not use these for
# constants or variables
#
# source://irb//lib/irb/completion.rb#40
IRB::InputCompletor::ReservedWords = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/input-method.rb#20
class IRB::InputMethod
  # Creates a new input method object
  #
  # @return [InputMethod] a new instance of InputMethod
  #
  # source://irb//lib/irb/input-method.rb#23
  def initialize(file = T.unsafe(nil)); end

  # The file name of this input method, usually given during initialization.
  #
  # source://irb//lib/irb/input-method.rb#27
  def file_name; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#35
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#57
  def inspect; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#30
  def prompt; end

  # The irb prompt associated with this input method
  #
  # source://irb//lib/irb/input-method.rb#30
  def prompt=(_arg0); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#52
  def readable_after_eof?; end

  # source://irb//lib/irb/input-method.rb#40
  def winsize; end
end

# An irb inspector
#
# In order to create your own custom inspector there are two things you
# should be aware of:
#
# Inspector uses #inspect_value, or +inspect_proc+, for output of return values.
#
# This also allows for an optional #init+, or +init_proc+, which is called
# when the inspector is activated.
#
# Knowing this, you can create a rudimentary inspector as follows:
#
#     irb(main):001:0> ins = IRB::Inspector.new(proc{ |v| "omg! #{v}" })
#     irb(main):001:0> IRB.CurrentContext.inspect_mode = ins # => omg! #<IRB::Inspector:0x007f46f7ba7d28>
#     irb(main):001:0> "what?" #=> omg! what?
#
# source://irb//lib/irb/inspector.rb#44
class IRB::Inspector
  # Creates a new inspector object, using the given +inspect_proc+ when
  # output return values in irb.
  #
  # @return [Inspector] a new instance of Inspector
  #
  # source://irb//lib/irb/inspector.rb#89
  def initialize(inspect_proc, init_proc = T.unsafe(nil)); end

  # Proc to call when the inspector is activated, good for requiring
  # dependent libraries.
  #
  # source://irb//lib/irb/inspector.rb#96
  def init; end

  # Proc to call when the input is evaluated and output in irb.
  #
  # source://irb//lib/irb/inspector.rb#101
  def inspect_value(v); end

  class << self
    # Example
    #
    #     Inspector.def_inspector(key, init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector([key1,..], init_p=nil){|v| v.inspect}
    #     Inspector.def_inspector(key, inspector)
    #     Inspector.def_inspector([key1,...], inspector)
    #
    # source://irb//lib/irb/inspector.rb#64
    def def_inspector(key, arg = T.unsafe(nil), &block); end

    # Determines the inspector to use where +inspector+ is one of the keys passed
    # during inspector definition.
    #
    # source://irb//lib/irb/inspector.rb#54
    def keys_with_inspector(inspector); end
  end
end

# source://irb//lib/irb.rb#439
class IRB::Irb
  # Creates a new irb session
  #
  # @return [Irb] a new instance of Irb
  #
  # source://irb//lib/irb.rb#470
  def initialize(workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://irb//lib/irb.rb#877
  def assignment_expression?(line); end

  # Returns the current context of this irb session
  #
  # source://irb//lib/irb.rb#511
  def context; end

  # source://irb//lib/irb.rb#616
  def convert_invalid_byte_sequence(str, enc); end

  # A hook point for `debug` command's TracePoint after :IRB_EXIT as well as its clean-up
  #
  # source://irb//lib/irb.rb#482
  def debug_break; end

  # source://irb//lib/irb.rb#623
  def encode_with_invalid_byte_sequence(str, enc); end

  # Evaluates input for this session.
  #
  # source://irb//lib/irb.rb#516
  def eval_input; end

  # source://irb//lib/irb.rb#645
  def handle_exception(exc); end

  # Outputs the local variables to this current session, including
  # #signal_status and #context, using IRB::Locale.
  #
  # source://irb//lib/irb.rb#862
  def inspect; end

  # source://irb//lib/irb.rb#824
  def output_value(omit = T.unsafe(nil)); end

  # source://irb//lib/irb.rb#785
  def prompt(prompt, ltype, indent, line_no); end

  # source://irb//lib/irb.rb#492
  def run(conf = T.unsafe(nil)); end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#513
  def scanner; end

  # The lexer used by this irb session
  #
  # source://irb//lib/irb.rb#513
  def scanner=(_arg0); end

  # Handler for the signal SIGINT, see Kernel#trap for more information.
  #
  # source://irb//lib/irb.rb#751
  def signal_handle; end

  # Evaluates the given block using the given +status+.
  #
  # source://irb//lib/irb.rb#773
  def signal_status(status); end

  # Evaluates the given block using the given +context+ as the Context.
  #
  # source://irb//lib/irb.rb#741
  def suspend_context(context); end

  # Evaluates the given block using the given +input_method+ as the
  # Context#io.
  #
  # Used by the irb commands +source+ and +irb_load+, see IRB@IRB+Sessions
  # for more information.
  #
  # source://irb//lib/irb.rb#730
  def suspend_input_method(input_method); end

  # Evaluates the given block using the given +path+ as the Context#irb_path
  # and +name+ as the Context#irb_name.
  #
  # Used by the irb command +source+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#700
  def suspend_name(path = T.unsafe(nil), name = T.unsafe(nil)); end

  # Evaluates the given block using the given +workspace+ as the
  # Context#workspace.
  #
  # Used by the irb command +irb_load+, see IRB@IRB+Sessions for more
  # information.
  #
  # source://irb//lib/irb.rb#716
  def suspend_workspace(workspace); end
end

# source://irb//lib/irb.rb#440
IRB::Irb::ASSIGNMENT_NODE_TYPES = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/locale.rb#13
class IRB::Locale
  # @return [Locale] a new instance of Locale
  #
  # source://irb//lib/irb/locale.rb#26
  def initialize(locale = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#50
  def String(mes); end

  # source://irb//lib/irb/locale.rb#46
  def encoding; end

  # source://irb//lib/irb/locale.rb#125
  def find(file, paths = T.unsafe(nil)); end

  # source://irb//lib/irb/locale.rb#59
  def format(*opts); end

  # source://irb//lib/irb/locale.rb#63
  def gets(*rs); end

  # Returns the value of attribute lang.
  #
  # source://irb//lib/irb/locale.rb#44
  def lang; end

  # source://irb//lib/irb/locale.rb#113
  def load(file, priv = T.unsafe(nil)); end

  # Returns the value of attribute modifier.
  #
  # source://irb//lib/irb/locale.rb#44
  def modifier; end

  # source://irb//lib/irb/locale.rb#71
  def print(*opts); end

  # source://irb//lib/irb/locale.rb#76
  def printf(*opts); end

  # source://irb//lib/irb/locale.rb#81
  def puts(*opts); end

  # source://irb//lib/irb/locale.rb#67
  def readline(*rs); end

  # source://irb//lib/irb/locale.rb#86
  def require(file, priv = T.unsafe(nil)); end

  # Returns the value of attribute territory.
  #
  # source://irb//lib/irb/locale.rb#44
  def territory; end

  private

  # source://irb//lib/irb/locale.rb#164
  def each_localized_path(dir, file); end

  # @yield [nil]
  #
  # source://irb//lib/irb/locale.rb#171
  def each_sublocale; end

  # source://irb//lib/irb/locale.rb#138
  def real_load(path, priv); end

  # typically, for the parameters and a <path> in paths, it searches
  #   <path>/<dir>/<locale>/<file>
  #
  # @param paths load paths in which IRB find a localized file.
  # @param dir directory
  # @param file basename to be localized
  #
  # source://irb//lib/irb/locale.rb#153
  def search_file(lib_paths, dir, file); end

  def toplevel_load(*_arg0); end
end

# source://irb//lib/irb/locale.rb#21
IRB::Locale::LOCALE_DIR = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/locale.rb#15
IRB::Locale::LOCALE_NAME_RE = T.let(T.unsafe(nil), Regexp)

# source://irb//lib/irb/magic-file.rb#3
IRB::MagicFile = T.let(T.unsafe(nil), Object)

# A convenience module for extending Ruby methods.
#
# source://irb//lib/irb/extend-command.rb#312
module IRB::MethodExtender
  # Extends the given +base_method+ with a postfix call to the given
  # +extend_method+.
  #
  # source://irb//lib/irb/extend-command.rb#331
  def def_post_proc(base_method, extend_method); end

  # Extends the given +base_method+ with a prefix call to the given
  # +extend_method+.
  #
  # source://irb//lib/irb/extend-command.rb#315
  def def_pre_proc(base_method, extend_method); end

  # Returns a unique method name to use as an alias for the given +name+.
  #
  # Usually returns <code>#{prefix}#{name}#{postfix}<num></code>, example:
  #
  #     new_alias_name('foo') #=> __alias_of__foo__
  #     def bar; end
  #     new_alias_name('bar') #=> __alias_of__bar__2
  #
  # source://irb//lib/irb/extend-command.rb#352
  def new_alias_name(name, prefix = T.unsafe(nil), postfix = T.unsafe(nil)); end
end

# An output formatter used internally by the lexer.
#
# source://irb//lib/irb/notifier.rb#17
module IRB::Notifier
  private

  # Define a new Notifier output source, returning a new CompositeNotifier
  # with the given +prefix+ and +output_method+.
  #
  # The optional +prefix+ will be appended to all objects being inspected
  # during output, using the given +output_method+ as the output source. If
  # no +output_method+ is given, StdioOutputMethod will be used, and all
  # expressions will be sent directly to STDOUT without any additional
  # formatting.
  #
  # source://irb//lib/irb/notifier.rb#37
  def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end

  class << self
    # Define a new Notifier output source, returning a new CompositeNotifier
    # with the given +prefix+ and +output_method+.
    #
    # The optional +prefix+ will be appended to all objects being inspected
    # during output, using the given +output_method+ as the output source. If
    # no +output_method+ is given, StdioOutputMethod will be used, and all
    # expressions will be sent directly to STDOUT without any additional
    # formatting.
    #
    # source://irb//lib/irb/notifier.rb#37
    def def_notifier(prefix = T.unsafe(nil), output_method = T.unsafe(nil)); end
  end
end

# An abstract class, or superclass, for CompositeNotifier and
# LeveledNotifier to inherit. It provides several wrapper methods for the
# OutputMethod object used by the Notifier.
#
# source://irb//lib/irb/notifier.rb#45
class IRB::Notifier::AbstractNotifier
  # Creates a new Notifier object
  #
  # @return [AbstractNotifier] a new instance of AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#47
  def initialize(prefix, base_notifier); end

  # Execute the given block if notifications are enabled.
  #
  # @yield [@base_notifier]
  #
  # source://irb//lib/irb/notifier.rb#105
  def exec_if; end

  # A wrapper method used to determine whether notifications are enabled.
  #
  # Defaults to +true+.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#59
  def notify?; end

  # Same as #ppx, except it uses the #prefix given during object
  # initialization.
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#88
  def pp(*objs); end

  # Same as #pp, except it concatenates the given +prefix+ with the #prefix
  # given during object initialization.
  #
  # See OutputMethod#ppx for more detail.
  #
  # source://irb//lib/irb/notifier.rb#98
  def ppx(prefix, *objs); end

  # The +prefix+ for this Notifier, which is appended to all objects being
  # inspected during output.
  #
  # source://irb//lib/irb/notifier.rb#54
  def prefix; end

  # See OutputMethod#print for more detail.
  #
  # source://irb//lib/irb/notifier.rb#64
  def print(*opts); end

  # See OutputMethod#printf for more detail.
  #
  # source://irb//lib/irb/notifier.rb#74
  def printf(format, *opts); end

  # See OutputMethod#printn for more detail.
  #
  # source://irb//lib/irb/notifier.rb#69
  def printn(*opts); end

  # See OutputMethod#puts for more detail.
  #
  # source://irb//lib/irb/notifier.rb#79
  def puts(*objs); end
end

# A class that can be used to create a group of notifier objects with the
# intent of representing a leveled notification system for irb.
#
# This class will allow you to generate other notifiers, and assign them
# the appropriate level for output.
#
# The Notifier class provides a class-method Notifier.def_notifier to
# create a new composite notifier. Using the first composite notifier
# object you create, sibling notifiers can be initialized with
# #def_notifier.
#
# source://irb//lib/irb/notifier.rb#122
class IRB::Notifier::CompositeNotifier < ::IRB::Notifier::AbstractNotifier
  # Create a new composite notifier object with the given +prefix+, and
  # +base_notifier+ to use for output.
  #
  # @return [CompositeNotifier] a new instance of CompositeNotifier
  #
  # source://irb//lib/irb/notifier.rb#123
  def initialize(prefix, base_notifier); end

  # Creates a new LeveledNotifier in the composite #notifiers group.
  #
  # The given +prefix+ will be assigned to the notifier, and +level+ will
  # be used as the index of the #notifiers Array.
  #
  # This method returns the newly created instance.
  #
  # source://irb//lib/irb/notifier.rb#139
  def def_notifier(level, prefix = T.unsafe(nil)); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#146
  def level; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#163
  def level=(value); end

  # Returns the leveled notifier for this object
  #
  # source://irb//lib/irb/notifier.rb#146
  def level_notifier; end

  # Sets the leveled notifier for this object.
  #
  # When the given +value+ is an instance of AbstractNotifier,
  # #level_notifier is set to the given object.
  #
  # When an Integer is given, #level_notifier is set to the notifier at the
  # index +value+ in the #notifiers Array.
  #
  # If no notifier exists at the index +value+ in the #notifiers Array, an
  # ErrUndefinedNotifier exception is raised.
  #
  # An ErrUnrecognizedLevel exception is raised if the given +value+ is not
  # found in the existing #notifiers Array, or an instance of
  # AbstractNotifier
  #
  # source://irb//lib/irb/notifier.rb#163
  def level_notifier=(value); end

  # List of notifiers in the group
  #
  # source://irb//lib/irb/notifier.rb#131
  def notifiers; end
end

# source://irb//lib/irb/notifier.rb#18
class IRB::Notifier::ErrUndefinedNotifier < ::StandardError
  # @return [ErrUndefinedNotifier] a new instance of ErrUndefinedNotifier
  #
  # source://irb//lib/irb/notifier.rb#19
  def initialize(val); end
end

# source://irb//lib/irb/notifier.rb#23
class IRB::Notifier::ErrUnrecognizedLevel < ::StandardError
  # @return [ErrUnrecognizedLevel] a new instance of ErrUnrecognizedLevel
  #
  # source://irb//lib/irb/notifier.rb#24
  def initialize(val); end
end

# A leveled notifier is comparable to the composite group from
# CompositeNotifier#notifiers.
#
# source://irb//lib/irb/notifier.rb#181
class IRB::Notifier::LeveledNotifier < ::IRB::Notifier::AbstractNotifier
  include ::Comparable

  # Create a new leveled notifier with the given +base+, and +prefix+ to
  # send to AbstractNotifier.new
  #
  # The given +level+ is used to compare other leveled notifiers in the
  # CompositeNotifier group to determine whether or not to output
  # notifications.
  #
  # @return [LeveledNotifier] a new instance of LeveledNotifier
  #
  # source://irb//lib/irb/notifier.rb#190
  def initialize(base, level, prefix); end

  # Compares the level of this notifier object with the given +other+
  # notifier.
  #
  # See the Comparable module for more information.
  #
  # source://irb//lib/irb/notifier.rb#203
  def <=>(other); end

  # The current level of this notifier object
  #
  # source://irb//lib/irb/notifier.rb#197
  def level; end

  # Whether to output messages to the output method, depending on the level
  # of this notifier object.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#209
  def notify?; end
end

# NoMsgNotifier is a LeveledNotifier that's used as the default notifier
# when creating a new CompositeNotifier.
#
# This notifier is used as the +zero+ index, or level +0+, for
# CompositeNotifier#notifiers, and will not output messages of any sort.
#
# source://irb//lib/irb/notifier.rb#220
class IRB::Notifier::NoMsgNotifier < ::IRB::Notifier::LeveledNotifier
  # Creates a new notifier that should not be used to output messages.
  #
  # @return [NoMsgNotifier] a new instance of NoMsgNotifier
  #
  # source://irb//lib/irb/notifier.rb#221
  def initialize; end

  # Ensures notifications are ignored, see AbstractNotifier#notify? for
  # more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/notifier.rb#229
  def notify?; end
end

# An abstract output class for IO in irb. This is mainly used internally by
# IRB::Notifier. You can define your own output method to use with Irb.new,
# or Context.new
#
# source://irb//lib/irb/output-method.rb#17
class IRB::OutputMethod
  # Returns an array of the given +format+ and +opts+ to be used by
  # Kernel#sprintf, if there was a successful Regexp match in the given
  # +format+ from #printf
  #
  #     %
  #     <flag>  [#0- +]
  #     <minimum field width> (\*|\*[1-9][0-9]*\$|[1-9][0-9]*)
  #     <precision>.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)?
  #     #<length modifier>(hh|h|l|ll|L|q|j|z|t)
  #     <conversion specifier>[diouxXeEfgGcsb%]
  #
  # source://irb//lib/irb/output-method.rb#54
  def parse_printf_format(format, opts); end

  # Prints the given +objs+ calling Object#inspect on each.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#70
  def pp(*objs); end

  # Prints the given +objs+ calling Object#inspect on each and appending the
  # given +prefix+.
  #
  # See #puts for more detail.
  #
  # source://irb//lib/irb/output-method.rb#78
  def ppx(prefix, *objs); end

  # Open this method to implement your own output method, raises a
  # NotImplementedError if you don't define #print in your own class.
  #
  # @raise [NotImplementedError]
  #
  # source://irb//lib/irb/output-method.rb#26
  def print(*opts); end

  # Extends IO#printf to format the given +opts+ for Kernel#sprintf using
  # #parse_printf_format
  #
  # source://irb//lib/irb/output-method.rb#37
  def printf(format, *opts); end

  # Prints the given +opts+, with a newline delimiter.
  #
  # source://irb//lib/irb/output-method.rb#31
  def printn(*opts); end

  # Calls #print on each element in the given +objs+, followed by a newline
  # character.
  #
  # source://irb//lib/irb/output-method.rb#60
  def puts(*objs); end
end

# source://irb//lib/irb/output-method.rb#18
class IRB::OutputMethod::NotImplementedError < ::StandardError
  # @return [NotImplementedError] a new instance of NotImplementedError
  #
  # source://irb//lib/irb/output-method.rb#19
  def initialize(val); end
end

# source://irb//lib/irb/input-method.rb#178
class IRB::ReadlineInputMethod < ::IRB::InputMethod
  # source://irb//lib/irb/input-method.rb#187
  def initialize; end

  # source://irb//lib/irb/input-method.rb#249
  def encoding; end

  # source://irb//lib/irb/input-method.rb#227
  def eof?; end

  # source://irb//lib/irb/input-method.rb#211
  def gets; end

  # source://irb//lib/irb/input-method.rb#254
  def inspect; end

  # source://irb//lib/irb/input-method.rb#244
  def line(line_no); end

  # source://irb//lib/irb/input-method.rb#235
  def readable_after_eof?; end

  class << self
    # source://irb//lib/irb/input-method.rb#179
    def initialize_readline; end
  end
end

# source://irb//lib/irb/input-method.rb#475
class IRB::ReidlineInputMethod < ::IRB::RelineInputMethod
  # @return [ReidlineInputMethod] a new instance of ReidlineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#476
  def initialize; end
end

# source://irb//lib/irb/input-method.rb#264
class IRB::RelineInputMethod < ::IRB::InputMethod
  include ::Reline

  # Creates a new input method object using Reline
  #
  # @return [RelineInputMethod] a new instance of RelineInputMethod
  #
  # source://irb//lib/irb/input-method.rb#268
  def initialize; end

  # source://irb//lib/irb/input-method.rb#317
  def auto_indent(&block); end

  # source://irb//lib/irb/input-method.rb#309
  def check_termination(&block); end

  # source://irb//lib/irb/input-method.rb#313
  def dynamic_prompt(&block); end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#457
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+
  # if there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#435
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#417
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#462
  def inspect; end

  # Returns the current line number for #io.
  #
  # #line counts the number of times #gets is called.
  #
  # See IO#lineno for more information.
  #
  # source://irb//lib/irb/input-method.rb#452
  def line(line_no); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#443
  def readable_after_eof?; end
end

# source://irb//lib/irb/input-method.rb#321
IRB::RelineInputMethod::SHOW_DOC_DIALOG = T.let(T.unsafe(nil), Proc)

# source://irb//lib/irb/input-method.rb#19
IRB::STDIN_FILE_NAME = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/input-method.rb#63
class IRB::StdioInputMethod < ::IRB::InputMethod
  # Creates a new input method object
  #
  # @return [StdioInputMethod] a new instance of StdioInputMethod
  #
  # source://irb//lib/irb/input-method.rb#64
  def initialize; end

  # The external encoding for standard input.
  #
  # source://irb//lib/irb/input-method.rb#114
  def encoding; end

  # Whether the end of this input method has been reached, returns +true+ if
  # there is no more data to read.
  #
  # See IO#eof? for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#85
  def eof?; end

  # Reads the next line from this input method.
  #
  # See IO#gets for more information.
  #
  # source://irb//lib/irb/input-method.rb#75
  def gets; end

  # For debug message
  #
  # source://irb//lib/irb/input-method.rb#119
  def inspect; end

  # Returns the current line number for #io.
  #
  # #line counts the number of times #gets is called.
  #
  # See IO#lineno for more information.
  #
  # source://irb//lib/irb/input-method.rb#109
  def line(line_no); end

  # Whether this input method is still readable when there is no more data to
  # read.
  #
  # See IO#eof for more information.
  #
  # @return [Boolean]
  #
  # source://irb//lib/irb/input-method.rb#100
  def readable_after_eof?; end
end

# A standard output printer
#
# source://irb//lib/irb/output-method.rb#87
class IRB::StdioOutputMethod < ::IRB::OutputMethod
  # Prints the given +opts+ to standard output, see IO#print for more
  # information.
  #
  # source://irb//lib/irb/output-method.rb#88
  def print(*opts); end
end

# source://irb//lib/irb/workspace.rb#15
IRB::TOPLEVEL_BINDING = T.let(T.unsafe(nil), Binding)

# source://irb//lib/irb/version.rb#14
IRB::VERSION = T.let(T.unsafe(nil), String)

# source://irb//lib/irb/workspace.rb#17
class IRB::WorkSpace
  # Creates a new workspace.
  #
  # set self to main if specified, otherwise
  # inherit main from TOPLEVEL_BINDING.
  #
  # @return [WorkSpace] a new instance of WorkSpace
  #
  # source://irb//lib/irb/workspace.rb#22
  def initialize(*main); end

  # The Binding of this workspace
  #
  # source://irb//lib/irb/workspace.rb#112
  def binding; end

  # source://irb//lib/irb/workspace.rb#144
  def code_around_binding; end

  # Evaluate the given +statements+ within the  context of this workspace.
  #
  # source://irb//lib/irb/workspace.rb#118
  def evaluate(context, statements, file = T.unsafe(nil), line = T.unsafe(nil)); end

  # error message manipulator
  #
  # source://irb//lib/irb/workspace.rb#131
  def filter_backtrace(bt); end

  # source://irb//lib/irb/workspace.rb#126
  def local_variable_get(name); end

  # source://irb//lib/irb/workspace.rb#122
  def local_variable_set(name, value); end

  # The top-level workspace of this context, also available as
  # <code>IRB.conf[:__MAIN__]</code>
  #
  # source://irb//lib/irb/workspace.rb#115
  def main; end
end

# :stopdoc:
#
# source://irb//lib/irb/ruby-lex.rb#17
class RubyLex
  # @return [RubyLex] a new instance of RubyLex
  #
  # source://irb//lib/irb/ruby-lex.rb#25
  def initialize; end

  # source://irb//lib/irb/ruby-lex.rb#315
  def check_code_block(code, tokens = T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#604
  def check_corresponding_token_depth(lines, line_index); end

  # source://irb//lib/irb/ruby-lex.rb#534
  def check_newline_depth_difference; end

  # source://irb//lib/irb/ruby-lex.rb#220
  def check_state(code, tokens = T.unsafe(nil), context: T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#712
  def check_string_literal(tokens); end

  # source://irb//lib/irb/ruby-lex.rb#796
  def check_termination_in_prev_line(code, context: T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#246
  def each_top_level_statement(context); end

  # source://irb//lib/irb/ruby-lex.rb#180
  def find_prev_spaces(line_index); end

  # source://irb//lib/irb/ruby-lex.rb#237
  def initialize_input; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#457
  def is_method_calling?(tokens, index); end

  # source://irb//lib/irb/ruby-lex.rb#506
  def is_the_in_correspond_to_a_for(tokens, index); end

  # source://irb//lib/irb/ruby-lex.rb#282
  def lex(context); end

  # source://irb//lib/irb/ruby-lex.rb#294
  def process_continue(tokens = T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#763
  def process_literal_type(tokens = T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#407
  def process_nesting_level(tokens = T.unsafe(nil)); end

  # source://irb//lib/irb/ruby-lex.rb#231
  def prompt; end

  # source://irb//lib/irb/ruby-lex.rb#200
  def set_auto_indent(context); end

  # io functions
  #
  # source://irb//lib/irb/ruby-lex.rb#51
  def set_input(io, p = T.unsafe(nil), context:, &block); end

  # source://irb//lib/irb/ruby-lex.rb#127
  def set_prompt(p = T.unsafe(nil), &block); end

  # source://irb//lib/irb/ruby-lex.rb#475
  def take_corresponding_syntax_to_kw_do(tokens, index); end

  private

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#845
  def heredoc_scope?; end

  # @return [Boolean]
  #
  # source://irb//lib/irb/ruby-lex.rb#850
  def in_keyword_case_scope?; end

  class << self
    # source://irb//lib/irb/ruby-lex.rb#33
    def compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

    # source://irb//lib/irb/ruby-lex.rb#145
    def generate_local_variables_assign_code(local_variables); end

    # source://irb//lib/irb/ruby-lex.rb#149
    def ripper_lex_without_warning(code, context: T.unsafe(nil)); end
  end
end

# source://irb//lib/irb/ruby-lex.rb#136
RubyLex::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

# source://irb//lib/irb/ruby-lex.rb#19
class RubyLex::TerminateLineInput < ::StandardError
  # @return [TerminateLineInput] a new instance of TerminateLineInput
  #
  # source://irb//lib/irb/ruby-lex.rb#20
  def initialize; end
end
