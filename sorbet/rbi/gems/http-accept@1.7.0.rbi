# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http-accept` gem.
# Please instead update this file by running `bin/tapioca gem http-accept`.

module HTTP; end
module HTTP::Accept; end

# A content type is different from a media range, in that a content type should not have any wild cards.
class HTTP::Accept::ContentType < ::HTTP::Accept::MediaTypes::MediaRange
  # @raise [ArgumentError]
  # @return [ContentType] a new instance of ContentType
  def initialize(mime_type, parameters = T.unsafe(nil)); end
end

module HTTP::Accept::Encodings
  class << self
    # Parse the list of browser preferred content codings and return ordered by priority. If no
    # `Accept-Encoding:` header is specified, the behaviour is the same as if
    # `Accept-Encoding: *` was provided, and if a blank `Accept-Encoding:` header value is
    # specified, the behaviour is the same as if `Accept-Encoding: identity` was provided
    # (according to RFC).
    def browser_preferred_content_codings(env); end

    def parse(text); end
  end
end

HTTP::Accept::Encodings::CODINGS = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc7231#section-5.3.4
HTTP::Accept::Encodings::CONTENT_CODING = T.let(T.unsafe(nil), Regexp)

class HTTP::Accept::Encodings::ContentCoding < ::Struct
  # Returns the value of attribute encoding
  #
  # @return [Object] the current value of encoding
  def encoding; end

  # Sets the attribute encoding
  #
  # @param value [Object] the value to set the attribute encoding to.
  # @return [Object] the newly set value
  def encoding=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  def q=(_); end

  def quality_factor; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    def parse(scanner); end
  end
end

HTTP::Accept::Encodings::HTTP_ACCEPT_ENCODING = T.let(T.unsafe(nil), String)
HTTP::Accept::Encodings::IDENTITY_CONTENT_CODING = T.let(T.unsafe(nil), HTTP::Accept::Encodings::ContentCoding)

# https://tools.ietf.org/html/rfc7231#section-5.3.1
HTTP::Accept::Encodings::QVALUE = T.let(T.unsafe(nil), Regexp)

HTTP::Accept::Encodings::WILDCARD_CONTENT_CODING = T.let(T.unsafe(nil), HTTP::Accept::Encodings::ContentCoding)

module HTTP::Accept::Languages
  class << self
    def parse(text); end
  end
end

# https://greenbytes.de/tech/webdav/rfc7231.html#quality.values
HTTP::Accept::Languages::LANGUAGE_RANGE = T.let(T.unsafe(nil), Regexp)

# https://tools.ietf.org/html/rfc3066#section-2.1
HTTP::Accept::Languages::LOCALE = T.let(T.unsafe(nil), Regexp)

class HTTP::Accept::Languages::LanguageRange < ::Struct
  # Returns the value of attribute locale
  #
  # @return [Object] the current value of locale
  def locale; end

  # Sets the attribute locale
  #
  # @param value [Object] the value to set the attribute locale to.
  # @return [Object] the newly set value
  def locale=(_); end

  # Returns the value of attribute q
  #
  # @return [Object] the current value of q
  def q; end

  # Sets the attribute q
  #
  # @param value [Object] the value to set the attribute q to.
  # @return [Object] the newly set value
  def q=(_); end

  def quality_factor; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    def parse(scanner); end
  end
end

# Provides an efficient data-structure for matching the Accept-Languages header to set of available locales according to https://tools.ietf.org/html/rfc7231#section-5.3.5 and https://tools.ietf.org/html/rfc4647#section-2.3
class HTTP::Accept::Languages::Locales
  # @return [Locales] a new instance of Locales
  def initialize(names); end

  # Returns the intersection of others retaining order.
  def &(languages); end

  def +(others); end
  def each(&block); end
  def freeze; end

  # @return [Boolean]
  def include?(locale_name); end

  def join(*args); end

  # Returns the value of attribute names.
  def names; end

  # Returns the value of attribute patterns.
  def patterns; end

  def to_a; end

  class << self
    def expand(locale, into); end
  end
end

# https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.9
HTTP::Accept::Languages::QVALUE = T.let(T.unsafe(nil), Regexp)

# Parse and process the HTTP Accept: header.
module HTTP::Accept::MediaTypes
  class << self
    # Parse the list of browser preferred content types and return ordered by priority. If no `Accept:` header is specified, the behaviour is the same as if `Accept: */*` was provided (according to RFC).
    def browser_preferred_media_types(env); end

    def parse(text, normalize_whitespace = T.unsafe(nil)); end
  end
end

HTTP::Accept::MediaTypes::HTTP_ACCEPT = T.let(T.unsafe(nil), String)

# According to https://tools.ietf.org/html/rfc7231#section-5.3.2
HTTP::Accept::MediaTypes::MIME_TYPE = T.let(T.unsafe(nil), Regexp)

# Map a set of mime types to objects.
class HTTP::Accept::MediaTypes::Map
  # @return [Map] a new instance of Map
  def initialize; end

  # Add a converter to the collection. A converter can be anything that responds to #content_type. Objects will be considered in the order they are added, subsequent objects cannot override previously defined media types. `object` must respond to #split('/', 2) which should give the type and subtype.
  def <<(object); end

  def [](media_range); end
  def []=(media_range, object); end

  # Given a list of content types (e.g. from browser_preferred_content_types), return the best converter. Media types can be an array of MediaRange or String values.
  def for(media_types); end

  def freeze; end
end

HTTP::Accept::MediaTypes::Map::WILDCARD = T.let(T.unsafe(nil), String)

# A single entry in the Accept: header, which includes a mime type and associated parameters.
class HTTP::Accept::MediaTypes::MediaRange < ::Struct
  def ===(other); end

  # Returns the value of attribute mime_type
  #
  # @return [Object] the current value of mime_type
  def mime_type; end

  # Sets the attribute mime_type
  #
  # @param value [Object] the value to set the attribute mime_type to.
  # @return [Object] the newly set value
  def mime_type=(_); end

  # Returns the value of attribute parameters
  #
  # @return [Object] the current value of parameters
  def parameters; end

  # Sets the attribute parameters
  #
  # @param value [Object] the value to set the attribute parameters to.
  # @return [Object] the newly set value
  def parameters=(_); end

  def parameters_string; end
  def quality_factor; end
  def split(on = T.unsafe(nil), count = T.unsafe(nil)); end
  def to_s; end
  def to_str; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end

    # @raise [ParseError]
    def parse(scanner, normalize_whitespace = T.unsafe(nil)); end

    def parse_parameters(scanner, normalize_whitespace); end
  end
end

HTTP::Accept::MediaTypes::PARAMETER = T.let(T.unsafe(nil), Regexp)
HTTP::Accept::MediaTypes::WILDCARD_MEDIA_RANGE = T.let(T.unsafe(nil), HTTP::Accept::MediaTypes::MediaRange)
class HTTP::Accept::ParseError < ::ArgumentError; end
HTTP::Accept::QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

module HTTP::Accept::QuotedString
  class << self
    # Quote a string if required. Doesn't handle newlines correctly currently.
    def quote(value, force = T.unsafe(nil)); end

    # Unquote a "quoted-string" value according to https://tools.ietf.org/html/rfc7230#section-3.2.6
    # It should already match the QUOTED_STRING pattern above by the parser.
    def unquote(value, normalize_whitespace = T.unsafe(nil)); end
  end
end

module HTTP::Accept::Sort
  class << self
    # This sorts items with higher priority first, and keeps items with the same priority in the same relative order.
    def by_quality_factor(items); end
  end
end

# According to https://tools.ietf.org/html/rfc7231#appendix-C
HTTP::Accept::TOKEN = T.let(T.unsafe(nil), Regexp)

HTTP::Accept::VERSION = T.let(T.unsafe(nil), String)
